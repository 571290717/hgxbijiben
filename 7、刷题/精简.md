# 精简

```
1、自我介绍
#你好面试官，我叫xxx，21年毕业于沈阳理工大学，信息管理与信息系统专业，主要学习方向是信息系统，在大学期间有前端开发的实习经历，后通过校招进入珠海格力电器从事软件测试工程师工作，主要负责公司软件的功能测试、性能测试工作，我个人对测试行业也很有兴趣、在格力工作期间也是提前两个月转正、从一开始的功能测试做起，到现在已经能带领其他测试组成员合作测试任务了。
个人掌握的技能也包括测试基础、测试工具的使用、Python数据库、数据库、测试框架、已经基础的前端知识和后端Django框架，自己也尝试过编写自动化测试脚本，结合tkinter的窗口脚本、和简单的Django项目。




Good morning !
It is really my honor to have this opportunity for an interview,
I hope i can make a good performance today. I'm confident that I can succeed.Now i will introduce myself briefly
I am 25 years old,born in HeBei province .
I was graduated from Chongqing University of Posts and Telecommunications. My major is Visual Desgin.and i got my bachelor degree after my graduation in the year of 2021.
I spend most of my time on study. and i have acquired basic knowledge of my major during my school time.
In July 2021, I began to do design support in Zhuhai Gree Electric Appliance Co., Ltd. I am mainly responsible for the interaction and visual design of data visualisation. Because I have the ability to take on more responsibilities and change my working environment, I want to find a more challenging job. 
Morover Motorola is a global company, so I feel I can gain the most from working in this kind of company ennvironment. That is the reason why I come here to compete for this position.
I think I'm a good team player and I'm a person of great honesty to others. Also I am able to work under great pressure.
That’s all. Thank you for giving me the chance.





2、为什么离职
1、以目前的工资水平我可能再工作10年也没办法买房子
2、我朋友们也在广州发展，他们也希望我和他们一起都在广州发展


3、介绍一个项目，你在其中的具体工作

格慧招二期：该项目的项目背景是原一期的系统功能已无法满足人力部处理校招流程的复杂需求，在一期的系统上迭代出二期项目，在该项目中我注意负责后台校园招聘模块的用例编写测试、和对系统关键接口进行接口测试和接口压力测试。该项目前端是微信小程序模式，后台管理端是web页面，其中前端主要功能有有登录、上传面试资料、签约、入职资料等资料，后台管理端，主要进行查看、审核面试、签约、入职等资料发放offer邮件、邮寄三方资料、处理违约流程、手动标记或转移各阶段状态、配置业务逻辑等操作。在该项目中我个人设计了500多条测试用例并进行测试占这个项目测试用例60%，我还负责该项目的性能测试，主要工作内容是对该系统的主要接口进行压力测试，包括设计性能测试用例，搭建设性能测试环境，进行性能测试并监控，以及编制性能测试报告。
3．系统功能需求（必填）	9
3.1后台管理系统	10
3.1.1登录	10
3.1.2首页-工作台	10
3.1.3人工审核身份信息	11
3.1.4校园招聘管理-面试资料管理	11
3.1.5校园招聘管理-offer资料管理	13
3.1.6校园招聘管理-签约资料管理	15
3.1.8通知模板	24
3.1.9 角色管理	25
3.1.10 管理员管理	25
3.2微信小程序端	25
3.2.1登录	25
3.2.2首次登录（身份验证）	26
3.2.3忘记密码	26
3.2.4功能页	26
该模块展示需要进行签约审核的学生基础信息及管理员的签约审核信息。模块功能：管理员在后台上传需要进行签约资料审核的学生基础信息，短信通知学生提交签约资料，管理员逐一审核学生提交的签约资料是否合格，并将审核结果短信通知学生。根据学生是否提交三方邮寄单号及是否申请违约，将学生签约资料大致区分为：三方待确认（学生未提交三方邮寄单号）、三方邮寄中（学生已提交三方邮寄单号）、三方OK（管理员已收到纸质版三方资料）、已签约（签约资料审核通过，返邮三方资料给学生）、违约中（管理员处理学生提交的违约申请）、已违约（违约申请处理完毕）。下面详细说明各个小模块的页面功能：








网络安全维修平台，目前公司有多个防护系统和安全设备，登录方式和告警阈值不统一，造成信息安全运营碎片化的情况越来越严重，信息安全工程往往需要一台一台的登录安全设备，逐台设备处理告警，无法跨素食别网络中的高威胁的攻击行为，并作出处理，然后该系统就是采集各安全设备的警告信息，进行汇总，可进行警告信息分类、查询、定时汇报、发送邮件、发送短信提醒等。主要包含事件查看、策略总览、敏感字典配置、告警策略配置等模块，在该项目在，我主要负责带来另外两名测试组同学组织进行测试，主要负责有测试计划编写，汇总测试用例，编写测试报告，递交测试报告，结项入档，最终在规定日期前提前完成两周该项目。




一、项目背景
1.1、项目背景意义
现关于格力成品物流的招投标工作，全流程均无系统管控，招标相关文件均以线下邮寄的方式互相传递，成本高、效率低且数据不易存档。人工收集各运输公司报价并对其进行对比分析，工作量大，人工操作效率低、易出错。招标进度无法清晰的呈现，管理难度大。 
现计划通过计算机系统，实现办公自动化功能和资料管理功能。有效控制招投标整个流程，详细记录各种数据，同时满足公司业务需求和管理要求。原先互相邮寄纸质的资料均可直接生成电子文档自动发送，高效且易存档；系统审批自动流转，流程清晰、可控；系统自动分析报价数据代替人为手工处理报表，高效、精准的分析报告为领导决策提供支持。


1.2、项目核心目标
1、实现商务招投标业务系统化管理。
2、收集社会运力资源，满足新零售业态下快速增长的商务招投标需求。
3、管理创新及管理改善：从手工作业到系统管理。改变信息传递方式，由纸质资料传递变为电子文档传递。

3．系统功能需求（必填）	9
3.1基础设置	9
3.1.1 业务字段管理	9
3.1.2 业务模型设置	9
3.1.3 银行账号设置	11
3.1.4 权重占比设置	12
3.1.5 运输公司排名	12
3.1.6 历史运量信息表	13
3.2运输公司申请账号及注册	14
3.2.1 注册申请（公网）	14
3.2.2 正式注册	14
3.3运输公司资质管理	15
3.3.1 初审	15
3.3.2 复审	16
3.3.3 运输公司分组	17
3.3.4 注册账号流程	18
3.4招投标	18
3.4.1 资质审批申请	18
3.4.2 运输公司资质审批	20
3.4.3 运输公司邀约	22
3.4.4 运输公司确认是否接受邀约	23
3.4.5 维护承运商类型	24
3.4.6 缴纳竞价保证金通知	24
3.4.7 运输公司上传缴纳保证金证明	27
3.4.8 财务确认上传保证金	28
3.4.9 商务专员发放招标文件	29
3.4.10 运输公司报价	31
3.4.11 格力议价	32
3.4.12 确认议价	33
3.4.13 报价分析	34
3.4.14 初定承运商导入	35
3.4.15 初定承运商审核	36
3.5临时运输	38
3.5.1 新增运输需求	38
3.5.2 运输公司报价	39
3.5.3 格力议价	41
3.5.4 运输公司确认议价	42
3.5.5 报价分析	42
3.5.6 初定承运商	43
3.5.7 传运输凭证	45
3.5.8 付款申请	46
3.5.9 付款申请审批	47
3.6数据统计分析	49
3.6.1 招投标数据分析	49
3.6.2 零担价格分析	50
3.6.3 历史承运商分析表	51
3.6.4 临时发运明细表	52
3.6.5 临时运输汇总分析	52
3.6.6 临时发运付款明细表	53

```



















目录

​	1、测试基础

测试用例设计方法：

黑：

等价类划分、边界值分析法、错误猜测法、正交实验法、场景法、因果图法、判定表法、功能图法

白：

语句覆盖、判定覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖、修改条件覆盖

测试计划和测试报告编写：。。。

测试工具的使用：。。

抓包工具：fiddler、charles（收费）

接口测试工具：postman、jmeter、spipost、apifox

用例编写工具：xmind、excel

bug管理工具：禅道、jira（英文收费）

接口管理工具： yapi平台

2、计算机基础

数据结构与算法

时间/空间复杂度

数据结构（数组、字符串、队列、栈、链表、集合、哈希表、）

算法（排序、查找、双指针、分治、递归、回溯、贪心等）

计算机网络

网络分词模型

网络传输过程

IP、端口

http、https协议

UDP、tcp协议

地址解析协议(ARP)

网络安全

DNS域名解析

操作系统

操作系统的组成

进程、线程

进程、线程间的通讯方式

进程调度算法

进程、线程同步方式

进程、线程状态

死锁

内存管理

mysql搭建

sql命令编写

约束

索引

事务

锁机制

设计数据库表

性能优化

Linux（基本命令、shell脚本）

Linux系统安装

环境变量

常用命令

常用环境搭建

shell脚本编程



3、编程语言

python基础

Python安装、开发工具使用、变量、运算符合表达式、流程控制、基本数据结构、函数、面对对象编程、模块、包、异常处理、文件操作、函数进阶、正则表达式、数据库编程、编发编程、网络编程以及第三方库使用（request、openpyxl、nose、faker、datafaker）



4、web框架

Python的web框架：Django、Flask  、fastAPI 、Django REST framework



5、开发知识

git、redis缓存、rabbiMQ消息队列、



6、平台开发

需要自己手动搭建：

包括像监控平台、接口自动化测试平台、压测平台。。。

写小程序



7、持续学习

​			前端，HTML、CSS、javaScript、vue，

不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，

Vue + SpringBoot 

还是很香的。

然后是后端，Redis高级操作、kafka、Nginx网关、Dobbo、微服务（spring cloud），学会如何使用中间件并不难，先能够独立使用，了解他们的应用场景；



最后是测试，可以学习性能测试、大数据测试、算法测试等





















## Python

python列表反转的4种方法

```python
# reverse()方法
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a.reverse()
print('列表反转结果：', a)

# 内置reversed()函数
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = reversed(a)
print('列表反转结果（迭代对象）：', a1)
print('列表反转结果转换成列表：', list(a1))

# 切片实现反转
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
print('列表反转结果：', a[::-1])


# 使用for循环
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = [a[len(a)-i-1] for i in range(len(a))]
print('列表反转结果：', a1)




**This is a sample   -->  SAMPLE A IS tHIS**


class solution:
    def trans(self,s,n):
        if n==0 :
            return s
        res = " "
        for i in range(n):
            if s[i]<='Z' and s[i]>='A':
                res +=chr(ord(s[i]) - ord('A') + ord('a'))
            elif s[i] >='a' and s[i]<='z':
                res +=chr(ord(s[i]) - ord('a') + ord('A'))
            else:
                res +=s[i]
        res = list(res.split(' '))[::-1]
        return  ' '.join(res)
    
        
if __name__ == "__main__""
	s = solution()
    s2 = s.trans("dqw dwq",7)
    print(s2)
    


```

3、SQL

```mysql
5. 小结
	登录数据库: mysql -uroot -p
查看所有数据库：show databases;
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
show tables；
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件
as 起名字 ： select id as 序号 ，name as 名字，gender as 性别 from students；
distinct 去重： select distinct 列1。。。 from 表名；

小结：
常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null

4. 模糊查询
	like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
	例1：查询姓黄的学生:
select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:
select * from students where name like '黄_';
3：查询姓黄或叫靖的学生:
select * from students where name like '黄%' or name like '%靖';



排序
select * from 表名 order by 列1 asc | desc【列2 ，asc|desc]
asc  小到大升
desc 大到小降
分页
select * from 表名 limit start count
start （开始的索引 默认0 ，count 查询条数）
小结
count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值

分组查询基本
GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

内连接查询语法格式:
select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2


左连接查询语法格式:
select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2

右连接查询语法格式:
select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2

查询所有价格大于平均价格的商品，并且按价格降序排序
 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;
 
 
 select id，name，price from goods
 where price >(select round(avg(price),2) as avg_price form goods)
 order by price desc;
 
 show engines; 看goods表的创表语句:
 
 查看表中已有索引:  show	index from 表名;
 
 
 索引的创建:  alter table classes add index my_name (name);
 
 删除索引  ：drop index index_name;
 
 
 -- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;

索引是加快数据库的查询速度的一种手段
创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
删除索引使用: alter table 表名 drop index 索引名;











```





5、装饰器



```python
import time
 
#  装饰器run_time,@run_time加在谁头上，谁就是参数fun
def run_time(fun):
 
    start_time = time.time()
    fun()
    end_time = time.time()
 
    print("程序运行时间为：{} 秒".format(str(round((end_time - start_time), 1))))
    return end_time - start_time
 
#  耗时任务task
@run_time
def task():
    time.sleep(3)
    
    
```

快速排序

```python
#快速排序
def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟`


#选择排序
def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]
     return li

li = [1,46,89,1,3,6,9]
print(select_sort(li))



#快速排序
def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分

li = [5,6,9,8,3]
quick_sort(li,0,len(li)-1)
print(li)


```



# Linux



1、查找文件

 find  /目录 -name filename.txt

2、查看一个程序是否运行   				ps         -ef|grep     进程名字

​				grep 命令的基本格式			 grep [选项] 模式 文件名

3、终止线程							kill  -9  进程号

4、查看文件包含的隐藏文件    		ls  -al 

5、查看当前工作目录					  pwd

6、复制文件包含其子文件到自定义目录			cp 	 -r	sourceFolder   targetFolder

7、创建目录						mkdir	newfolder

8、删除目录					rmdir  【 】 documents    -v显示详细执行过程   -p 删除指定目录及子空目录

9、删除文件包括其子文件		rm 		-rf 		deletefile

10、移动文件 		mv  	/temp/movefile		/targetfolder 	+		mv  oldnamefile	newnamefile

11、切换用户 		su 	-username

12、修改文件权限		chmod	777   	file        -rwxrwxrwx

13、压缩文件		tar		-czf		test.tar.gz  	/test1/test2

14、列出压缩文件列表	tar 	-tzf	test.tar.gz

15、解压文件			tar 	-xvzf		test.tar.gz

16、查看文件头10行		head		-n		10		example.txt

17、查看文件尾10行		tail			-n		10	example.txt

18、查看日志文件 			tail			-f		example.log 	

 19 、启动vi编辑器			vi

20、查看系统当前时间		date		

21、 cd

22、ls

23、grep 		grep [选项] 模式 文件名	grep CLERK emp.data

如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下：grep -c CLERK emp.data

搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：grep ^78     emp.data

24、find

25、mkdir

26、cp -a file1 file2				cp file1 file2 file3 	dir

27.mv

28.rm -fr dir

29.ps  -a     ps  -ef

30. netstat -a      # 列出所有端口

    netstat -at     # 列出所有TCP端口

    netstat -au    # 列出所有UDP端口

    netstat -ax    # 列出所有unix端口

    netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名



一、linux管理和目录命令
pwd 显示当前路径地址
cd 改变当前用户的目录
ls 查看当前文件夹下的文件
mkdir  新建文件夹目录
rmdir  删除文件夹目录
touch  新建文件
cat    查看文本内容
mv     移动
cp	复制
rm	删除
grep	字符串查找

二、线上查找
man 查看当前或者一个命令的使用方法
locate 根据一个关键字或者关键词定位
whatis 查看某个命令的含义
三、文件阅读命令
head	从头开始查看
tail 	从尾开始查看
more	分页查看
四、文件或目录的压缩和解压缩
tar 
gzip
bizip2
gunzip
bunzip
五权限管理
chmod	修改权限
useradd	用户添加
userdel 用户删除
su	切换用户
passwd	修改密码
chgrp	修改文件所在组
chown	用来修改文件的所有者
六、文件的定位和查找
which  定位
whereis	查找
七、磁盘操作
df 查看文件系统使用情况
du 查看文件磁盘占用情况
八、系统命令
reboot重启
shutdown 关机
halt	关机
ps	进程
toop	进程
date	日期
cal	日历
exit	退出
kill	结束进程
九网络
ipconfig 显示网络状态
ping	监测主机
netstat	知道整个linux系统的网络情况或显示网络状态

netstat -a # 列出所有端口

netstat -at # 列出所有TCP端口

netstat -au # 列出所有UDP端口

netstat -ax # 列出所有unix端口

netstat -atnlp # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名

top 查看cpu、内存密集使用的动态数据
free 查看内存使用情况
du 查看目录或文件的大小
df 查看磁盘分区的大小
cd 切换目录
ls 显示目录中的内容
cat 查看文件中的数据
vi 进入打开、修改、保存文件
rm 删除目录或者文件
mkdir 创建目录
touch 如果一个文件不存在，则创建文件，如果一个文件存在，则修改最后的访问时间
cp拷贝目录或文件



# 两种 HTTP 请求方法：GET 和 POST

- **GET** - 从指定的资源请求数据。
- **POST** - 向指定的资源提交要被处理的数据。

**Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：**

-  **1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。**
-  **2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。**
-  **3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。**
-  **4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。**
-  **5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。**
-  **6、Get 是 Form 的默认方法。**

**使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。**

 **当我们在浏览器地址上输入一个网址时，浏览器会进行(HTTP)HTTPS的的请求时，基本根据以下步骤。**
​    
​        **1.通过DNS解析域名获取服务器IP。**

**首先，浏览器会根据当前网址域名去DNS服务器上进行解析请求，然后DNS服务器会请求到当前域名所对应的服务器IP地址，并将此IP地址返回给浏览器，浏览器再通过该浏览器访问当前服务器。****

​        **2.通过三次握手与服务器建立连接。**

**此时，在应用层是HTTP(HTTPS)协议，当进行到传输层时，服务器会通过TCP协议进行三次握手，首先客户端发送一个连接数据包给服务器(SYN = 1)，接着服务器会响应一个数据包给客户端，代表允许建立连接，然后客户端再发送一个数据包给客户端代表此时连接建立成功，-->-->**

​        **3.如果为HTTPS请求，则需要通过SSL证书加密。**

**如果是HTTPS协议，服务器首先会发送一个SSL证书给浏览器，浏览器检查当前证书是否过期以及证书是否安全，如果安全，则产生一个随机密钥通过SSL证书的公钥进行加密，将密钥发送给服务器端，服务器端根据自己的私钥对发送过来的密钥进行解密，**

​        **4.进行传输内容。**

**得到随机密钥后，通过随机密钥对要传输的内容加密，然后发送给服务器端，**

​        **5.TCP连接是否为长连接？**

TCP连接在这个过程中，还是基于TCP协议进行报文的发送与接收。如果说浏览器的connection = Keep-alive，代表本次TCP连接是一个长连接，不会主动释放连接，当传输内容完毕后，需要主动释放连接，**

​        **6.通过四次挥手释放连接**

**此时需要客户端发送挥手报文(FIN = 1)，服务器接收到后会发送一个确认报文，如果有未发送完的数据，接着发送数据，如果数据发送完毕，此时服务器会再发送一个数据包(FIN = 1,ACK = 1)给浏览器，浏览器再发送一个确认数据包给服务器，四次握手结束，这就是一个完整的访问网页的过程。**





**进程(Process)：进程是计算机中的程序关于某数据集合的一次运行实例，是操作系统进行资源分配的最小单位**
**线程(Thread)：线程被包含在进程之中，是操作系统进行程序调度执行的最小单位**
**协程(Coroutine)：协程是用户态执行的轻量级编程模型，由单一线程内部发出控制信号进行调度**





迭代器与生成器的区别：
（1）生成器：
生成器本质上就是一个函数，它记住了上一次返回时在函数体中的位置。
对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。
而且记录了程序执行的上下文。
生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。

（2）迭代器

迭代器是一种支持next()操作的对象。它包含了一组元素，当执行next()操作时，返回其中一个元素。
当所有元素都被返回后，再执行next()报异常—[StopIteration](https://so.csdn.net/so/search?q=StopIteration&spm=1001.2101.3001.7020)
生成器一定是可迭代的，也一定是迭代器对象

（3）区别：
①生成器是生成元素的，迭代器是访问集合元素的一中方式
②迭代输出生成器的内容
③迭代器是一种支持next()操作的对象
④迭代器（iterator）：其中iterator对象表示的是一个数据流，可以把它看做一个有序序列，但我们不能提前知道序列的长度，只有通过nex()函数实现需要计算的下一个数据。可以看做生成器的一个子集。





装饰器本质上是一个Python函数(其实就是闭包)，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。









建立连接的方式又称为三次握手：

（1）第一次握手，主机A向主机B发出请求数据包：“我想给你发数据，可以吗？”这是第一次对话。

（2）第二次握手，主机B向主机A发送同意连接，并要求同步的数据包（同步就是两台主机协调工作，一台在发送，一台在接收）：“可以，你什么时候发？”这是第二次对话。

（3）第三次握手，主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接收吧！”这是第三次对话。

这三次对话的目的是使数据包的发送和接收同步，TCP协议是一定要经过这三次对话之后，主机A才可以向主机B正式发送数据。


TCP建立连接需要进行三次握手，但是断开连接却要进行四次挥手：

（1）第一次挥手，在主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求。

（2）第二次挥手，主机B收到FIN位置上的1信息后对其做出响应，确认这一方向上的TCP连 接将关闭，将ACK置1。

（3）第三次挥手，B主机再提出反方向的关闭请求，并将控制位FIN置1，发送给A主机，并关闭连接。

（4）第四次挥手，主机A对主机B的请求进行确认，将ACK置1，并关闭连接，至此双方关闭连接。





一、TCP和UDP是什么？
TCP：传输控制协议(Transmission Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信 协议。由IETF的RFC 793定义。

UDP：用户数据报协议(User Datagram Protocol)，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。由RFC 768描述了UDP。

二、TCP与UDP的区别是什么？
1、连接方面

TCP面向连接(如打电话先拨号建立连接)。

UDP无连接，即发送数据报之前不用建立连接。

2、安全方面

TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达。

UDP尽最大努力交付，即不保证可靠交付。

3、传输效率

TCP传输效率较低，UDP传输效率较高。

4、连接数量的区别

TCP连接只能是一对一、点对点的。

UDP支持一对一、一对多、多对一和多对多的交互通信。

5、首部

TCP报文首部20个字节，UDP首部8个字节。

6、可靠

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

7、面向方式

TCP面向字节流。实际上是TCP把数据看成一串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题。

UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

| unittest                             | pytest                                 |
| ------------------------------------ | -------------------------------------- |
| 测试类里面需要继承unittest。TestCase | 不需要继承，可以是一个函数，也可以是类 |
| 参数化需要依赖第三方的库             | 不需要依赖，直接使用内部到parametrize  |
| 测试报告HTMLTestRunner               | Pytest-html 或者是allure               |
| 没有插件                             | 有很丰富的 插件                        |
| 不支持失败重试                       | 支持失败重试                           |





黑盒测试：常用的测试用例设计方法有: **等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果图法、功能图法**.

白盒测试：

语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖、修改条件覆盖













一、网络 7 层架构(ISO/OSI协议参考模型)
	物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
	数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
	网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
	传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。
	会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
	表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
	应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。





TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。



HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 





2.1 TCP对应的应用层协议
 FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
 Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
 SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
 POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
 HTTP：从Web服务器传输超文本到本地浏览器的传送协议。
2.2 UDP对应的应用层协议
 DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
 TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务





体系	作用
	物理层	通过媒介传输比特,确定机械及电气规范（比特Bit）
	数据链路层	将比特组装成帧和点到点的传递（帧Frame）
	网络层	负责数据包从源到宿的传递和网际互连（包PackeT）
	传输层	提供端到端的可靠报文传递和错误恢复（段Segment）
	会话层	建立、管理和终止会话（会话协议数据单元SPDU）
	表示层	对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
	应用层	允许访问OSI环境的手段（应用协议数据单元APDU）





2. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。典型的算法：DES
     由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。典型的算法：RSA

3. Get与POST的区别
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
   GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
   GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

4. ipconfig和netstat的作用？
   ipconfig显示当前TCP/IP配置的信息，帮助用户查看网络状况，可以看到很多网络信息，比如延迟，IP，主机信息，物理地址信息等。
   netstat主要用于提供系统的接口命令。可以使用相关参数打印出每一个接口的MTU、输入分组数、输入错误、冲突以及当前的输出队列长度。







# python3方法

| print（）                                                    | print('a','b','c',sep=",",end=",") |
| ------------------------------------------------------------ | ---------------------------------- |
| **变量[头下标:尾下标:步长]**                                 |                                    |
| isinstance(a, int)                                           | True                               |
| \# 通过空格将字符串分隔符，把各个单词分隔为列表              | inputWords = input.split(" ")      |
| \# 翻转字符串  \# 第一个参数 -1 表示最后一个元素<br/>  \# 第二个参数为空，表示移动到列表末尾<br/>  \# 第三个参数为步长，-1 表示逆向 | inputWords=inputWords[-1::-1]      |
| \# 重新组合字符串                                            | output = ' '.join(inputWords)      |
|                                                              |                                    |

print（）

print('a','b','c',sep=",",end=",")



\# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')

**print**(a - b)   # a 和 b 的差集

**print**(a | b)   # a 和 b 的并集

**print**(a & b)   # a 和 b 的交集

**print**(a ^ b)   # a 和 b 中不同时存在的元素





dict = {}
dict['one'] = "1 - 菜鸟教程"
dict[2]   = "2 - 菜鸟工具"

tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}
**print** (dict['one'])    # 输出键为 'one' 的值
**print** (dict[2])      # 输出键为 2 的值
**print** (tinydict)      # 输出完整的字典
**print** (tinydict.keys())  # 输出所有键
**print** (tinydict.values()) # 输出所有值



\>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
{'Runoob': 1, 'Google': 2, 'Taobao': 3}
\>>> {x: x**2 **for** x **in** (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
\>>> dict(Runoob=1, Google=2, Taobao=3)
{'Runoob': 1, 'Google': 2, 'Taobao': 3}





lambda 参数: 返回值 

*# 多个参数的时候，用英文逗号隔开*



```python
# 匿名函数 lambda
# 基本的语法结构
# func 是一个内存地址，要运行它，需要加个()去调用它; x 表示形参；x+1 相当于函数return 的值；
func = lambda x: x+1
print(func(10))

# 相当于以下函数

"""
def foo(x):
    return x+1


print(foo(10))
"""

f = lambda x, y, z: (x+1, y+1, z+1)
print(f(1, 2, 3))



11
(2, 3, 4)





1,调用函数

def square(x)

        return x**2

print(map(square,[1,2,3])

输出结果：[1,4,9]

2，匿名函数

a=map(lambda x,y:x*y,[1,2],[3,4])

print(a)

输出结果：[3,8]

a=map(lambda x,y:(x*y,x+y),[1,2],[3,4])

print(a)

输出结果：[(3,4],(8,6)]          #理解时可以先把每次循环的x,y先抽出来，在带入到规faction中

3，类zip()

当map()函数的faction不存在时，map（）函数等同于zip()函数，将给出的多个列表的对应位置的元素整合成一个元组的集合。

map(None,[1,2],[3,4])

输出结果：[(1,3),(2,4)]

4,类型转换 

1>,转换字符串

map(str,'abc')

输出结果：[a,b,c]







```





1. **基本概念**
1、**eval() 是 python 中功能非常强大的一个函数**
2、**将字符串当成有效的表达式来求值，并返回计算结果**
3、**所谓表达式就是：eval 这个函数会把里面的字符串参数的引号去掉，把中间的内容当成Python的代码，eval 函数会执行这段代码并且返回执行结果**
4、**也可以这样来理解：eval() 函数就是实现 list、dict、tuple、与str 之间的转化**
5、**安全性是 eval 最大的缺点**











