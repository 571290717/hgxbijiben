# 刷题

```
1、自我介绍
#你好面试官，我叫xxx，21年毕业于沈阳理工大学，信息管理与信息系统专业，主要学习方向是信息系统，在大学期间有前端开发的实习经历，后通过校招进入珠海格力电器从事软件测试工程师工作，主要负责公司软件的功能测试、性能测试工作，我个人对测试行业也很有兴趣、在格力工作期间也是提前两个月转正、从一开始的功能测试做起，到现在已经能带领其他测试组成员合作测试任务了。
个人掌握的技能也包括测试基础、测试工具的使用、Python数据库、数据库、测试框架、已经基础的前端知识和后端Django框架，自己也尝试过编写自动化测试脚本，结合tkinter的窗口脚本、和简单的Django项目。










2、为什么离职
1、以目前的工资水平我可能再工作10年也没办法买房子
2、我朋友们也在广州发展，他们也希望我和他们一起都在广州发展


3、介绍一个项目，你在其中的具体工作

格慧招二期：该项目的项目背景是原一期的系统功能已无法满足人力部处理校招流程的复杂需求，在一期的系统上迭代出二期项目，在该项目中我注意负责后台校园招聘模块的用例编写测试、和对系统关键接口进行接口测试和接口压力测试。该项目前端是微信小程序模式，后台管理端是web页面，其中前端主要功能有有登录、上传面试资料、签约、入职资料等资料，后台管理端，主要进行查看、审核面试、签约、入职等资料发放offer邮件、邮寄三方资料、处理违约流程、手动标记或转移各阶段状态、配置业务逻辑等操作。在该项目中我个人设计了500多条测试用例并进行测试占这个项目测试用例60%，我还负责该项目的性能测试，主要工作内容是对该系统的主要接口进行压力测试，包括设计性能测试用例，搭建设性能测试环境，进行性能测试并监控，以及编制性能测试报告。


网络安全维修平台，目前公司有多个防护系统和安全设备，登录方式和告警阈值不统一，造成信息安全运营碎片化的情况越来越严重，信息安全工程往往需要一台一台的登录安全设备，逐台设备处理告警，无法跨素食别网络中的高威胁的攻击行为，并作出处理，然后该系统就是采集各安全设备的警告信息，进行汇总，可进行警告信息分类、查询、定时汇报、发送邮件、发送短信提醒等。主要包含事件查看、策略总览、敏感字典配置、告警策略配置等模块，在该项目在，我主要负责带来另外两名测试组同学组织进行测试，主要负责有测试计划编写，汇总测试用例，编写测试报告，递交测试报告，结项入档，最终在规定日期前提前完成两周该项目。



4、项目中的亮点贡献，具体的效果。








5、项目中测试工作流程
项目需求评审、冒烟测试、制定测试计划、设计测试用例、功能测试、接口测试、性能测试、禅道缺陷管理、编写测试报告，测试报告审核、遗留bug回归、结项


6、工作中用到的工具，工具的作用
Jmeter进行接口测试、压力测试、（参数化）


7、测试用例设计
等边工场判正因错


8、linux系统常见知识


9、mysql使用，构造测试数据的方法


10、编程语言知识


11、项目实践紧如何处理


12、开发质量差如何处理



13、项目测试过程中遇到过什么问题没有




14、你有什么问题要问？
问1、如果有幸加入贵公司会给我按排什么工作呢
问2、贵公司希望该岗位的员工需要那些能力
问3、该岗位是否是急招呢？，如果合适是需要什么时候入职上岗呢？




import math
R = float(input())
#利用math.pi圆周率
J = math.pi * R * R
print('%.3f'%J)




```



![332085cc3ef9ef877c7814241ca51a3](%E5%88%B7%E9%A2%98.assets/332085cc3ef9ef877c7814241ca51a3-16781745909221.jpg)

```
提问：

1、设计用例方法及其应用
等边工厂判因正错



设计测试用例： 
主要是功能性，性能性，安全性，易用性，兼容性，网络，压力测试，界面UI，

2、测试流程





3、fiddler你一般用来干啥
1、抓包 （充当浏览器和服务器之间的网关，记录浏览器请求信息和服务器响应信息）
2、筛选指定url的信息
3、composer 可进行测试接口、传递非法参数、伪造数据





4、jmter参数化、接口测试流程、压力测试流程


性能指标：
时延： 数据从一段到另一端所需的时间
信道利用率：某一信道有百分之多少的时间是有数据通过的
信道利用率=有数据通过的时间/（有+无）数据通过时间
速率：连接在计算机网络上的主机在数字信道上传输数据的速率
带宽： 信道所能传输的最高数据传输速度
吞吐量：单位时间内通过某个网络（或信道，接口）的数据量、实际的数据传输率
时延带宽积：传播时延*信道带宽 、指发送端发送第一个比特到达终点时、发送端以及发出了多少给比特
往返时间RTT：2* 传播时延（往返传播时延） +末端处理时延


性能测试流程：

1、性能测试需求分析（分析真正的需求）
2、性能测试计划
3、性能测试用例 （需求体现在用例的设计中）
4、测试脚本编写
5、测试场景设计
6、测试场景运行
7、场景运行监控
8、运行结果分析
9、系统性能调优 （调优玩载到第二步）
10、性能测试报告总结

性能测试实施：
1、测试设计阶段   需求、方案、人员和数据收集模板   
2、测试环境准备 	工具、测试账号、脚本、 参数化（CSV数据文件设置、函数助手、用户定义变量、用户参数） 、 配置原件、前置处理器、定时器、sampler（取样器） 、 后置处理器 、断言、监听器

3、测试执行阶段   	录制（jmeter录制方法：第三方、代理、手动编写）、调试、执行、和数据收集整理 查看结果树、聚合报告
4、测试分析阶段	分析测试数据
5、提交测试报告
























5、appium和uiautomator是什么作用是什么工作中如何运用

6、写过自动化脚本吗举例说明

7、reqeusts你一般用来干什么

8、unittest和pytest的区别


9、mysql基本语句

10、liunx命令

11、adb命令

12、tcp、ip http协议
TCP/IP和OSI都是计算机网络分层结构：osi是7层分别是
应表会传网数物-（客户FTpHTTPSMTP、打包ASCII、电话接头SYN、上车UDPTCP、导航IP、变帧、光纤）
TCP/IP 应传网网-（应HTTP|FTPSMTPDNS|DNS一般指域名系统、传TCPUDP、网际层IP、网络接口层帧光纤）




HTTP协议：
无状态的、TCP为其传输协议、http本身是无连接（通信双方在交换http报文之前不需要先建立http连接）

请求报文
响应报文

HTTP通信机制:

1、建立TCP连接 TCP端口80
2、web浏览器发送请求命令    GET  url地址   HTTP/ 1.1  
3、web浏览器发送请求头  （空格结束）
4、Web服务器应答  HTTP/1.1 200 OK
5、Web服务器发头信息
6、web服务器向浏览器发送数据
7、web服务器关闭TCP连接  （长连接除外）

HTTP请求信息由4部分组成： 
请求方式  URL 协议版本
请求头
（空行）
请求正文

HTTP 1.1 语法有7种
get、post、head、options、put、delete、trace


1xx  已接受，处理中
2xx ok
3xx 重定向
4xx 客户端错误  （401 无权限  403 拒绝访问  404 无页面）
5xx 服务器端错误  （500 服务器内部错了 503服务器当前不能处理该请求 ）



三握手：  1、 客-服 请求包标志物SYN-seq=x
		2、 服务-客户  syn = y  ack=x+1
		3.  客户-服务    ack=Y+1
		
四挥手  1、客户-服务  标志位-FIN-seq=x ACK=y
		2、服务-客户  ACK Y+1
		3、服务-客户  FIN-seq =y
		4、客户-服务   ACK = Y+1
		
why？ 三握手 ： 
简述： 客户-服务、服务-客户的请求进行确认、客户-服务端的确认进行确认
假如2次。传输过程中会有时延、丢包、阻塞等造成服务端误以为开始、造成服务器等待和资源的浪费


why？四挥手

TCP是全双工的 ，收到FIN就说明没有数据再发过来来了，也就是接受一个FIN就只是关闭一个方向的数据传输、另一个方向也可以发送，所以需要两次FIN，四次挥手才能关闭全双工


网络通信的过程

简单记忆：

	MAC地址：在设备与设备之间数据通信时用来标记收发双方（网卡的序列号）
	
	IP地址：在逻辑上标记一台电脑，用来指引数据包的收发方向（相当于电脑的序列号）
	
	网络掩码：用来区分ip地址的网络号和主机号
	
	默认网关：当需要发送的数据包的目的ip不在本网段内时，就会发送给默认的一台电脑，成为网关
	
	集线器：已过时，用来连接多态电脑，缺点：每次收发数据都进行广播，网络会变的拥堵
	
	交换机：集线器的升级版，有学习功能知道需要发送给哪台设备，根据需要进行单播、广播
	
	路由器：连接多个不同的网段，让他们之间可以进行收发数据，每次收到数据后，ip不变，但是MAC地址会变化
	
	DNS：用来解析出IP（类似电话簿）
	
	http服务器：提供浏览器能够访问到的数据

访问百度过程（重点）：

		1. 需要知道www.baidu.com的ip，但是不知道，
		2. 需要通过dns来解析出 www.baidu.com对应的ip，但是不知道网关的mac地址
		3. 真的情况是 先发送arp广播，得到默认网关的mac地址，
		4. 然后向dns服务器发送查询 www.baidu.com对应的ip的请求
		5. 假如 dns服务器找到了 www.baidu.com对应的ip，那么就会将这个ip地址返回到 请求方
		6. 到现在为止，咱们的电脑才知道了 www.baidu.com对应的ip
		7. 接下来会通过tcp的3次握手，链接http服务器
		8. 链接成功后，会发送真正的http请求，来得到www.baidu.com的主页内容
		9. http服务器接收到请求后，组织主页的内容数据，将其返回到这个 请求方的电脑上
		10. 电脑接收到http的数据应答后，传递给浏览器，浏览器负责将其进行显示






13、Django相关问题



14、测试中难题
1、负载机
2、设计压力测试的测试用例

13、Session、Cookie 的区别？ 
两者都是跟踪浏览器用户身份的回话方式。 
· session 默认被存储在服务器的一个文件里（不是内存） 
· session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） 
· session 可以放在 文件、数据库、或内存中都可以。 
· 用户验证这种场合一般会用session 
· cookie 是存放在客户端的，用于记录用户信息的；session是存放在服务器端的，用于记录用户状态。 
· cookie不安全，可以分析存放在本地的cookie进行cookie欺骗，session存放在服务器内存中，安全性较高。 
· 单个cookie保存数据不可以超过4k，session则没有限制



unitest和pytest的区别

一、用例编写规则
1.unittest提供了test cases、test suites、test fixtures、test runner相关的类,让测试更加明确、方便、可控。使用unittest编写用例,必须遵守以下规则:

　　（1）测试文件必须先import unittest

　　（2）测试类必须继承unittest.TestCase

　　（3）测试方法必须以“test_”开头

　　（4）测试类必须要有unittest.main()方法

2.pytest是python的第三方测试框架,是基于unittest的扩展框架,比unittest更简洁,更高效。使用pytest编写用例,必须遵守以下规则:

（1）测试文件名必须以“test_”开头或者"_test"结尾(如:test_ab.py)

（2）测试方法必须以“test_”开头。

（3）测试类命名以"Test"开头。

总结: pytest可以执行unittest风格的测试用例,无须修改unittest用例的任何代码,有较好的兼容性。 pytest插件丰富,比如flask插件,可用于用例出错重跑;还有xdist插件,可用于设备并行执行。 　　　　



二、用例前置和后置
1.unittest提供了setUp/tearDown，只能针对所有用例。

2.pytest提供了模块级、函数级、类级、方法级的setup/teardown，比unittest的setUp/tearDown更灵活。

模块级（setup_module/teardown_module）开始于模块始末，全局的

函数级（setup_function/teardown_function）只对函数用例生效（不在类中）

类级（setup_class/teardown_class）只在类中前后运行一次(在类中)

方法级（setup_method/teardown_method）开始于方法始末（在类中）

类里面的（setup/teardown）运行在调用方法的前后

3.pytest还可以在函数前加@pytest.fixture()装饰器，在测试用例中装在fixture函数。fixture的使用范围可以是function,module,class,session。
firture相对于setup和teardown来说有以下几点优势：

命名方式灵活，不局限于setup和teardown这几个命名

conftest.py 配置里可以实现数据共享，不需要import就能自动找到一些配置，可供多个py文件调用。

scope="module" 可以实现多个.py跨文件共享前置

scope="session" 以实现多个.py跨文件使用一个session来完成多个用例

用yield来唤醒teardown的执行

三、断言
1.unittest提供了assertEqual、assertIn、assertTrue、assertFalse。

2.pytest直接使用assert 表达式。

四、报告
1.unittest使用HTMLTestRunnerNew库。

2.pytest有pytest-HTML、allure插件。

五、失败重跑
1、unittest无此功能。

2、pytest支持用例执行失败重跑，pytest-rerunfailures插件。

六、参数化
1、unittest需依赖ddt库，

2、pytest直接使用@pytest.mark.parametrize装饰器。

七、用例分类执行
1、unittest默认执行全部用例，也可以通过加载testsuit，执行部分用例。

2、pytest可以通过@pytest.mark来标记类和方法，pytest.main加入参数("-m")可以只运行标记的类和方法。

八、如果不好看，可以看下面表格：



![img](%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%BD%92%E7%BA%B3.assets/3b4564d9c8c0382b77737533e8aaca77-16789572888902.png)


总体来说，unittest用例格式复杂，兼容性无，插件少，二次开发方便。pytest更加方便快捷，用例格式简单，可以执行unittest风格的测试用例，无须修改unittest用例的任何代码，有较好的兼容性。pytest插件丰富，比如flask插件，可用于用例出错重跑，还有xdist插件，可用于设备并行执行，效率更高。




```

## 2. 接口测试

### **2.1 什么是接口测试**

接口测试是测试系统组件间数据交互的一种方式. 

接口测试就是通过测试不同情况下的输入参数和与之对应的输出结果来判断接口是否符合或满足相应的功能性、安全性要求.

***简单的说,接口测试是就是代替前端或者第三方,来验证后端实现是否符合接口规范.***

###  **2.2 接口测试的好处**

通过接口测试,测试接口的正确性和稳定性, 能快速定位bug,提高测试效率. 

- 能为项目平台带来高效的缺陷监测和质量监督能力；
- 平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）

### **2.3 接口测试原理**

**原理:**

**模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收响应数据后并进行判断**

- 请求: 是否正确, 默认请求成功是返回200, 假如请求错误返回400, 404, 500等状态码
- 检查: 返回数据的正确性与完整性
- 安全性: 接口一般不会暴露在网上任意被调用,需要做一些限制,比如必须登录或者请求次数、频率限制

### **2.4 基本流程**

接口测试流程: 定位服务器接口资源并提交测试数据，然后查看响应结果是否符合预期

1. 定位接口资源(URL)

2. 提交测试数据

3. 检查响应结果

### **2.5 接口测试分类**

- web接口测试
- 模块接口测试

##### (1). web接口测试

- 服务器接口测试, 是测试浏览器与服务器的接口, 是B/S架构的

- 外部接口测试, 测试第三方接口,

  > 举例：支付接口测试/天气预报接口测试

#### (2). 模块接口测试

- 单元测试的基础,主要测试模块的调用与返回.

## 3. 如何做好接口测试

接口测试要遵循一些要点:

1. 接口的功能性实现. 检查接口返回的数据与预期结果的一致性.
2. 测试接口的容错性, 例如传递的数据类型是错误的能否处理.
3. 测试接口参数的边界值. 例如传递的数据足够大或者为负数时能否处理
4. 测试接口性能, 接口处理和响应数据的时间也是测试的一个方面, 这牵扯到代码实现的优化
5. 测试接口的安全性. 特别是第三方接口,比如登录的用户名密码第三方是否是密文传输的





**接口的功能是否正确实现了**

**接口是否按照设计文档中来实现**

（比如username参数写为了user，那么这就不符合，因为接口文档在整个开发中都需要使用，所以接口实际的设计要与接口设计文档中保持一致）



- **兼容性测试：**

  比如说今天接口进行了调整，但是前端没有进行变更，这时候需要验证新的接口是否满足旧的调用方式

- **错误码测试：**

  通用的错误码与业务错误码是否能够清晰的说明调用问题，错误码是否能够尽可能的全的覆盖所有的情况

- **返回值测试：**

  返回值除了内容需要是正确的，还需要类型也是正确的，保证调用方拿到这些参数能够正确的解析



**参数边界值、等价类测试**



- **json格式测试：**

  通常我们的接口一般设计的都是传递json串，那么就需要去测试 如果传递非json的情况，这时候程序会不会正确的处理，返回相应的 error code

- **默认值测试：**

  很多情况一些非必填的参数会有默认值，比如说一个查询的接口，参数count为返回查询的结果数量， 默认为10，那么就应该有一条case来测试，当然前置条件是数据库里面必须要存在这样的数据超过10条。



**02**

**逻辑业务**







**是否有依赖业务，**比如查看订单，是需要用户首先登录的，所以肯定要保证登录了或有相应的cookie



**业务逻辑测试：**传递正确的参数，接口对数据库进行查询的操作，需要去验证数据库查询是否正确，接口对数据库进行 增删改的操作，也需要看数据库是否同步进行了这些操作

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/p1ibuRQ0oDljCwFnxxC7RQxt3yhq35Z4EvXofHxUDZOIIiaezljQ9KMzpWlhD7AG5nb4LzkUUEdIyXL6ZTmzL4WA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)



**03**

**异常测试**







异常分为两类，**参数异常**和**数据异常**



**1、参数异常：**

- 关键字参数：

  将参数写为开发语言中的关键字

- 参数为空：

  比如去掉了username参数

- 多或少参数：

  多或者少参数的验证，现在还不确定如果一个接口多了参数如果没有报错是否是合理的，或者是否需要优化，因为就目前开发给予的答案是，**一般不对接口多了参数的处理**

- 错误参数：

  比如将username参数写为了user等看是否能返回相应的error code



**2、数据异常：**

- 关键字数据：

  将参数的值填为开发语言中的关键字

- 数据为空：

  将参数的额值填为空

- 长度不一致：

  因为数据库中每个字段都设置有字段长度，填写不符合的长度进行验证

- 错误数据：

  就是将参数的值任意填写，或填写不存在的数值

- 异常类型测试：

  比如count参数，这个参数的类型一定是可以转换为int类型的，这时候我们需要测试如果传的一些不可以 转换为int类型值来测试代码是否加入判断



**04**

**性能测试**







- 响应时间
- 吞吐量
- 并发用户数
- 占用内存，CPU等



**05**

**安全性测试**







**敏感信息是否加密**

**必要参数是否后端也进行校验**

（现在很多系统前后端架构是分离的，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前端太容易了）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证）



**接口是否防恶意请求**（SQL注入）

- **cookie**：

  将header中的cookie修改或删除后看是否能返回相应的error code

- **header**：

  删除或修改header中部分参数的值，看是否能返回相应的error code

- **唯一识别码**：

  删除修改唯一识别码测试







一、用例编写规则
1.unittest提供了test cases、test suites、test fixtures、test runner相关的类,让测试更加明确、方便、可控。使用unittest编写用例,必须遵守以下规则:

　　（1）测试文件必须先import unittest

　　（2）测试类必须继承unittest.TestCase

　　（3）测试方法必须以“test_”开头

　　（4）测试类必须要有unittest.main()方法

2.pytest是python的第三方测试框架,是基于unittest的扩展框架,比unittest更简洁,更高效。使用pytest编写用例,必须遵守以下规则:

（1）测试文件名必须以“test_”开头或者"_test"结尾(如:test_ab.py)

（2）测试方法必须以“test_”开头。

（3）测试类命名以"Test"开头。

总结: pytest可以执行unittest风格的测试用例,无须修改unittest用例的任何代码,有较好的兼容性。 pytest插件丰富,比如flask插件,可用于用例出错重跑;还有xdist插件,可用于设备并行执行。 　　　　



二、用例前置和后置
1.unittest提供了setUp/tearDown，只能针对所有用例。

2.pytest提供了模块级、函数级、类级、方法级的setup/teardown，比unittest的setUp/tearDown更灵活。

模块级（setup_module/teardown_module）开始于模块始末，全局的

函数级（setup_function/teardown_function）只对函数用例生效（不在类中）

类级（setup_class/teardown_class）只在类中前后运行一次(在类中)

方法级（setup_method/teardown_method）开始于方法始末（在类中）

类里面的（setup/teardown）运行在调用方法的前后

3.pytest还可以在函数前加@pytest.fixture()装饰器，在测试用例中装在fixture函数。fixture的使用范围可以是function,module,class,session。
firture相对于setup和teardown来说有以下几点优势：

命名方式灵活，不局限于setup和teardown这几个命名

conftest.py 配置里可以实现数据共享，不需要import就能自动找到一些配置，可供多个py文件调用。

scope="module" 可以实现多个.py跨文件共享前置

scope="session" 以实现多个.py跨文件使用一个session来完成多个用例

用yield来唤醒teardown的执行

三、断言
1.unittest提供了assertEqual、assertIn、assertTrue、assertFalse。

2.pytest直接使用assert 表达式。

四、报告
1.unittest使用HTMLTestRunnerNew库。

2.pytest有pytest-HTML、allure插件。

五、失败重跑
1、unittest无此功能。

2、pytest支持用例执行失败重跑，pytest-rerunfailures插件。

六、参数化
1、unittest需依赖ddt库，

2、pytest直接使用@pytest.mark.parametrize装饰器。

七、用例分类执行
1、unittest默认执行全部用例，也可以通过加载testsuit，执行部分用例。

2、pytest可以通过@pytest.mark来标记类和方法，pytest.main加入参数("-m")可以只运行标记的类和方法。

八、如果不好看，可以看下面表格：



![img](%E5%88%B7%E9%A2%98.assets/3b4564d9c8c0382b77737533e8aaca77.png)


总体来说，unittest用例格式复杂，兼容性无，插件少，二次开发方便。pytest更加方便快捷，用例格式简单，可以执行unittest风格的测试用例，无须修改unittest用例的任何代码，有较好的兼容性。pytest插件丰富，比如flask插件，可用于用例出错重跑，还有xdist插件，可用于设备并行执行，效率更高。




五、使用Fiddler实现接口测试 1测试登录接口 抓包，完成后退出 选中需要测试的url，找到并复制请求部分raw中的cookie整行 重新启动Fiddler Composer→Parsed Composer 创作 输入越权访问的url 粘贴Cookie 执行越权url Execute 2传递非法参数 修改参数为非法数据，使用此方式伪造或篡改数据。 【例】测试Webtours处理信用卡号的接口。 方法1 在Fiddler中设置抓包 选择url，F2，修改参数 回放url 查看响应数据或后台数据 方法2 Composer 选择get或post方法 输入url，url后应携带/ post方法应添加 Content-Type: application/x-www-form-urlencoded 参数 get方法直接在url/后写 ?参数名1=值1&参数名2=值2 post方法在RequestBody中写 参数名1=值1&参数名2=值2 Execute 查看响应数据或后台数据 响应中文乱码问题 进入注册表 HKEY_CURRENT_USER\Software\Microsoft\Fiddler2 新建字符串值：HeaderEncoding，值设置为GBK 重启Fiddler 3伪造数据 设置断点修改Request，使用此方式伪造或篡改数据。 【例】攻击Webtours付款接口。 无需截获数据流（抓包），在浏览器中打开将数据（如价格）发给服务器的页面，停止操作 在Fiddler中设置抓包和拦截请求 返回软件操作，给服务器发送数据 拦截完成，篡改将要发送的数据，点击Break on Response，点击Run to Completion 在Fiddler中取消抓包和拦截请求 继续后续操作，到完成 查看后台数据 支付漏洞与解决方案 漏洞1：在支付过程中直接发送含有支付金额的数据包 让开发不要在数据包中加入价格和数量等敏感值。 漏洞2：没有对购买数量进行限制 严格控制购买数量的大小，不允许数量为负数，控制总支付金额是一个正常的数。 漏洞3：程序的异常处理 指支付的数据包异常的程序的错误处理。 这种异常可以是数据与KEY不符，支付的金额有错误，购买的数量不正确等。 程序的异常处理出现的原因主要是开发人员对出现异常后的处理不当造成的。



![img](%E5%88%B7%E9%A2%98.assets/a2c32000b01ac06caa780070bfeee57c-16781522730364.jpeg@wm_2,t_55m+5a625Y+3L+a1i+ivleeMv+ivvuWggg==,fc_ffffff,ff_U2ltSGVp,sz_18,x_12,y_12)



![img](%E5%88%B7%E9%A2%98.assets/16b17836e920c483f7d2579d92c6e1db-16781522495382.jpeg@s_0,w_1242wm_2,t_55m+5a625Y+3L+a1i+ivleeMv+ivvuWggg==,fc_ffffff,ff_U2ltSGVp,sz_32,x_20,y_20)



![img](https://pic.rmb.bdstatic.com/bjh/down/16b17836e920c483f7d2579d92c6e1db.jpeg@s_0,w_1242%7Cwm_2,t_55m+5a625Y+3L+a1i+ivleeMv+ivvuWggg==,fc_ffffff,ff_U2ltSGVp,sz_32,x_20,y_20)









###### 1、链表

```Python
#注：写哈希表 之前，先写个链表
#注：链表的创建
class LinkList: #注：链表类
    class Node: #注：链表里的节点
        def __init__(self, item=None):
            self.item = item
            self.next = None

    class LinkListIterator: #注：这个类是一个迭代器 因为 支持__next__
        def __init__(self, node):
            self.node = node

        def __next__(self):
            if self.node:   #注：如果node不是空
                cur_node = self.node
                self.node = cur_node.next
                return cur_node.item
            else:
                raise StopIteration
        def __iter__(self):
            return self

    def __init__(self, iterable=None):  #注：构造函数。传一个列表
        self.head = None
        self.tail = None
        if iterable:    #注：如果有列表
            self.extend(iterable)

#注：extend()接受一个列表参数  [1,2].extend([1,2,3]) [1,2,1,2,3]
#注：append()接受一个对象参数  [1,2].append([1,2,3]) [1,2,[1,2,3]]
    def append(self, obj):  #注：尾插
        s = LinkList.Node(obj)  #注：创建节点
        if not self.head:   #注：如果head是空
            self.head = s
            self.tail = s
        else:               #注：如果head不是空，插到尾巴上
            self.tail.next = s
            self.tail = s

    def extend(self, iterable): #注：循环调appdend 就有extend了
        for obj in iterable:
            self.append(obj)

    def find(self, obj):    #注：在链表里查找，for循环查
        for n in self:      #注：self是linklist对象，self是迭代的支持这种写法
            if n == obj:
                return True
        else:
            return False

    def __iter__(self): #注：写迭代器的 支持迭代
        return self.LinkListIterator(self.head)

    def __repr__(self):     #注：转换成字符串
        return "<<"+", ".join(map(str, self))+">>"
        #注：map对于可迭代对象的每个元素 转换成字符串str

        
        
        
lk = LinkList([1,2,3,4,5])  #注：可迭代对象
for element in lk:
    print(element)
#结果为
# 1
# 2
# 3
# 4
# 5
print(lk)
#结果 <<1, 2, 3, 4, 5>>
```







###### 2、哈希表



```python
#注：在这基础上 写 哈希表

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):   #注：哈希表的构造函数,size哈希表的大小
        self.size = size
        self.T = [LinkList() for i in range(self.size)]   #注：开一个T列表，每个位置都是一个链表（拉链法）
        #注：刚开始T列表 每一个位置都是一个空链表 LinkList()

    def h(self, k): #注：哈希函数
        return k % self.size    #注：对self.size取模

    def insert(self, k):    #注：插入
        #注：计算哈希函数 返回的哈希值
        i = self.h(k)
        #注：k这个元素 要插到i这个位置上去
        #注：判断这个元素在不在里面
        if self.find(k):    #注：如果找到了，我就不插入。达到哈希 去重的目的
            print("Duplicated Insert.") #注：重复插入 提醒
        else:   #注：如果没找到，插入
            self.T[i].append(k) #注：插入

    def find(self, k):  #注：先写 查找函数
        i = self.h(k)   #注：先找到k的哈希值
        return self.T[i].find(k)    #注：T[i] 是个链表

#注：哈希表 删除功能 没写。写删除的话 链表就得支持删除的功能

ht = HashTable()    #注：创建HashTable对象

ht.insert(0)
ht.insert(1)
# ht.insert(0)
# #注：输入第3条语句时 ，提示 Duplicated Insert.
ht.insert(3)
ht.insert(102)
ht.insert(508)

print(",".join(map(str, ht.T)))
#注：打印这个哈希表，1和102在一个链表里，因为 哈希表的长度是101，102对101取余剩1
#注：508对101取余剩3
# <<0>>,<<1, 102>>,<<>>,<<3, 508>>,<<>>,<<>>,<<>>,…………

print(ht.find(3))
#结果为 True
print(ht.find(102)) #注：也能找到，它是个链表， 先去1那个位置上找，发现1 不是，102 是，找到了
#结果为 True
print(ht.find(203))
#结果为 False      #注：因为发现 1 不是，102 不是，没了  返回一个false

#注：集合实现 跟它差不错
```



```python
#哈希表 精简代码

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):
        self.size = size
        self.T = [LinkList() for i in range(self.size)]

    def h(self, k):
        return k % self.size

    def insert(self, k):
        i = self.h(k)
        if self.find(k):
            print("Duplicated Insert.")
        else:
            self.T[i].append(k)

    def find(self, k):
        i = self.h(k)
        return self.T[i].find(k)

ht = HashTable()

ht.insert(0)
ht.insert(1)
ht.insert(3)
ht.insert(102)
ht.insert(508)

#print(",".join(map(str, ht.T)))
print(ht.find(203))![点击并拖拽以移动]()
```

# python列表反转的4种方法

```python
# reverse()方法
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a.reverse()
print('列表反转结果：', a)

# 内置reversed()函数
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = reversed(a)
print('列表反转结果（迭代对象）：', a1)
print('列表反转结果转换成列表：', list(a1))

# 切片实现反转
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
print('列表反转结果：', a[::-1])


# 使用for循环
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = [a[len(a)-i-1] for i in range(len(a))]
print('列表反转结果：', a1)



```

**This is a sample   -->  SAMPLE A IS tHIS**

```python
class solution:
    def trans(self,s,n):
        if n==0 :
            return s
        res = " "
        for i in range(n):
            if s[i]<='Z' and s[i]>='A':
                res +=chr(ord(s[i]) - ord('A') + ord('a'))
            elif s[i] >='a' and s[i]<='z':
                res +=chr(ord(s[i]) - ord('a') + ord('A'))
            else:
                res +=s[i]
        res = list(res.split(' '))[::-1]
        return  ' '.join(res)
    
        
if __name__ == "__main__""
	s = solution()
    s2 = s.trans("dqw dwq",7)
    print(s2)
    

```

















3、SQL

```mysql
查看所有数据库
	show databases;

创建数据库
	create database 数据库名 charset=utf8;

使用数据库
	use 数据库名;

查看当前使用的数据库
	select database();

删除数据库-慎重
	drop database 数据库名;

查看当前数据库中所有表
	show tables;

创建表
创建表

​	create table 表名(
字段名称 数据类型  可选的约束条件,
column1 datatype contrai,
...
);

	create table students(
 id int unsigned primary key auto_increment not null,
 name varchar(20) not null,
 age tinyint unsigned default 0,
 height decimal(5,2),
 gender enum('男','女','人妖','保密')
);



修改表-添加字段
	alter table 表名 add 列名 类型 约束;
例：
alter table students add birthday datetime;


修改表-修改字段类型
	alter table 表名 modify 列名 类型 约束;
例：
alter table students modify birthday date not null;
	说明:
modify: 只能修改字段类型或者约束，不能修改字段名



修改表-修改字段名和字段类型
	alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
	说明:
change: 既能对字段重命名又能修改字段类型还能修改约束


修改表-删除字段
	alter table 表名 drop 列名;
例：
alter table students drop birthday;


查看创表SQL语句
	show create table 表名;
例：
show create table students;


查看创库SQL语句
	show create database 数据库名;
例：
show create database mytest;


删除表
	drop table 表名;
例：
drop table students;


查询数据
	-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;


添加数据
	-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
	说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值


修改数据
	update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;

删除数据
	delete from 表名 where 条件
例：
delete from students where id=5;
	问题:
	上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
	-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
	说明:
	逻辑删除，本质就是修改操作



5. 小结
	登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件



使用 as 给字段起别名
select id as 序号, name as 名字, gender as 性别 from students;

distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
as 关键字可以给表中字段 或者 表名起别名
distinct 关键字可以去除重复数据行。



7. 小结
	常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null



4. 模糊查询
	like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
	例1：查询姓黄的学生:
select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:
select * from students where name like '黄_';
3：查询姓黄或叫靖的学生:
select * from students where name like '黄%' or name like '%靖';



1. 排序查询语法
	排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:
先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:
select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:
select * from students  order by age desc,height desc;




2. 分页查询的语法
	select * from 表名 limit start,count
说明:
limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:
select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;

3. 分页查询案例
	已知每页显示m条数据，求第n页显示的数据
提示: 关键是求每页的开始行索引
查询学生表，获取第n页数据的SQL语句:
select * from students limit (n-1)*m,m


6. 求平均值
	-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
	说明
	ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。

8. 小结
	count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值



分组查询
	学习目标
		能够写出分组查询的SQL语句
	1. 分组查询介绍
		分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
	2. group by的使用
		group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
	3. group by + group_concat()的使用
		group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
	4. group by + 聚合函数的使用
		- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
	5. group by + having的使用
		having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
	6. group by + with rollup的使用
		with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
	7. 小结
		group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果



内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;



左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;




右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;



自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:
小结
	自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
	自连接就是一种特殊的连接方式，连接的表还是本身这张表


2. 子查询的使用
	例1. 查询大于平均年龄的学生:
select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:
select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:
select * from students where (age, height) =  (select max(age), max(height) from students);














```





l

```mysql
演练-分组和聚合函数的组合使用
	学习目标
		能够写出分组和聚合函数组合使用的SQL语句
	1. 数据准备
		-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
		表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
	2. SQL语句演练
		查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;
```





```mysql
事务
	学习目标
		能够知道事务的四大特性
	1. 事务的介绍
		事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
	2. 事务的四大特性
		原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
	3. 事务的使用
		在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
		-- 查看MySQL数据库支持的表的存储引擎
show engines;
	查看goods表的创表语句:
		-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
	开启事务:

begin;
或者
start transaction;
	4. 小结
		事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
索引
	学习目标
		能够写出创建索引的SQL语句
	1. 索引的介绍
		索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
		应用场景:
		当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
	2. 索引的使用
		查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
	3. 案例-验证索引查询性能
		创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
	4. 联合索引
		联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
	5. 联合索引的最左原则
		在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
	6. MySQL中索引的优点和缺点和使用原则
		优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
	7. 小结
		索引是加快数据库的查询速度的一种手段
		创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
		删除索引使用: alter table 表名 drop index 索引名;
```



5、装饰器



```python
import time
 
#  装饰器run_time,@run_time加在谁头上，谁就是参数fun
def run_time(fun):
 
    start_time = time.time()
    fun()
    end_time = time.time()
 
    print("程序运行时间为：{} 秒".format(str(round((end_time - start_time), 1))))
    return end_time - start_time
 
#  耗时任务task
@run_time
def task():
    time.sleep(3)
    
    
```



快速排序

`

```python
def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟`


def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]
     return li

li = [1,46,89,1,3,6,9]
print(select_sort(li))




            
            
            
            
  #二分




def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分


```





## Linux

1、查找文件

 find  /目录 -name filename.txt



2、查看一个程序是否运行   				ps         -ef|grep     进程名字

​				grep 命令的基本格式			 grep [选项] 模式 文件名

3、终止线程							kill  -9  进程号



4、查看文件包含的隐藏文件    		ls  -al 



5、查看当前工作目录					  pwd



6、复制文件包含其子文件到自定义目录			cp 	 -r	sourceFolder   targetFolder



7、创建目录						mkdir	newfolder



8、删除目录					rmdir  【 】 documents    -v显示详细执行过程   -p 删除指定目录及子空目录



9、删除文件包括其子文件		rm 		-rf 		deletefile



10、移动文件 		mv  	/temp/movefile		/targetfolder 	+		mv  oldnamefile	newnamefile



11、切换用户 		su 	-username



12、修改文件权限		chmod	777   	file        -rwxrwxrwx



13、压缩文件		tar		-czf		test.tar.gz  	/test1/test2



14、列出压缩文件列表	tar 	-tzf	test.tar.gz



15、解压文件			tar 	-xvzf		test.tar.gz



16、查看文件头10行		head		-n		10		example.txt



17、查看文件尾10行		tail			-n		10	example.txt

  

18、查看日志文件 			tail			-f		example.log 	

 19 、启动vi编辑器			vi

20、查看系统当前时间		date		

21、 cd

22、ls

23、grep 		grep [选项] 模式 文件名	grep CLERK emp.data

如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下：grep -c CLERK emp.data

搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：grep ^78     emp.data

24、find

25、mkdir

26、cp -a file1 file2				cp file1 file2 file3 	dir

27.mv

28.rm -fr dir

29.ps  -a     ps  -ef

30. netstat -a      # 列出所有端口

    netstat -at     # 列出所有TCP端口

    netstat -au    # 列出所有UDP端口

    netstat -ax    # 列出所有unix端口

    netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名



一、linux管理和目录命令
pwd 显示当前路径地址
cd 改变当前用户的目录
ls 查看当前文件夹下的文件
mkdir  新建文件夹目录
rmdir  删除文件夹目录
touch  新建文件
cat    查看文本内容
mv     移动
cp	复制
rm	删除
grep	字符串查找

二、线上查找
man 查看当前或者一个命令的使用方法
locate 根据一个关键字或者关键词定位
whatis 查看某个命令的含义
三、文件阅读命令
head	从头开始查看
tail 	从尾开始查看
more	分页查看
四、文件或目录的压缩和解压缩
tar 
gzip
bizip2
gunzip
bunzip
五权限管理
chmod	修改权限
useradd	用户添加
userdel 用户删除
su	切换用户
passwd	修改密码
chgrp	修改文件所在组
chown	用来修改文件的所有者
六、文件的定位和查找
which  定位
whereis	查找
七、磁盘操作
df 查看文件系统使用情况
du 查看文件磁盘占用情况
八、系统命令
reboot重启
shutdown 关机
halt	关机
ps	进程
toop	进程
date	日期
cal	日历
exit	退出
kill	结束进程
九网络
ipconfig 显示网络状态
ping	监测主机
netstat	知道整个linux系统的网络情况或显示网络状态

top 查看cpu、内存密集使用的动态数据
free 查看内存使用情况
du 查看目录或文件的大小
df 查看磁盘分区的大小
cd 切换目录
ls 显示目录中的内容
cat 查看文件中的数据
vi 进入打开、修改、保存文件
rm 删除目录或者文件
mkdir 创建目录
touch 如果一个文件不存在，则创建文件，如果一个文件存在，则修改最后的访问时间
cp拷贝目录或文件



# 网络



## 两种 HTTP 请求方法：GET 和 POST

- **GET** - 从指定的资源请求数据。
- **POST** - 向指定的资源提交要被处理的数据。

**Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：**

-  **1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。**
-  **2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。**
-  **3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。**
-  **4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。**
-  **5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。**
-  **6、Get 是 Form 的默认方法。**

**使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。**





浏览器网址请求过程

​     **当我们在浏览器地址上输入一个网址时，浏览器会进行(HTTP)HTTPS的的请求时，基本根据以下步骤。**
​    
​        **1.通过DNS解析域名获取服务器IP。**

**首先，浏览器会根据当前网址域名去DNS服务器上进行解析请求，然后DNS服务器会请求到当前域名所对应的服务器IP地址，并将此IP地址返回给浏览器，浏览器再通过该浏览器访问当前服务器。****

​        **2.通过三次握手与服务器建立连接。**

**此时，在应用层是HTTP(HTTPS)协议，当进行到传输层时，服务器会通过TCP协议进行三次握手，首先客户端发送一个连接数据包给服务器(SYN = 1)，接着服务器会响应一个数据包给客户端，代表允许建立连接，然后客户端再发送一个数据包给客户端代表此时连接建立成功，-->-->**

​        **3.如果为HTTPS请求，则需要通过SSL证书加密。**

**如果是HTTPS协议，服务器首先会发送一个SSL证书给浏览器，浏览器检查当前证书是否过期以及证书是否安全，如果安全，则产生一个随机密钥通过SSL证书的公钥进行加密，将密钥发送给服务器端，服务器端根据自己的私钥对发送过来的密钥进行解密，**

​        **4.进行传输内容。**

**得到随机密钥后，通过随机密钥对要传输的内容加密，然后发送给服务器端，**

​        **5.TCP连接是否为长连接？**

TCP连接在这个过程中，还是基于TCP协议进行报文的发送与接收。如果说浏览器的connection = Keep-alive，代表本次TCP连接是一个长连接，不会主动释放连接，当传输内容完毕后，需要主动释放连接，**

​        **6.通过四次挥手释放连接**

**此时需要客户端发送挥手报文(FIN = 1)，服务器接收到后会发送一个确认报文，如果有未发送完的数据，接着发送数据，如果数据发送完毕，此时服务器会再发送一个数据包(FIN = 1,ACK = 1)给浏览器，浏览器再发送一个确认数据包给服务器，四次握手结束，这就是一个完整的访问网页的过程。**



**进程(Process)：进程是计算机中的程序关于某数据集合的一次运行实例，是操作系统进行资源分配的最小单位**
**线程(Thread)：线程被包含在进程之中，是操作系统进行程序调度执行的最小单位**
**协程(Coroutine)：协程是用户态执行的轻量级编程模型，由单一线程内部发出控制信号进行调度**





迭代器与生成器的区别：
（1）生成器：
生成器本质上就是一个函数，它记住了上一次返回时在函数体中的位置。
对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。
而且记录了程序执行的上下文。
生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。

（2）迭代器

迭代器是一种支持next()操作的对象。它包含了一组元素，当执行next()操作时，返回其中一个元素。
当所有元素都被返回后，再执行next()报异常—[StopIteration](https://so.csdn.net/so/search?q=StopIteration&spm=1001.2101.3001.7020)
生成器一定是可迭代的，也一定是迭代器对象

（3）区别：
①生成器是生成元素的，迭代器是访问集合元素的一中方式
②迭代输出生成器的内容
③迭代器是一种支持next()操作的对象
④迭代器（iterator）：其中iterator对象表示的是一个数据流，可以把它看做一个有序序列，但我们不能提前知道序列的长度，只有通过nex()函数实现需要计算的下一个数据。可以看做生成器的一个子集。







 装饰器本质上是一个Python函数(其实就是闭包)，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。





```

# 为函数添加一个统计运行时长的功能
import time
 
def how_much_time(func):
    def inner():
        t_start = time.time()
        func()
        t_end = time.time()
        print("一共花费了{0}秒时间".format(t_end - t_start, ))
    return inner
    # 将增加的新功能代码以及被装饰函数运行代码func()一同打包返回，返回的是一个内部函数，这个被返回的函数就是装饰器
 
def sleep_5s():
    time.sleep(5)
    print("%d秒结束了" % (5,))
 
def sleep_6s():
    time.sleep(6)
    print("%d秒结束了" % (6,))
 
sleep_5s = how_much_time(sleep_5s)
# 因为sleep_5s函数的功能就是睡5秒钟，虽然增加了统计运行时间的功能，但是他本身功能没变(还是睡5秒钟)，所以仍然用原来函数名接收增加功能了的自己
sleep_6s = how_much_time(sleep_6s)
 
t1 = threading.Thread(target=sleep_5s)
t2 = threading.Thread(target=sleep_6s)
t1.start()
t2.start()
# 5秒结束了
# 一共花费了5.014161109924316秒时间
# 6秒结束了
# 一共花费了6.011810302734375秒时间

```





建立连接的方式又称为三次握手：

（1）第一次握手，主机A向主机B发出请求数据包：“我想给你发数据，可以吗？”这是第一次对话。

（2）第二次握手，主机B向主机A发送同意连接，并要求同步的数据包（同步就是两台主机协调工作，一台在发送，一台在接收）：“可以，你什么时候发？”这是第二次对话。

（3）第三次握手，主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接收吧！”这是第三次对话。

这三次对话的目的是使数据包的发送和接收同步，TCP协议是一定要经过这三次对话之后，主机A才可以向主机B正式发送数据。


TCP建立连接需要进行三次握手，但是断开连接却要进行四次挥手：

（1）第一次挥手，在主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求。

（2）第二次挥手，主机B收到FIN位置上的1信息后对其做出响应，确认这一方向上的TCP连 接将关闭，将ACK置1。

（3）第三次挥手，B主机再提出反方向的关闭请求，并将控制位FIN置1，发送给A主机，并关闭连接。

（4）第四次挥手，主机A对主机B的请求进行确认，将ACK置1，并关闭连接，至此双方关闭连接。





一、TCP和UDP是什么？
TCP：传输控制协议(Transmission Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信 协议。由IETF的RFC 793定义。

UDP：用户数据报协议(User Datagram Protocol)，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。由RFC 768描述了UDP。

二、TCP与UDP的区别是什么？
1、连接方面

TCP面向连接(如打电话先拨号建立连接)。

UDP无连接，即发送数据报之前不用建立连接。

2、安全方面

TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达。

UDP尽最大努力交付，即不保证可靠交付。

3、传输效率

TCP传输效率较低，UDP传输效率较高。

4、连接数量的区别

TCP连接只能是一对一、点对点的。

UDP支持一对一、一对多、多对一和多对多的交互通信。

5、首部

TCP报文首部20个字节，UDP首部8个字节。

6、可靠

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

7、面向方式

TCP面向字节流。实际上是TCP把数据看成一串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题。

UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

三、TCP的三次握手与四次挥手
1、TCP三次握手
三次握手是TCP用来确保连接可靠建立的方式：

第一次握手：A给B发短信说：“B，你现在有空吗？”
第二次握手：B此时收到了A的信息，然后对A说：“我有空，你呢？有空吗？”
第三次握手：A此时收到了A的信息，然后说：“我也有空，那我给你说个事。”
在三次握手之后，A和B都能确定这么一件事：双方的通信可以流畅的进行。这样，双方就可以开始进行正常的对 话了。

2、TCP四次挥手
四次挥手是TCP用来确保连接可靠关闭的方式：

第一次挥手：A给B发短信说，“B，我要准备吃饭了？”
第二次挥手：B此时收到了A的信息，然后先对A说：“我知道了。”
第三次挥手：B对A说：“我也要准备吃饭了。”然后放下了手机
第四次挥手：A此时收到了B的确认信息，然后向B发送一个包说：“好的，知道了。”这时才放下手机去吃饭
在四次挥手之后，A和B都能确定这么一件事：双方的通信都可以正常关闭，这样，双方就可以确定对方已经完全知道了自己要确认关闭连接。

![在这里插入图片描述](D:\hgx笔记\hgxbijiben\7、刷题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzg1Njkx,size_16,color_FFFFFF,t_70)







```python
Python 数组翻转指定个数的元素
	定义一个整型数组，并将指定个数的元素翻转到数组的尾部。

例如：(ar[], d, n) 将长度为 n 的 数组 arr 的前面 d 个元素翻转到数组尾部。

以下演示了将数组的前面两个元素放到数组后面。
	def leftRotate(arr, d, n):
    for i in range(d):
        leftRotatebyOne(arr, n)
def leftRotatebyOne(arr, n):
    temp = arr[0]
    for i in range(n-1):
        arr[i] = arr[i+1]
    arr[n-1] = temp
         
 
def printArray(arr,size):
    for i in range(size):
        print ("%d"% arr[i],end=" ")
 

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
		3 4 5 6 7 1 2
		类似冒泡排序的解法引入temp变量
	def leftRotate(arr, d, n):
    for i in range(gcd(d,n)):
         
        temp = arr[i]
        j = i
        while 1:
            k = j + d
            if k >= n:
                k = k - n
            if k == i:
                break
            arr[j] = arr[k]
            j = k
        arr[j] = temp

def printArray(arr, size):
    for i in range(size):
        print ("%d" % arr[i], end=" ")

def gcd(a, b):
    if b == 0:
        return a;
    else:
        return gcd(b, a%b)

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
	def rverseArray(arr, start, end):
    while (start < end):
        temp = arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        start += 1
        end = end-1
 
def leftRotate(arr, d):
    n = len(arr)
    rverseArray(arr, 0, d-1)
    rverseArray(arr, d, n-1)
    rverseArray(arr, 0, n-1)
 
def printArray(arr):
    for i in range(0, len(arr)):
        print (arr[i], end=' ')
 
arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2)
printArray(arr)



Python 将列表中的指定位置的两个元素对调
	定义一个列表，并将列表中的指定位置的两个元素对调。

例如，对调第一个和第三个元素：

对调前 : List = [23, 65, 19, 90], pos1 = 1, pos2 = 3
对调后 : [19, 65, 23, 90]
	def swapPositions(list, pos1, pos2):
     
    list[pos1], list[pos2] = list[pos2], list[pos1]
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
     
    first_ele = list.pop(pos1)    
    second_ele = list.pop(pos2-1)
     
    list.insert(pos1, second_ele)  
    list.insert(pos2, first_ele)  
     
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
 
    get = list[pos1], list[pos2]
       
    list[pos2], list[pos1] = get
       
    return list
 
List = [23, 65, 19, 90]
 
pos1, pos2  = 1, 3
print(swapPositions(List, pos1-1, pos2-1))
	def reversal(list,n1,n2):
    temp = list[n1]
    list[n1] = list[n2]
    list[n2] = temp
    print(list)
list = [1,2,3,4,5,6,7]
reversal(list,4,5)



Python 翻转列表
	定义一个列表，并将它翻转。

例如：

翻转前 : list = [10, 11, 12, 13, 14, 15]
翻转后 : [15, 14, 13, 12, 11, 10]
	def Reverse(lst):
    return [ele for ele in reversed(lst)]
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    lst.reverse()
    return lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    new_lst = lst[::-1]
    return new_lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))





Python 将字符串的时间转换为时间戳
	import time
 
a1 = "2019-5-10 23:40:00"
# 先转换为时间数组
timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")
 
# 转换为时间戳
timeStamp = int(time.mktime(timeArray))
print(timeStamp)
 
 
# 格式转换 - 转为 /
a2 = "2019/5/10 23:40:00"
# 先转换为时间数组,然后转换为其他格式
timeArray = time.strptime(a2, "%Y/%m/%d %H:%M:%S")
otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)
print(otherStyleTime)

```

# jmeter必备总结

## 1. 接口概述(了解)

### **1.1 什么是接口呢？**

接口一般来说有两种，一种是程序内部的接口，一种是系统对外的接口; 或者一种是软件接口,一种是硬件接口. 

我们常说的接口是应用程序编程接口,也就是Application Programming Interface,简称API.

### **1.2 常见接口**

1. webService接口：是走soap协议通过http传输，请求报文和返回报文都是xml格式的，我们在测试的时候都用通过工具才能进行调用，测试。可以使用的工具有SoapUI、jmeter、loadrunner等；

2. http api接口：是走http协议，通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json串，有get和post等方法，这也是最常用的两种请求方式。可以使用的工具有postman、RESTClient、jmeter、loadrunner等；

### **1.3 使用接口的优点**

- 项目开发中,使用接口带来的优点

```
1. 统一设计标准；
2. 前后端开发相对独立；
3. 扩展性灵活；
4. 前后端都可以使用自己熟悉的技术；
```

- 项目开发中,未使用接口的缺点

```
1. 研发标准不统一，团队磨合难度高
2. 研发周期长
3. 可扩展性差
```

### **总结：**

- 软件项目开发模式大多数都采用接口了，那我们作为软件测试人员要学接口吗?

> **复习-接口的组成部分**

## 2. 接口测试

### **2.1 什么是接口测试**

接口测试是测试系统组件间数据交互的一种方式. 

接口测试就是通过测试不同情况下的输入参数和与之对应的输出结果来判断接口是否符合或满足相应的功能性、安全性要求.

***简单的说,接口测试是就是代替前端或者第三方,来验证后端实现是否符合接口规范.***

###  **2.2 接口测试的好处**

通过接口测试,测试接口的正确性和稳定性, 能快速定位bug,提高测试效率. 

- 能为项目平台带来高效的缺陷监测和质量监督能力；
- 平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）

### **2.3 接口测试原理**

**原理:**

**模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收响应数据后并进行判断**

- 请求: 是否正确, 默认请求成功是返回200, 假如请求错误返回400, 404, 500等状态码
- 检查: 返回数据的正确性与完整性
- 安全性: 接口一般不会暴露在网上任意被调用,需要做一些限制,比如必须登录或者请求次数、频率限制

### **2.4 基本流程**

接口测试流程: 定位服务器接口资源并提交测试数据，然后查看响应结果是否符合预期

1. 定位接口资源(URL)

2. 提交测试数据

3. 检查响应结果

### **2.5 接口测试分类**

- web接口测试
- 模块接口测试

##### (1). web接口测试

- 服务器接口测试, 是测试浏览器与服务器的接口, 是B/S架构的

- 外部接口测试, 测试第三方接口,

  > 举例：支付接口测试/天气预报接口测试

#### (2). 模块接口测试

- 单元测试的基础,主要测试模块的调用与返回.

## 3. 如何做好接口测试

接口测试要遵循一些要点:

1. 接口的功能性实现. 检查接口返回的数据与预期结果的一致性.
2. 测试接口的容错性, 例如传递的数据类型是错误的能否处理.
3. 测试接口参数的边界值. 例如传递的数据足够大或者为负数时能否处理
4. 测试接口性能, 接口处理和响应数据的时间也是测试的一个方面, 这牵扯到代码实现的优化
5. 测试接口的安全性. 特别是第三方接口,比如登录的用户名密码第三方是否是密文传输的





# 测试用例八大要素

| 测试用例编号 | 测试项目(测试模块) | 预置(前提)条件 | 测试输入 | 预期输出 | 操作步骤 | 测试用例标题 | 级别 |

1. **用例的设计者**:能准确找到测试用例的设计人员,对用例修改时能方便找到人员
2. **用例设计日期**: 方便检查用例的设计进度
3. **对应的开发人员**: 出现bug后能及时找到相应的人员进行修复
4. **测试结果**: 执行用例最后执行的结果, 包括:pass、fail、block
5. **测试类型**: 功能、性能、压力等等

常用的测试用例设计方法有: **等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果图法、功能图法**.
	等价类划分
		等价类划分
		使用最少的测试数据,达到最好的测试质量.
		等价类划分法的测试思想是:
		从大量数据里划分范围（每个范围内的数据测试效果是等价的所以每个范围是一个等价类），然后从每个范围中挑选代表数据，这些代表数据能反应这个范围内数据的测试结果。
		官方定义:
		等价类测试方法是把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。使用等价类划分方法设计测试用例要经历划分等价类（列出等价类表）和选取测试用例两步，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。
		等价类的类型划分分为:有效等价类和无效等价类.
		(1). 有效等价类
		有效等价类是指对对于程序的规格说明来说是合理的、有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能.
		(2). 无效等价类
		无效等价类指对程序的规格说明是不合理的、无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。利用无效等价类可校验程序对于无效数据的处理能力,检测程序的健壮性、容错能力
		注意:
		设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。
		3. 案例
要求:使用等价类划分法测试QQ账号的合法符合规范

明确需求	输入6-10位的自然数	
有效等价类	有效等价类	自然数个数大于6小于10个
无效等价类	无效等价类	小于6个、大于10个、中文、空格、英文、特殊字符、小数
设计测试用例	有效等价类测试用例	无效等价类测试用例
		

	边界值分析法
		边界值分析法就是对输入或输出边界值进行测试的,也是一种黑盒测试.
		边界值分析法通常作为等价类划分法的补充,其测试用例来自等价类的边界;长期的经验得知,大量的错误是发现在输入或输出范围的边界上，而不是发生再输入输出范围的内部，因此针对各种边界情况设计测试用例，可以查出更多错误.
		和等价类划分法的区别:
		是等价类划分法的补充
		等价类划分法可以挑选等价范围内任意一个数据作为代表,边界值分析法要求每个边界值都要作为测试条件
		边界值分析法不仅考虑输入条件,同样考虑输出产生的测试情况
		常见的边界值:
		边界点(上点):输入范围的边界点
		离点: 离边界点最近的点
		内点: 输入范围内的任意一个点
		对于边界值的说明:
		边界值数据本质上属于等价类的范畴,测试时确实是一种冗余（重复），但是为了更好的测试质量（边界值特别容易出bug），边界值必须要单独测,适当必要的冗余是可以接受的.
		
		2.1 步骤:

明确需求
确定有效和无效等价类
明确输入条件中的边界值
编写测试用例
注意: 边界值法应用时，如果测试时间紧张，应该优先测试最大值和最小值
		

		3. 小结
			边界值分析法作为等价类划分法的补充,经常和等价类划分一起使用.
			使用的场景是:有输入并且存在边界值的位置.
	判定表法
		判定表法
		1. 使用场景
		适合于有多个输入和对个输出,输入和输出之间有相互的组合关系, 输入输出之间有相互的制约和依赖关系
		2. 定义
		判定表也称决策表, 是分析和表达多逻辑条件下执行不同操作的工具.
		它能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此,利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。
		3. 组成
		判定表是由条件桩、动作桩、条件项、动作项四部分组成,如下图.
		条件桩	条件项
		动作桩	动作项
		1） 条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。
		2） 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。
		3） 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。
		4） 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。
		4.规则及规则合并
		4.1 规则
		任何一个条件组合的特定取值及其相应要执行的操作称为规则。
		在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。
		4.2 化简
		规则合并有两条或多条规则具有相同动作,并且其条件项之间存在着极为相似的关系。
		5. 测试案例设计
		步骤:
		明确规则个数
		列出所有条件桩和动作桩
		填入条件项
		填入动作项,等到初始判定表
		简化,合并相似规则


​		
​		
​		
​		
​	因果图法
​		1. 概述
​		因果图法是一种利用图解法分析输入条件、输出结果的各种组合情况,从而设计测试用例的方法.
​		因果图法适用于有多个输入和多个输出，而且输入和输入之间有相互的组合关系，输入和输出之间有相互的制约和依赖关系.
​		使用场景和判定表法是一样的.
​		在界面中有多个控件，控件之间有组合或限制关系，不同的输入组合会对应不同的输出结果，如果想弄清楚不同的输入组合到底对应哪些输出结果，可以使用因果图/判定表法。(因果图/判定表法比较适合测试组合数量较少的情况，一般少于20种)
​		和判定表法的不同:
​		因果图，只是一个用图形表示，表示因果方式不同而已
​		关联:
​		判定表和因果图是等价的，判定表是因果图的简化版。
​		2.核心
​		2.1 因果图
​		原因(因): 输入条件
​		结果(果): 输出结果
​		因果图: 就是通过画图的方式来表示输入条件（因）和输出结果（果）之间的关系。
​		2.2 因果图中的图形符号
​		(1). 恒等(=)
​		恒等
​		含义: 原因出现结果出现,原型不出现,结果不出现. 例如:若c=10,则d=0.
​		(2). 非 (~)
​		非
​		含义: 若原因出现,则结果不出现;原因不出现则结果出现.例如: 搜索联系人,若有就不提示错误.
​		(3). 或 (v)
​		或
​		含义: 若几个原因中有一个出现,这结果出现;若都不出现,结果不出现.
​		(4). 与(^)
​		与
​		含义: 若几个原因都出现结果才出现,否则,结果不出现.
​		2.3 约束
​		输入状态相互之间还可能存在某些互相依赖的关系,称为约束. 输出状态之间也存在某些约束.在因果图中使用特定符号表示这些约.
​		束.
​		约束
​		(1). 输入条件约束
​		E(exclude) 约束: a和b中至多有一个为1.
​		I(include) 包含: a、b和c中至少有一个必须是1.
​		R(required) 要求: a是1时，b必须是1.
​		O(only) 唯一: a和b必须有一个，且仅有1个为1.
​		(2). 输出条件约束
​		M(mandatory) 强制: 若结果a是1,结果b强制为0.
​		3. 设计测试用例
​		步骤
​		了解需求,找出所有的输入条件(因)
​		找出所有的输出结果(果)
​		画因果图、填判定表
​		判定表中每个规则就是一条测试用例


​		小结
​			5.小结
​			因果图法是通向判定表法的一个中间过程.我们经常会将因果图法和判定表分析法结合起来使用.
​			对于业务逻辑比较复杂的我们建议先使用因果图法进行分析,然后再转化为判定表法,最后写测试用例.这样思路比较清晰,
​			对于简单的可以直接使用判定表法直接分析,然后写测试用例.
​	正交验证法
​		1.1 定义
​		正交法,也叫正交实验法或者正交排列法, 就是使用最小的测试过程集合获得最大的测试覆盖率。
​		“正交实验”是研究多因素、多水平的一种实验方法,它利用正交表来对实验进行设计,通过少数实验代替全面的实验.
​		在一项实验中,把影响试验结果的量称为试验因素(因子)，简称因素。因素可以理解为试验过程中的自变量，试验结果可以看成因素的函数。在试验过程中，每一个因素可以处于不同的状态或状况，把因素所处的状态或状况，称为因素的水平，简称水平。
​		
​		2. 使用正交法设计测试用例
​		2.1 步骤
​		根据需求把空间即其取值列举出来
​		根据空间和空间的取值个数,选择一个合适的正交表
​		根据控件的个数,选择正交表的次幂,也就是正交表中包含的最大值, 例如,4个控件,选择4次幂
​		根据控件取值个数,选择正交表的底,也就是正交表包含的最大值, 例如, 每个控件有3个取值,底是3
​		把控件及其取值映射到正交表中
​		把控件名字分别映射到正交表的列名位置
​		把正交表中每一列的数字分别用对应的控件取值替代
​		根据正交表,编写测试用例


​		小结
​			正交实验法，就是使用已经造好了的表格——正交表来安排实验并进行数据分析的一种方法
​			使用最小的测试过程集合获得最大的测试覆盖率。
​			3.1 使用场景
​			需求中条件的组合量比较大的时候
​			需求两个两个相互组合的时候
​			3.2 局限性
​			正交表的个数有限,一般要求每个控件的取值相等,但是这在实际中很难应用,所以在实际使用时要进行取舍
​			对于控件个数,如果没有,就选择一个接近的
​			对于控制的取值,应该少数服从多数, 有更多空间的取值一样
​	场景法
​		1. 概述
​		1.1 为什么使用场景法设计测试用例
​		大多数业务软件由后台管理（比如：用户管理、角色管理、权限管理等等各种管理）和工作流等几个部分组成。终端用户，期望软件能够实现业务需求，而不是简单的功能的组合。对于单点功能利用等价类、边界值、判定表用例设计方法能够解决大部分问题。涉及业务流程的软件系统，采用场景法比较合适。
​		总之, 对于多个功能组合测试的场景适合使用场景法, 所以场景测试,也是业务场景组合测试.
​		1.2 概念
​		场景流程图-------------------------每一个场景就是一条测试用例
​		场景业务流通常分为: 基本流、备选流、异常流程
​		(1) 基本流
​		基本流表示通过业务流程时输入都正确，能达到目标的流程
​		(2) 备选流
​		备选流表示通过业务流程时输入错误（或者操作错误）导致流程存在反复，但是经过纠正后仍能达到能达到目标的流程.（插卡-->输入错误密码--》输入正确密码--》输入金额--》取款--》取卡）
​		(3) 异常流
​		异常流表示通过业务流程时输入错误（或者操作错误）产生异常终止流程
​		2. 使用场景法设计测试用例
​		1. 步骤
​		分析需求,确定基本流程、备选流程、异常流程
​		绘制流程图,确定流程路径, 根据流程图生成不同的场景
​		每一个场景就是一条测试用例

​		小结
​			场景流程比较适合于涉及到业务需求的场景, 能够多个功能联合进行测试,不是单个功能进行测试.

			1. 步骤
			分析需求,确定基本流程、备选流程、异常流程
			绘制流程图,确定流程路径, 根据流程图生成不同的场景
			每一个场景就是一条测试用例
	功能图法
		功能图法  						---	功能图形象的描述程序的功能说明，并机械的生成功能图的测试用例
			2. 
			3. 
			4. 
			5. 
			1. ​		一个程序的		功能说明通常由动态说明和静态说明组成.
	​		动态说明描述了输入数据的次序或转移的次序.静态说明描述了输入条件与输出条件之间的对应关系.
	​		对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例.
	​		功能图模型由状态迁移图和逻辑功能模型构成.
	​		状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.
	​		逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。
	​		功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.
	​		逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.
	​		由于覆盖测试的目标不同,逻辑覆盖可分为:
	​		语句覆盖
	​		判定覆盖
	​		判定-条件覆盖
	​		条件组合覆盖
	​		路径覆盖
	​		1.2 组成
	​		功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.
	​		eg：
	​		1.3 设计测试用例
	​		(1). 生成测试用例的规则
	​		从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.
	​		为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.
	​		在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.
	​		(2). 步骤
	​		生成局部测试用例: 在每个状态中,从因果图生成局部测试用例.局部测试用例由输入数据与对应的输出数据或状态构成。
	​		测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。
	​		测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。
	​		小结
	​			功能图设计方法：功能图方法使用功能图形象地表示程序的功能说明，并机械地生成功能图的测试用例。
	​	错误推测法
	​		2.1 定义
	​		错误推测法是: 基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。
	​		2.2 基本思想
	​		根据经验,列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。
	​		2.3 使用场景
	​		适用于项目时间比较短促,任务比较繁重的情况下



![image-20230129092045067](C:/Users/571290717/Desktop/%25E9%259D%25A2%25E8%25AF%2595%25E9%259D%25A2%25E7%25BB%258F.assets/image-20230129092045067-16749552470691.png)



# 计算机网络



一、网络 7 层架构(ISO/OSI协议参考模型)
	物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
	数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
	网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
	传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。
	会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
	表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
	应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。
	
	
	

二、TCP/IP 原理
	TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。
	

	1、应用层(Application Layer)
	    应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。
	2、传输层(Tramsport Layer-TCP/UDP)
	    传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
	3、网络层(Internet Layer)
	  网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP，Internet Protocol)。
	4、网络访问层(Network Access Layer)
	   网络访问层(Network Access Layer)在 TCP/IP ：是TCP/IP协议栈的最底层，它提供物理网络的接口，实现对复杂数据的发送和接收。网络访问层协议为网络接口、数据传输提供了对应的技术规范。网络访问层对应 OSI 七层网络模型的物理层和数据链路层。
	5、四层协议和对应的标准七层协议的关系如下图
	————————————————

三、TCP 三次握手/四次挥手
	1、三次握手
	SYN：同步序列编号（Synchronize Sequence Numbers）、seq：序号--sequence number、
ACK (Acknowledge character）即是确认字符  、ack number 确认序号
	第一次握手： 主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器主机 B，由 SYN=1 知道，A 要求建立联机；
	第二次握手： 主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包
	第三次握手： 主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认。
	

	2、四次挥手
	TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。
	关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u
	服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
	关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。
	客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
	————————————————
	主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到close 状态。
	为什么会有TIME_WAIT状态：
		确保有足够的时间让对方收到ACK包
		避免新旧连接混淆
	3、TCP/IP状态
		1、LISTENING（listening)
		FTP服务启动后首先处于侦听（LISTENING）状态。
		2、ESTABLISHED（established）
		建立连接。表示两台机器正在通信。
		3、CLOSE_WAIT
		对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT，此时我方要调用close()来使得连接正确关闭。
		4、TIME_WAIT
		我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。
		5、SYN_SENT
		SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED。

四、TCP 长连接与短连接
	1、长连接和短连接使用原因
	当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次挥手，所以说每个连接的建立都是需要资源消耗和时间消耗的。
	2、HTTP的长连接和短连接
	HTTP的长连接和短连接本质上是TCP长连接和短连接。
	在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
	而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
	Connection:keep-alive
	1
	在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
	3、TCP—长连接
	 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。
	连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；
	这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；
	 TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
	4、TCP—短连接
	 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；
	 连接→数据传输→关闭连接；
	5、应用场景
	 长连接： 多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。
	例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
	 短连接： 像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

五、HTTP原理
	 HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。
	1、地址解析
	如用客户端浏览器请求这个页面：http://www.lydms.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
	协议名： http
	主机名： www.lydms.com
	端口： 8080
	对象路径： /index.htm
	在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。
	2、封装 HTTP 请求数据包
	把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包
	3、封装成 TCP 包并建立连接
	封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）
	4、客户机发送请求命
	客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。
	5、服务器响应
	服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。
	6、服务器关闭 TCP 连接
	一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

六、HTTPS
	六、HTTPS
	HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：
	1、SSL/TLS之间的关系
	SSL 是英文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。
	为啥要发明 SSL 这个协议呢？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。
	到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
	很多人都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。
	2、建立连接获取证书
	SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
	3、证书验证
	Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
	4、数据加密和传输
	如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。
	

七、CDN 原理
	CND 一般包含分发服务系统、负载均衡系统和管理系统。
	1、分发服务系统
	其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。
	2、负载均衡系统
	负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。
	3、管理系统
	分为运营管理和网络管理子系统。网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。
	包括用户管理、产品管理、计费管理、统计分析等。

八、TCP/IP协议族
	TCP/IP只提供无连接、不可靠的服务。
	传输之前需要进行三次握手。
	IP的主要功能包括将上层数据(如TCP、UDP数据)或者同层的其它数据(如ICMP数据)封装到IP数据报中，将IP数据报传送到最终目的地；为了使数据能够在链路层上进行传输，对数据进行分段，确定数据报到达其它网络中的目的地的路径。
	1、应用层协议—文件传输服务(FTP)
	用来在计算机之间传输文件。
	实际Internet的FTP服务是一种匿名(anonymous)FTP服务，设置一个特殊的用户名-anonymous，供公众使用。
	匿名登录到FTP服务器后，其工作方式与常规FTP相同。通常处于安全目的，大多数匿名FTP服务器只允许下载，不允许上传文件。
	FTP在客户端到服务器建立2条TCP连接，一条是控制连接，主要用于传输命令和参数(端口21)；另一条是数据连接，主要用于传输文件(端口号20)。
	2、应用层协议—远程登录协议(Telnet)
	远程登录服务实在Telnet协议的支持下，将用户计算机和远程主机连接起来，在远程计算机上运行程序，用户输入的信息通过Telnet协议发送给远程主机，主机在TCP端口监听用户请求，并处理后，将结果通过Telnet协议返回给客户。客户再经过适当的转换显示在计算机屏幕上。因为使用Telnet命令进行远程登录，所有称为Telnet远程登录。
	由客户端软件、服务器软件以及Telnet通用协议三部分组成。
	3、应用层协议—电子邮件协议（SMTP)
	电子邮件(E-mail)利用计算机进行信息交换的电子媒体信件。
	基于客户端/服务器模式，有E-mail客户端软件、E-mail服务器、通信协议三部分组成。发送邮件，首先到达自己注册的邮件服务器主机，再在网络传输中经过多个计算机和路由中转到达目的地的邮件服务器主机，进入收件人的电子邮箱，最后邮件的接收者上网并启动电子邮件管理程序，会自动下载到自己计算机，完成接受邮件。
	SMTP：简单邮件传输协议
	MIME：Internet邮件扩充协议
	PEM：增强私密邮件保护协议
	POP：来保管用户未能及时取走的邮件，简单的纯文本协议，每次传输以正规E-mail为单位，不提供部分传输。
	4、传输层协议—TCP
	在IP提供的不可靠数据服务的基础上为应用程序提供一个可靠的、面向连接的、全双工的数据传输服务。TCP在源主机和目的之间建立和关闭连接操作是，均需要通过三次握手来确认建立和关闭是否成功。TCP虽然提供了一个可靠的数据传输服务，但是以牺牲通信量来实现的。
	TCP采用了重发技术： 发送数据时，启动定时器，在规定时间内没有收到确认信息，就重新发送数据包。
	5、传输层协议—UDP
	用户数据报协议是一种不可靠、无连接的协议，与同层面向连接的TCP相比，UDP是一种无连接的协议(无错误检测功能)。TCP有助于提供可靠的连接，UDP有助于提高传输的高速率性。不负责重新发送丢失的包，不对接收的数据进行排序，不消除重复的IP数据报，不负责建立和终止连接。(都是UDP应用程序负责的)
	TCP：交互式会话应用程序(FTP等)。
	UDP：自己进行错误检测、不需要检测错误(DNS、SNMP)。
	6、网际层协议—IP
	IP只提供无连接、不可靠的服务，把差错检测和流量控制之类的服务授权给了其他层的协议。
	IP的主要功能：
	将上层数据(TCP、UDP数据)或同层其他数据(ICMP数据)封装到IP数据报中；
	将IP数据报传送到最终目的地；
	为了使数据能够在链路层上进行传输，对数据进行分段；
	确定数据报到达其它网络中的目的地的路径。
	7、网际层协议—ICMP
	Internet控制信息协议，用于发送查错报文的协议。ICMP让IP更加稳固。也是利用IP来传送报文的。ping工具就是利用ICMP报文进行目标是否可达测试。
	5种差错报文：(源抑制、超时、目的不可达、重定向和要求分段)
	4种信息报文：回应请求、回应应答、地址屏蔽码请求和地址屏蔽码应答。
	8、网际层协议—ARP和RARP
	地址解析协议(ARP)和反地址解析协议(RARP)
	ARP的作用是将IP地址转为物理地址，RARP的作用是将物理地址转为IP地址。每台设备都有唯一的物理地址(通过网卡给出)，为了屏蔽底层协议及物理地址上的差异，IP协议又使用了IP地址。因此，在传输过程中，必须对IP地址和物理地址进行相互转换。
	9、网络接口层协议—以太网(Ethernet IEEE 802.3
	Ethernet IEEE 802.3：标准局域网，速度10Mps，传输介质为铜缆。
	Ethernet IEEE 802.3u：快速以太网，速度100Mps，传输介质为双绞线。
	Ethernet IEEE 802.3z：千兆以太网，速度1000Mps，传输介质为光纤或双绞线。
	10、网络接口层协议—令牌环网(Ethernet IEEE 802.5)
	1、只有拥有令牌才可以发送数据。
	2、发送数据时，需要捕获一个令牌。
	3、令牌不为空，需要等待。
	11、网络接口层协议—光纤分布式数据接口(FDDI)
	以光纤为传输介质。
	采用双环体系结构，两环上的信息反方向流动。双环中一环称为主环，另一个环称为次环。正常情况下，主环传输数据，次环处于空闲状态。
	双环设计的目的是提供高可靠性和稳定性。FDDI定义的传输介质有单模光纤和多模光纤两种。
	12、网络接口层协议—点对点协议(PPP)
	主要用于”拨号上网“这种广域连接模式。优点简单、具备用户验证功能、可以解决IP分配等。为各种主机、网桥和路由器之间简单连接的一种通用解决方案。
	利用以太网(Ethernet)资源在以太网上运行PPP来进行用户认证接入的方式成为PPPoE。是目前ADSL接入方式中最广泛的技术标准。
	ATM网络撒花姑娘运行PPP来管理用户再认证的方式成为PPPoA。
	PPPoA和PPPoE运行原理相同，不同的是运行环境的不同。
	13、其他—ADSL(非对称用户数据线)
	ADSL Modem上网拨号方式有3中，即专线方式(静态IP)、PPPoA和PPPoE。
	ADSL独享带宽，安全可靠。费用低廉,使用过去的电话线路，可以分离电话机和ADSL Modem(上网)。
	14、其他—IPv4和IPv6
	IPv4：32位二进制，能表示IP地址个数：2^32=40亿
	IPv6:128位二级制，能表示IP地址个数：2128=3.4*1038。

1、TCP和UDP的区别
	TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输；
	TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报；
	TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

2. TCP和UDP分别对应的常见应用层协议？
   2.1 TCP对应的应用层协议
    FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
    Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
    SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
    POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
    HTTP：从Web服务器传输超文本到本地浏览器的传送协议。
   2.2 UDP对应的应用层协议
    DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
    SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
    TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

   各协议对应的端口号

   摘自计算机网络(面试必备知识点)

3. TCP协议如何来保证传输的可靠性
   TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
   对于可靠性，TCP通过以下方式进行保证：
   数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据超时后会重发数据；
   对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
   丢弃重复数据：对于重复数据，能够丢弃重复数据；
   应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
   超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
   流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

4. 解释一下IP的定义，在哪个层上？主要作用是？TCP与UDP呢？
   IP是 Internet protocol 的缩写，是网络层的主要协议，作用是提供不可靠、无连接的数据包传输协传送。
    TCP是 Transmit Control Protocol（传输控制协议），在传输层，TCP提供一种面向连接的、可靠地字节流服务。
    UDP是 User Datagram Protocol（用户数据报协议），在传输层，UDP提供不可靠的传输控制数据服务。

5. IP地址的分类
   IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。
   　　
     每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：
    A类地址：以0开头，第一个字节范围：0~127；
    B类地址：以10开头，第一个字节范围：128~191；
    C类地址：以110开头，第一个字节范围：192~223；
    D类地址：以1110开头，第一个字节范围为224~239；
    E类地址：以1111开头，保留地址

6. 分别写出OSI、TCP/IP及五层协议的体系结构
   从上至下
   OSI：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
   TCP/IP：应用层、运输层、网际层、网络接口层；
   五层协议：应用层、运输层、网络层、数据链路层、物理层；

   6.1 OSI每一层对应的协议
   	体系	协议
   	物理层	RJ45、CLOCK、IEEE802.3 （中继器，集线器）
   	数据链路	PPP、FR、HDLC、VLAN、MAC（网桥，交换机）
   	网络层	IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、（路由器）
   	传输层	TCP、UDP、SPX
   	会话层	NFS、SQL、NETBIOS、RPC
   	表示层	JPEG、MPEG、ASII
   	应用层	FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
   	
   6.2 OSI每一层的作用
   	体系	作用
   	物理层	通过媒介传输比特,确定机械及电气规范（比特Bit）
   	数据链路层	将比特组装成帧和点到点的传递（帧Frame）
   	网络层	负责数据包从源到宿的传递和网际互连（包PackeT）
   	传输层	提供端到端的可靠报文传递和错误恢复（段Segment）
   	会话层	建立、管理和终止会话（会话协议数据单元SPDU）
   	表示层	对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
   	应用层	允许访问OSI环境的手段（应用协议数据单元APDU）
   	拓展：
   	网关的定义：一个链接两种不同协议簇的进程，为某一个特定的应用提供服务。
   	在TCP/IP协议簇中，IP层使用不可靠的服务，TCP提供可靠的服务，为了提供可靠到的服务，TCP采用了超时重传，发送和接收端到端的确认分组机制。
   	网桥是在数据链路层对网络进行互联的，路由器是在网络层对网络进行互联的。

7. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。典型的算法：DES
     由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。典型的算法：RSA

8. Get与POST的区别
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
   GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
   GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

9. ipconfig和netstat的作用？
   ipconfig显示当前TCP/IP配置的信息，帮助用户查看网络状况，可以看到很多网络信息，比如延迟，IP，主机信息，物理地址信息等。
   netstat主要用于提供系统的接口命令。可以使用相关参数打印出每一个接口的MTU、输入分组数、输入错误、冲突以及当前的输出队列长度。

10. 两台笔记本连起来后ping不同，可能是哪些原因？
    网线问题。确认网线连接是否正确，电脑之间连的线和电脑与USB之间连的线分正线、反线，是不同的。但是对于使用千兆网卡的除外，千兆位网卡有自动识别功课，既可以是正线也可以是反线。
    局域网设置问题。电脑互连是要设置的，看看是否安装了必要的网络协议，最重要的是，IP地址是否设置正确，互联的时候最好一台电脑为正，一台电脑为副，为主的设为网关。
    网卡驱动未正确安装
    防火墙设置有问题
    是否有什么软件阻止ping包

11. 运行net share返回结果是什么?
    显示本地计算机上所有共享资源相关信息。如果加上参数 ShareName ，则仅显示有关该共享的信息。

12. net use和net user 分别指什么？
     net use是对用户进行管理，如添加、删除网络使用用户等。
     net user 是对网络设备进行管理

13. 交换和路由的区别是什么，VLAN有什么特点？
    交换机是指转发和过滤帧，是交换机的工作，它在OSI参考模型的第二层。
    而路由器是指网络线路当中非直连的链路，它是路由器的工作，在OSI参考模型的第三层。
    交换和路由的区别很大。首先，交换是不需要IP的，而路由需要，因为IP就是第三层的协议，第二层需要的是MAC地址；再有，第二层可以做NAT、ACL、QOS等。
    VLAN是虚拟局域网络的英文缩写，它是一个纯二层的技术，它的特点有三个：控制广播，安全，灵活性和可扩展性。

14. 简单描述DNS域名系统的工作原理
    当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括3条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53.该应用一般不直接为用户使用，而是为其他应用服务，如HTTP,SMTP等，在其中需要完成主机名到IP地址的转换。

    原文链接：https://blog.csdn.net/weixin_41948075/article/details/88625382

15. 提供可靠数据流传输控制的是OSI的第几层？
    会话层

16. 在浏览器中输入www.baidu.com后执行的全部过程
    1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过该IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，通过TCP进行封装数据包，输入到网络层。
    2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口，然后使用IP层的IP地址查找目的端。
    3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过过哪个路径到达服务器。
    4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

17. ARP是地址解析协议，简单解释一下工作原理？
    首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
    当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
    当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
    源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。



操作系统定义
	操作系统直接运行在计算机上的系统软件， 它是控制硬件和支持软件运行的计算机程序。
	. 操作系统的作用
	向下控制硬件向上支持软件的运行，具有承上启下的作用

Linux基础
	Linux基础知识
		熟练使用Linux常用命令，熟练部署基于Linux系统的测试环境。
		Linux内核是操作系统内部操作和控制硬件设备的核心程序，它是由芬兰人林纳斯开发的。
		真正操作和控制硬件是由内核来完成的，操作系统是基于内核开发出来的。
		是Linux内核与各种常用软件的组合产品，通俗来说就是我们常说的Linux操作系统。
		常用的Linux发行版:
		Ubuntu
		CentOS
		Redhat
		3. 小结
		Linux内核是Linux操作系统管理硬件设备的核心程序
		常用的Linux操作系统都是基于Linux内核开发出来的
	目录命令
		1. 查看目录命令的使用
		命令	       说明
		ls	查看当前目录信息
		tree	以树状方式显示目录信息
		pwd	查看当前目录路径
		clear	清除终端内容
		cd 目录	切换到指定目录
		cd ~	切换到当前用户的主目录
			注意:
			cd命令切换目录时，这个目录必须存在。
			cd 后面不写目录等价于cd ~
		cd ..	切换到上一级目录
		cd .	切换到当前目录
		cd -	切换到上一次目录
		子主题 12
	绝对路径和相对路径
		绝对路径
			从根目录算起的路径叫做绝对路径
		相对路径
			从当前目录算起的路径叫做相对路径
		绝对路径和相对路径的使用
			使用绝对路径切换到桌面
			cd /home/python/Desktop
			在下载目录以相对路径切换到桌面
			cd Downloads
			cd ../Desktop
			在桌面使用相对路径切换到上一级目录的上一级目录 cd Desktop cd ../../
		自动补全
			当敲出 文件或者目录或者命令 的前几个字母之后，按下 tab 键，如果输入的没有歧义，系统会自动补全
			当切换目录或者使用命令的时候，如果不确定当前目录下有那些子目录或者其它命令，可以通过两次tab键查看
	文件及目录命令
		touch 文件名	创建指定文件
		mkdir 目录名	创建目录(文件夹)
			1. mkdir命令选项
			命令选项	说明
			-p	创建所依赖的文件夹
		rm 文件名或者目录名	删除指定文件或者目录
			rm命令想要删除目录需要加上-r选项，-r表示递归删除目录及其内容
			2. rm命令选项
			命令选项	说明
			-i	交互式提示
			-r	递归删除目录及其内容
			-f	强制删除，忽略不存在的文件，无需提示
			-d	删除空目录
		rmdir 目录名	删除空目录
		cp	拷贝文件、拷贝目录
			拷贝目录需要加上-r选项，-r表示递归拷贝目录及其内容
			1. cp命令选项
			命令选项	说明
			-i	交互式提示
			-r	递归拷贝目录及其内容
			-v	显示拷贝后的路径描述
			-a	保留文件的原有权限
		mv	移动文件、移动目录、重命名
			2. mv命令选项
			命令选项	说明
			-i	交互式提示
			-v	显示移动后的路径描述
		小结
			创建嵌套文件夹使用 “mkdir –p” 嵌套目录
			删除空目录使用 “rmdir 目录名” 或者 “rm –d 目录名”
			删除非空目录使用 “rm –r 目录名”
			拷贝文件防止覆盖使用 “cp –i” 操作
			拷贝文件夹使用 “cp –r” 操作，拷贝文件夹并且文件权限不丢失使用 “cp –a” 操作。
			移动文件防止覆盖使用 “mv –i” 操作
			移动文件夹直接使用 “mv” 即可，“mv” 还可以给文件和文件夹重命名。
	终端命令格式的组成
		1. 终端命令格式说明
		command [-options] [parameter]
		每项信息的说明:
		command：命令名, 比如: ls、pwd
		[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。
		[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。
		[]：代表可选
		2. 小结
		终端命令完整格式: 命令名 选项(可选) 参数(可选)
		选项：用于调整命令的功能，比如：-r选项调整cp命令的功能。
		选项可以分为短选项和长选项
		短选项的格式: '-'后面接单个字母, 比如:-r
		长选项的格式: '--'后面接单词, 比如:--help
		参数：命令的操作对象，一般是文件名或者目录名。
		对于命令，它的选项和参数一般情况下没有顺序要求，但是scp命令是必须先选项然后在跟上参数。
	查看命令帮助
		--help 使用说明: 命令 --help
		man 使用说明: man 命令
			man命令的说明:
			操作键	说明
			空格	显示下一屏信息
			回车	显示下一行信息
			b	显示上一屏信息
			f	显示下一屏信息
			q	退出
	ls命令选项-查看目录中隐藏文件的命令选项
		1. ls命令选项使用
		命令选项	说明
		-l	以列表方式显示
		-h	件大小单位显示，默认是字节
		-a	显示隐藏文件和隐藏目录
		每项信息说明:
		

# Linux高级

​	重定向命令
​		2. 重定向命令的使用
​		命令	说明
​		>	如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式
​		>>	如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式
​		小结
​			终端内容保存到文件使用重定向有两种方式: > 和 >>
​			> 表示每次只写入最新的数据，原有数据不保留。
​			>> 表示每次在原有数据的基础上进行追加，原有数据会保留。
​	查看文件内容命令
​		1. 查看文件内容命令的使用
​		命令	说明
​		cat	查看小型文件
​			说明:
​			cat命令结合重定向可以完成多个文件的合并
​			gedit 文件编辑命令，可以查看和编辑文件
​		more	分屏查看大型文件
​			操作键说明:
​			操作键	说明
​			空格	显示下一屏信息
​			回车	显示下一行信息
​			b	显示上一屏信息
​			f	显示下一屏信息
​			q	退出
​		2. 管道(|)命令的使用
​			管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。
​		小结
​			查看小文件使用 cat 命令
​			分屏查看大型文件使用 more 命令，
​			查看终端显示内容并分屏展示，使用 管道(|) 结合 more 命令。
​	链接命令
​		ln -s	创建软链接
​		ln	创建硬链接
​		软链接
​			类似于Windows下的快捷方式，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接。
​			注意点:
​			如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。
​			删除源文件则软链接失效
​			可以给目录创建软链接
​			3. 软链接小结
​			软链接的作用是方便文件的快速访问，比如:给一个复杂路径下的文件创建一个软链接，以后就可以通过软链接完成快速访问操作。
​			创建软链接命令格式: ln -s 源文件路径(使用绝对路径) 软链接
​			4. 硬链接
​		硬链接
​			### 4. 硬链接
​			类似于**源文件的一个别名**，也就是说这两个名字指向的是同一个文件数据。
​			**注意点:**
​			- **创建硬链接使用相对路径和绝对路径都可以**
​			- **删除源文件，硬链接还可以访问到数据。**
​			- **创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。**
​			- **创建软链接，硬链接数不会加1**
​			- **不能给目录创建硬链接**
​			**硬链接数:**
​			**硬链接数就是文件数据被文件名使用的次数, 好比引用计数**
​			### 5. 硬链接小结
​			- 硬链接的作用是可以给重要文件创建硬链接，能够防止文件数据被误删。
​			- 删除源文件，软链接失效，但是硬链接依然可以使用。
​			- 创建硬链接命令格式: ln 源文件路径 硬链接
​	文本搜索命令
​		grep	文本搜索
​			2. grep命令选项的使用
​			命令选项	说明
​			-i	忽略大小写
​			-n	显示匹配行号
​			-v	显示不包含匹配文本的所有行
​			3. grep命令结合正则表达式的使用
​			正则表达式	说明
​			^	以指定字符串开头
​			$	以指定字符串结尾
​			.	匹配一个非换行符的字符
​			 扩展
​			grep 命令还可以文本搜索管道中的内容，比如: ls / | grep ‘lib’
​			在使用 grep 命令的时候还可以省略搜索内容的引号，比如: ls / | grep lib， grep hello 1.txt
​		小结
​			grep 命令是完成文本搜索操作的
​			文本搜索的命令格式: grep 选项 文本搜索内容
​	查找文件命令
​		命令	说明
​		find	在指定目录下查找文件(包括目录)
​		find命令选项:
​		选项	说明
​		-name	根据文件名(包括目录名)字查找
​		2. find命令结合通配符的使用
​		通配符:
​		是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件
​		通配符	说明
​		*	代表0个或多个任意字符
​		?	代表任意一个字符
​		3. 小结
​			find命令是完成查找文件操作的
​			查找文件的命令格式: find 指定查找目录 -name "文件名"
​	压缩和解压缩命令
​		1. 压缩格式的介绍
​		Linux默认支持的压缩格式:
​		.gz
​		.bz2
​		.zip
​		说明:
​		.gz和.bz2的压缩包需要使用tar命令来压缩和解压缩
​		.zip的压缩包需要使用zip命令来压缩，使用unzip命令来解压缩
​		压缩目的:
​		节省磁盘空间
​		2. tar命令及选项的使用
​		命令	说明
​		tar	压缩和解压缩命令
​		tar命令选项:
​		选项	说明
​		-c	创建打包文件
​		-v	显示打包或者解包的详细信息
​		-f	指定文件名称, 必须放到所有选项后面
​		-z	压缩或解压缩(.gz)
​		-j	压缩或解压缩(.bz2)
​		-x	解包
​		-C	解压缩到指定目录
​		3. zip和unzip命令及选项的使用
​		命令	说明
​		zip	压缩成.zip格式文件
​		unzip	解压缩.zip格式文件
​		unzip命令选项:
​		选项	说明
​		-d	解压缩到指定目录
​		说明:
​		压缩文件尽量使用.gz格式，因为占用空间较少
​		使用zip命令压缩的文件占用空间比较多, 当时比较通用，操作更加简单。
​		4. 小结
​		.gz和.bz2的压缩文件使用tar命令来完成压缩和解压缩
​		.zip的压缩文件使用zip和unzip命令来完成压缩和解压缩
​	文件权限命令
​		1. chmod命令的介绍
​		命令	说明
​		chmod	修改文件权限
​		chmod修改文件权限有两种方式:
​		字母法
​		数字法
​		2. chmod 字母法的使用
​		角色说明:
​		角色	说明
​		u	user, 表示该文件的所有者
​		g	group, 表示用户组
​		o	other, 表示其他用户
​		a	all, 表示所有用户
​		权限设置说明:
​		操作符	说明
​		+	增加权限
​		-	撤销权限
​		=	设置权限
​		权限说明:
​		权限	说明
​		r	可读
​		w	可写
​		x	可执行
​		-	无任何权限
​		3. chmod 数字法的使用
​		数字法就是“rwx” 这些权限也可以用数字来代替
​		权限说明:
​		权限	说明
​		r	可读，权限值是4
​		w	可写，权限值是2
​		x	可执行，权限值是1
​		-	无任何权限，权限值是0
​		4. 小结
​		利用 chmod 命令可以控制文件的操作权限。
​		字母法格式: chmod 不同角色设置的权限 文件
​		数字法格式: chmod 不同角色的权限值 文件名
​	获取管理员权限的相关命令
​		1. sudo命令的使用
​		命令	说明
​		sudo -s	切换到root用户，获取管理员权限
​		sudo	某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo
​		说明:
​		如果只是某次操作需要使用管理员权限建议使用 sudo , 也就是说临时使用管理器权限。
​		如果大量操作都需要使用管理员权限 sudo –s, 但是操作需谨慎。
​		2. whoami命令的使用
​		命令	说明
​		whoami	查看当前用户限
​		3. exit命令的使用
​		命令	说明
​		exit	退出登录用户
​		说明:
​		如果是切换后的登陆用户，退出则返回上一个登陆账号。
​		如果是终端界面，退出当前终端。
​		4. who命令的使用
​		命令	说明
​		who	查看所有的登录用户
​		5. passwd命令的使用
​		命令	说明
​		passwd	修改用户密码，不指定用户默认修改当前登录用户密码
​		6. which命令的使用
​		命令	说明
​		which	查看命令位置
​		7. 关机和重启命令的使用
​		命令	说明
​		shutdown –h now	立刻关机
​		reboot	重启
​		8. 小结
​		sudo 是临时获取管理员权限
​		sudo -s 是切换到管理员用户，一直使用管理员权限，需要谨慎操作。
​		exit 是退出当前用户
​		passwd 默认修改当前用户密码
​	用户相关操作
​		1. 创建用户
​		命令	说明
​		useradd	创建(添加)用户
​		useradd命令选项:
​		选项	说明
​		-m	自动创建用户主目录,主目录的名字就是用户名
​		-g	指定用户所属的用户组，默认不指定会自动创建一个同名的用户组
​		说明:
​		useradd 命令的使用需要使用管理员权限，前面需要加上 sudo
​		创建用户如果不指定用户组，默认会自动创建一个同名的用户组
​		查看用户是否创建成功，可以查看/etc/passwd这个文件
​		查看用户组是否创建成功，可以查看/etc/group这个文件
​		passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例:
​		第一个：用户名
​		第二个：密码占位符
​		第三个：uid, 用户id
​		第四个：gid, 用户所在组id
​		第五个：用户描述, 可选，
​		第六个：用户的主目录所在位置
​		第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型
​		group文件中的每项信息说明, 以laowang:x:1001:为例:
​		第一个：用户组名
​		第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的
​		第三个：组id
​		id命令查看用户信息:
​		命令	说明
​		id	查看用户信息
​		id命令效果图: id命令
​		每项信息说明:
​		uid=1001(laowang) gid=1001(laowang) 组=1001(laowang)
​		第一个: uid 表示用户id
​		第二个: gid 表示用户组id
​		第三个: 组 表示用户所在的用户组
​		2. 设置密码
​		给其它用户设置密码，需要使用: sudo passwd 用户名
​		设置密码效果图: useradd命令
​		3. 切换用户
​		命令	说明
​		su	切换用户
​		语法格式: su - 用户名
​		切换用户效果图:
​		su命令
​		在laowang用户使用sudo -s效果图:
​		sudo -s命令
​		解决办法:
​		给laowang用户设置一个sudo附加组， 需要使用usermod修改用户信息
​		4. 修改用户信息
​		命令	说明
​		usermod	修改用户信息
​		usermod选项:
​		命令	说明
​		-G	设置一个附加组
​		-g	修改用户组
​		usermod命令效果图:
​		usermod命令
​		设置附加组sudo以后，在sudo -s切换到管理员用户效果图:
​		usermod命令
​		5. 扩展: 删除附加组
​		命令	说明
​		gpasswd	添加和删除附加组信息
​		gpasswd命令选项:
​		选项	说明
​		-a 用户名	给用户添加附加组
​		-d 用户名	给用户删除附加组
​		删除附加组效果图:
​		usermod命令
​		删除附加组再次使用 sudo -s 效果图:
​		usermod命令
​		5. 删除用户
​		命令	说明
​		userdel	删除用户
​		userdel命令选项:
​		选项	说明
​		-r 用户名	删除用户主目录，必须要设置，否则用户主目录不会删除
​		删除用户效果图:
​		userdel命令
​		id查看用户信息效果图:
​		userdel命令
​		查看group文件信息效果图:
​		userdel命令
​		说明:
​		删除用户，默认同名的用户组也会被删除
​		6. 小结
​		创建用户命令格式: sudo useradd -m 用户名, 默认会创建一个同名的用户组。
​		查看用户信息使用 id 命令或者 /etc/passwd文件
​		查看用户组信息使用 /etc/group文件
​		给用户设置密码使用 sudo passwd 用户名
​		切换用户使用 su - 用户名
​		设置附加组使用 sudo usermod -G 组名 用户名
​		删除用户使用 sudo userdel -r 用户名，默认会删除同名的用户组。
​	用户组相关操作
​		1. 创建用户组
​		命令	说明
​		groupadd	创建(添加)用户组
​		创建用户组效果图:
​		groupadd命令
​		2. 创建用户并指定用户组
​		创建用户并指定用户组效果图:
​		groupadd命令
​		3. 修改用户组
​		修改用户组效果图:
​		usermod命令
​		4. 删除用户组
​		命令	说明
​		groupdel	删除用户组
​		删除用户组效果图:
​		groupdel命令
​		说明:
​		如果用户组下面有用户先删除用户在删除用户组
​		5. 小结
​		创建用户组使用: sudo groupadd 用户组名
​		创建用户并指定用户组使用: sudo useradd -m -g 用户组 用户名
​		修改用户组使用: sudo usermod -g 用户组 用户名
​		删除用户组使用: sudo groupdel 用户组名
​	远程登录、远程拷贝命令
​		远程登录、远程拷贝命令
​		学习目标
​		能够写出远程拷贝、远程登录命令
​		1. 远程登录、远程拷贝命令的介绍
​		命令	说明
​		ssh	远程登录
​		scp	远程拷贝
​		2. ssh命令的使用
​		ssh是专门为远程登录提供的一个安全性协议，常用于远程登录，想要使用ssh服务，需要安装相应的服务端和客户端软件，当软件安装成功以后就可以使用ssh命令了，以后可以通过远程登录之间操作远程的服务器。
​		远程登录效果图:
​		ssh命令
​		软件安装步骤:
​		假如Ubuntu作为服务端,需要安装ssh服务端软件. 执行命令: sudo apt-get install openssh-server
​		客户端电脑如果是 macOS 系统则不需要安装 ssh 客户端软件，默认已经安装过了，直接可以使用 ssh 命令
​		客户端电脑如果是Windows系统则需要安装OpenSSH for Windows这个软件
​		ssh命令格式:
​		ssh 用户名@ip地址
​		ssh命令效果图:
​		ssh命令
​		说明:
​		在一台电脑上可以安装安装ssh客户端和ssh服务端软件
​		在Ubuntu安装ssh客户端命令: sudo apt-get install openssh-client
​		3. scp命令的使用
​		scp是基于ssh进行远程文件拷贝的命令，也就是说需要保证服务端和客户端电脑安装了相应的ssh软件，以后可以把我们写代码远程拷贝到服务器。
​		scp命令格式:
​		远程拷贝文件
​		scp 本地文件 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径
​		scp 远程服务器用户名@远程服务器ip地址:远程服务器文件 指定拷贝到本地电脑的路径
​		远程拷贝目标
​		scp -r 本地目录 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径
​		scp -r 远程服务器用户名@远程服务器ip地址:远程服务器目录 指定拷贝到本地电脑的路径
​		-r 表示递归拷贝整个目录
​		本地文件远程拷贝到服务器效果图:
​		scp命令
​		服务器文件远程拷贝到本地效果图:
​		scp命令
​		本地目录远程拷贝到服务器效果图:
​		scp命令
​		服务器目录远程拷贝到本地效果图:
​		scp命令
​		4. FileZilla软件的使用
​		FileZilla 是一个免费开源的FTP软件, 使用可视化方式进行上传和下载文件。以后可以通过 FileZilla 来代替 scp 命令
​		FileZilla使用效果图:
​		FileZilla FileZilla FileZilla FileZilla
​		5. 小结
​		ssh命令是远程登录主机电脑，相当于直接操作的是远程电脑。
​		scp命令是可以完成远程拷贝操作，注意:拷贝文件夹需要加-r选项。
​		大量的文件上传和下载可以通过可视化工具FileZilla来完成。
​	编辑器 vim
​		学习目标
​		能够说出vim的三种工作模式
​		能够说出vim对应复制和粘贴命令
​		1. vim 的介绍
​		vim 是一款功能强大的文本编辑器，也是早年 Vi 编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。
​		2. vim 的工作模式
​		命令模式
​		编辑模式
​		末行模式
​		说明:
​		vim 打开文件进入的是命令模式
​		工作模式效果图:
​		ssh命令
​		注意点:
​		编辑模式和末行模式之间不能直接进行切换，都需要通过命令模式来完成。
​		3. vim 的末行模式命令
​		:w 保存
​		:wq 保存退出
​		:x 保存退出
​		:q! 强制退出
​		4. vim 的常用命令
​		命令	说明
​		yy	复制光标所在行
​		p	粘贴
​		dd	删除/剪切当前行
​		V	按行选中
​		u	撤销
​		ctr+r	反撤销
​		>>	往右缩进
​		<<	往左缩进
​		:/搜索的内容	搜索指定内容
​		:%s/要替换的内容/替换后的内容/g	全局替换
​		:开始行数,结束行数s/要替换的内容/替换后的内容	局部替换
​		.	重复上一次命令操作
​		G	回到最后一行
​		gg	回到第一行
​		数字+G	回到指定行
​		shift+6	回到当前行的行首
​		shift+4	回到当前行的行末
​		ctr+f	下一屏
​		ctr+b	上一屏
​		5. 小结
​		vim 是一款功能强大的命令文本编辑器，可以对远程服务器的代码直接进行修改，这样操作起来更加快速和方便。
​	软件安装
​		学习目标
​		能够使用apt-get命令安装软件
​		1. 软件安装的介绍
​		Ubuntu软件安装有两种方式:
​		离线安装(deb文件格式安装）
​		在线安装(apt-get方式安装)
​		2. deb文件格式安装
​		是 Ubuntu 的安装包格式，可以使用 dpkg 命令进行软件的安装和卸载。
​		命令	说明
​		dpkg	安装和卸载deb安装包
​		dpkg命令选项:
​		选项	说明
​		-i	离线安装deb安装包
​		dpkg命令效果图:
​		dpkg命令
​		3. apt-get方式安装
​		是在线安装deb软件包的命令，主要用于在线从互联网的软件仓库中搜索、安装、升级、卸载软件。
​		在线安装软件命令格式:
​		sudo apt–get install 安装包 , 表示在线安装deb安装包
​		4. 更改镜像源
​		因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器。
​		镜像源说明:
​		镜像源就是下载软件来源的服务器。
​		镜像源效果图:
​		镜像源命令
​		更改镜像源的方式:
​		可视化方式更改镜像源
​		手动方式更改镜像源
​	软件卸载
​		学习目标
​		能够使用apt-get命令卸载软件
​		1. 软件卸载的介绍
​		Ubuntu软件卸载有两种方式:
​		离线安装包的卸载(deb 文件格式卸载）
​		在线安装包的卸载(apt-get 方式卸载)
​		2. deb 文件格式卸载
​		命令格式:
​		sudo dpkg –r 安装包名
​		-r 选项表示安装的卸载
​		dpkg 卸载效果图:
​		dpkg命令
​		3. apt-get 方式卸载
​		命令格式:
​		sudo apt-get remove 安装包名
​		apt-get 卸载效果图:
​		apt-get命令
​		4. 小结
​		Ubuntu 操作系统卸载软件有两种方式:
​		dpkg -r 安装包 命令
​		apt-get remove 安装包 命令卸载

Linux命令总结
	一、Linux管理和目录命令
		pwd 显示当前路径地址
		cd 改变当前用户的目录
		ls 查看当前文件夹下的文件
		mkdir  新建文件夹目录
		rmdir  删除文件夹目录
		touch  新建文件
		cat    查看文本内容
		mv     移动
		cp	复制
		rm	删除
		grep	字符串查找
	二、线上查找
		man 查看当前或者一个命令的使用方法
		locate 根据一个关键字或者关键词定位
		whatis 查看某个命令的含义
	三、文件阅读命令
		head	从头开始查看
		tail 	从尾开始查看
		more	分页查看
	四、文件或目录的压缩和解压缩
		tar 
		gzip
		bizip2
		gunzip
		bunzip
	五、权限管理
		chmod	修改权限
		useradd	用户添加
		userdel 用户删除
		su	切换用户
		passwd	修改密码
		chgrp	修改文件所在组
		chown	用来修改文件的所有者
	六、文件的定位和查找
		which  定位
		whereis	查找
	七、磁盘操作
		df 查看文件系统使用情况
		du 查看文件磁盘占用情况
	八、系统命令
		reboot重启
		shutdown 关机
		halt	关机
		ps	进程
		toop	进程
		date	日期
		cal	日历
		exit	退出
		kill	结束进程
	九、网络
		ipconfig 显示网络状态
		ping	监测主机
		netstat	知道整个linux系统的网络情况或显示网络状态

Linux刷题
	1、查找文件
		find /目录 -name filename.txt
		根据名称查找/目录下的filename.txt文件

Shell

Windows
	# 关机、重启、注销、休眠、定时
​		关机：shutdown /s
​		重启：shutdown /r
​		注销：shutdown /l
​		休眠：shutdown /h /f
​		取消关机：shutdown /a
​		定时关机：shutdown /s /t 3600（3600 秒后关机）
	# 目录操作
​		切换目录，进入指定文件夹：
​		切换磁盘：d:（进入 d 盘）
​		切换磁盘和目录：cd /d d:/test（进入 d 盘 test 文件夹）
​		进入文件夹：cd \test1\test2（进入 test2 文件夹）
​		返回根目录：cd \
​		回到上级目录：cd ..
​		新建文件夹：md test
​		显示目录内容：
​		显示目录中文件列表：dir
​		显示目录结构：tree d:\test（d 盘 test 目录）
​		显示当前目录位置：cd
​		显示指定磁盘的当前目录位置：cd d:
	# 网络操作
​		延迟和丢包率：ping ip/域名
​		Ping 测试 5 次：ping ip/域名 -n 5
​		清除本地 DNS 缓存：ipconfig /flushdns
​		路由追踪：tracert ip/域名
	# 进程/服务操作
​		进程管理：
​		显示当前正在运行的进程：tasklist
​		运行程序或命令：start 程序名
​		结束进程，按名称：taskkill /im notepad.exe（关闭记事本）
​		结束进程，按 PID：taskkill /pid 1234（关闭 PID 为 1234 的进程）
​		服务管理：
​		显示当前正在运行的服务：net start
​		启动指定服务：net start 服务名
​		停止指定服务：net stop 服务名
​		保存为 .bat 可执行文件
​		我们可以将常用的命令输入记事本中，并保存为后缀为 .bat 的可执行文件。
​		以后只要双击该文件即可执行指定命令；将文件放入系统【启动】目录中，可以实现开机自动运行。
​	以下40个非常实用的Windows系统命令大全，在WinXP、Win7、Windows server均可使用：
​		cmd------CMD命令提示符
​		MSConfig------系统配置实用程序
​		regedit------注册表编辑器
​		notepad------打开记事本
​		calc------启动计算器
​		mstsc------远程桌面连接
​		services.msc------系统服务
​		gpedit.msc------组策略
​		shutdown------60秒倒计时关机命令
​		Nslookup-------IP地址侦测器
​		explorer------打开资源管理器
​		chkdsk.exe------Chkdsk磁盘检查
​		dcomcnfg------打开系统组件服务
​		devmgmt.msc------设备管理器
​		cleanmgr------垃圾整理
​		compmgmt.msc------计算机管理
​		secpol.msc------本地安全策略
​		netstat -an------(TC)命令检查接口
​		taskmgr------任务管理器
​		mmc------打开控制台
​		logoff------注销命令
​		lusrmgr.msc------本机用户和组
​		dvdplay------DVD播放器
​		diskmgmt.msc------磁盘管理实用程序
​		dxdiag------检查DirectX信息
​		perfmon.msc------计算机性能检测程序
​		winver------检测Windows版本
​		write------写字板
​		wiaacmgr------扫描仪和照相机向导
​		mspaint------画图板
​		magnify------放大镜实用程序
​		utilman------辅助工具管理器
​		osk------打开屏幕键盘
​		odbcad32------ODBC数据源管理器
​		Sndvol32或Sndvol------音量控制程序
​		sfc.exe------系统文件检查器
​		sfc /scannow------Windows文件保护
​		eventvwr------事件查看器
​		cliconfg------SQL Server客户端网络实用程序
​		certmgr.msc------证书管理实用程序
​		使用 Win键+其他键组合：
​		Win键：打开“开始”菜单
​		Win键+E：打开我的电脑
​		Win键+R：打开运行对话框
​		Win键+D：显示桌面
​		Win键+M：最小化所有窗口
​		Win键+X：Windows移动中心，调节音量，屏幕亮度
​		Win键+Home：除了正在选择的窗口，其他窗口最小化
​		Win键+PAUSE BREAK：打开“系统属性”对话框
​		Win键+【+/-】：打开Windows放大、缩小功能
​		Win键+Pause：显示系统属性对话框
​		Win键+TAB：Aero三维效果切换程序
​		Win键+数字键：让位于任务栏上的程序打开（数字为序号）
​		Win键+P：选择一个演示文稿显示模式，可以用来关闭屏幕
​		Win键+L：锁定计算机，需要输入密码或者选择其他用户
​		Win键+T：多次按可以在多个程序间顺序切换
​		Win键+F：计算机搜索，可以搜索计算机里面所有文件
​		Win键+【←/→】：在屏幕左/右半个屏幕最大化
​		Win键+【↑/↓】：最大化/最小化



常见题目
	1. 什么是性能测试?
		概念：性能测试是模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行的测试。
		说明：
		    1). 峰值：客户指定指标数值或场景需求数值，如：CPU使用率80%以内、登录3秒、内存空间40%等等
		    2). 负载：用户(一个或多个)向服务器发送请求，负载测试我们1.2节会讲解
	2. 性能测试与功能测试的焦点?
		功能测试：验证软件系统操作功能是否符合产品功能需求规格，主要焦点在功能（正向、逆向）；
		性能测试：验证软件系统是否满足业务需求场景，主要焦点是业务场景的满足度（时间、空间）；
		说明：
		    时间：软件的响应时间...
		    空间：服务器的磁盘读写数率、CPU 使用率、内存空闲率...
	3. 性能测试与功能测试的关系?
		功能测试和性能测试是相辅相成的，对于一款优秀的软件产品来讲，它们是测试工作中不可或缺的两个重要环节；



星环科技测开实习生面经

1.自我介绍

2.后续的规划和实习时间

3.TCP三次握手和四次挥手

4.Linux查看资源使用情况和网络带宽（没答出来）

5.有用linux抓过包吗（没有）

6.docker的平台？

7.webservice接口有用过吗？（没有）

8.Mysql隔离级别？MVCC机制实现原理？（不会）

9.通过mysql做过哪些工作？

10.写过python的代码量？（我简历写的熟练python，其实我写的不多，答了点其他的绕过去了）

11.之前项目中测试的大概流程？

12.测试用例的内容？

13.反问

14.到岗时间？



mysql
	知识要点：常用的SQL命令，子查询、连接查询、存储过程、触发器、游标等数据库概念和语法。

MySQL数据库的基本使用
	数据库说明
		学习目标
			能够知道数据库的作用
		1. 数据库的介绍
			数据库就是存储和管理数据的仓库，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。
		2. 数据库的分类
			非关系型数据库
			关系型数据库
			常用的关系型数据库:

Oracle
Microsoft SQL Server
MySQL
SQLite
非关系型数据库:

非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。

常用的非关系型数据库:

MongoDB
Redis
		3. 数据库的作用
			数据库的作用就是存储和管理数据的
		4. 数据库的特点
			持久化存储
读写速度极高
保证数据的有效性
		5. 小结
			数据库就是存储和管理数据的一个仓库，是用来持久化存储和快速读取数据的。
			数据库可以分为关系型数据库和非关系型数据库
	关系型数据库管理系统
		1、关系型数据库管理系统介绍
			学习目标
				知道数据库和数据库管理系统的关系
			1. 关系型数据库管理系统的介绍
				数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件。
				关系型数据库管理系统可以分为:

关系型数据库服务端软件
关系型数据库客户端软件
			关系型数据库管理系统的效果图:
				

		2. SQL的介绍
			SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。
			SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。
			SQL语言主要分为：
				DQL：数据查询语言，用于对数据进行查询，如select
				DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete
				TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback
				DCL：数据控制语言，进行授权与权限回收，如grant、revoke
				DDL：数据定义语言，进行数据库、表的管理等，如create、drop
			说明:
				对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.
				SQL语言不区分大小写
		3. 小结
			关系型数据库管理系统是一个软件，它可以管理不同的数据库，想要对数据库进行操作安装对应的关系型数据库管理系统软件即可。
			SQL的作用是实现数据库客户端和数据库服务端之间的通信，好比是通信桥梁。
	MySQL数据库
		sudo apt-get install mysql-server
		查看MySQL服务状态:
			sudo service mysql status
		停止MySQL服务:
			sudo service mysql stop
		启动MySQL服务:
			sudo service mysql start
		重启MySQL服务:
			sudo service mysql restart
		配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf
		命令行客户端mysql的安装
			sudo apt-get install mysql-client
		mysql命令的使用帮助:
			mysql --help
		MySQL客户端连接MySQL服务端命令
			mysql -uroot -p
	数据类型和约束
		1. 数据类型
			使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。

常用数据类型如下:

整数：int，bit
小数：decimal
字符串：varchar,char
日期时间: date, time, datetime
枚举类型(enum)
数据类型说明:

decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.
char表示固定长度的字符串，如char(3)，如果填充'ab'时会补一个空格为'ab '，3表示字符数
varchar表示可变长度的字符串，如varchar(3)，填充'ab'时就会存储'ab'，3表示字符数
对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.
字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.
		2. 数据约束
			主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.
			非空 not null: 此字段不允许填写空值.
			惟一 unique: 此字段的值不允许重复.
			默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.
			外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.
		3. 数据类型附录表
			1. 整数类型
类型	字节大小	有符号范围(Signed)	无符号范围(Unsigned)
TINYINT	1	-128 ~ 127	0 ~ 255
SMALLINT	2	-32768 ~ 32767	0 ~ 65535
MEDIUMINT	3	-8388608 ~ 8388607	0 ~ 16777215
INT/INTEGER	4	-2147483648 ~2147483647	0 ~ 4294967295
BIGINT	8	-9223372036854775808 ~ 9223372036854775807	0 ~ 18446744073709551615

2. 字符串
   类型	说明	使用场景
   CHAR	固定长度，小型数据	身份证号、手机号、电话、密码
   VARCHAR	可变长度，小型数据	姓名、地址、品牌、型号
   TEXT	可变长度，字符个数大于 4000	存储小型文章或者新闻
   LONGTEXT	可变长度， 极大型文本数据	存储极大型文本数据
3. 时间类型
   类型	字节大小	示例
   DATE	4	'2020-01-01'
   TIME	3	'12:29:59'
   DATETIME	8	'2020-01-01 12:29:59'
   YEAR	1	'2017'
   TIMESTAMP	4	'1970-01-01 00:00:01' UTC ~ '2038-01-01 00:00:01' UTC
   图形化客户端Navicat
   	sqlyog
   命令行客户端MySQL的使用
   	登录or登出数据库:
   		登出(退出)数据库:
   			quit 或 exit 或 ctrl + d
   		登录数据库:
   		mysql -uroot -p
   		# 显示当前时间
   select now();
   	2. 数据库操作的SQL语句
   		查看所有数据库
   			show databases;
   		创建数据库
   			create database 数据库名 charset=utf8;
   			例：
   			create database python charset=utf8;
   		使用数据库
   			use 数据库名;
   		查看当前使用的数据库
   			select database();
   		删除数据库-慎重
   			drop database 数据库名;
   			例：
   			drop database python;
   	3. 表结构操作的SQL语句
   		查看当前数据库中所有表
   			show tables;
   		创建表
   			create table students(
    id int unsigned primary key auto_increment not null,
    name varchar(20) not null,
    age tinyint unsigned default 0,
    height decimal(5,2),
    gender enum('男','女','人妖','保密')
   );
   			create table 表名(
   字段名称 数据类型  可选的约束条件,
   column1 datatype contrai,
   ...
   );
   		修改表-添加字段
   			alter table 表名 add 列名 类型 约束;
   例：
   alter table students add birthday datetime;
   		修改表-修改字段类型
   			alter table 表名 modify 列名 类型 约束;
   例：
   alter table students modify birthday date not null;
   			说明:

modify: 只能修改字段类型或者约束，不能修改字段名
			修改表-修改字段名和字段类型
				alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
				说明:

change: 既能对字段重命名又能修改字段类型还能修改约束
			修改表-删除字段
				alter table 表名 drop 列名;
例：
alter table students drop birthday;
			查看创表SQL语句
				show create table 表名;
例：
show create table students;
			查看创库SQL语句
				show create database 数据库名;
例：
show create database mytest;
			删除表
				drop table 表名;
例：
drop table students;
		4. 表数据操作的SQL语句
			查询数据
				-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;
			添加数据
				-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
				说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值
			修改数据
				update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;
			删除数据
				delete from 表名 where 条件
例：
delete from students where id=5;
				问题:
				上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
				-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
				说明:
				逻辑删除，本质就是修改操作
		5. 小结
			登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件
	as和distinct关键字
		学习目标
			能够知道去除重复数据行的关键字
		1. as关键字
			使用 as 给字段起别名
			select id as 序号, name as 名字, gender as 性别 from students;
			可以通过 as 给表起别名

-- 如果是单表查询 可以省略表名
select id, name, gender from students;

-- 表名.字段名
select students.id,students.name,students.gender from students;

-- 可以通过 as 给表起别名 
select s.id,s.name,s.gender from students as s;
		2. distinct关键字
			distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
		as 关键字可以给表中字段 或者 表名起别名
		distinct 关键字可以去除重复数据行。
	where条件查询
		1. where条件查询的介绍
			where语句支持的运算符:

比较运算符
逻辑运算符
模糊查询
范围查询
空判断
			where条件查询语法格式如下:

select * from 表名 where 条件;
例：
select * from students where id = 1;
		2. 比较运算符查询
			等于: =
大于: >
大于等于: >=
小于: <
小于等于: <=
不等于: != 或 <>
			例1：查询编号大于3的学生:
select * from students where id > 3;

例2：查询编号不大于4的学生:
select * from students where id <= 4;

例3：查询姓名不是“黄蓉”的学生:
select * from students where name != '黄蓉';

例4：查询没被删除的学生:
select * from students where is_delete=0;
		3. 逻辑运算符查询
			and
or
not
			例1：查询编号大于3的女同学:

select * from students where id > 3 and gender=0;
例2：查询编号小于4或没被删除的学生:

select * from students where id < 4 or is_delete=0;
例3：查询年龄不在10岁到15岁之间的学生:

select * from students where not (age >= 10 and age <= 15);
			说明:
			多个条件判断想要作为一个整体，可以结合‘()’。
		4. 模糊查询
			like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
			例1：查询姓黄的学生:

select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:

select * from students where name like '黄_';
例3：查询姓黄或叫靖的学生:

select * from students where name like '黄%' or name like '%靖';
		5. 范围查询
			between .. and .. 表示在一个连续的范围内查询
in 表示在一个非连续的范围内查询
			例1：查询编号为3至8的学生:

select * from students where id between 3 and 8;
例2：查询编号不是3至8的男生:

select * from students where (not id between 3 and 8) and gender='男';
		6. 空判断查询
			判断为空使用: is null
判断非空使用: is not null
			例1：查询没有填写身高的学生:

select * from students where height is null;
			注意:

不能使用 where height = null 判断为空
不能使用 where height != null 判断非空
null 不等于 '' 空字符串
		7. 小结
			常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null
	排序
		1. 排序查询语法
			排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:

先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:

select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:

select * from students  order by age desc,height desc;
		排序使用 order by 关键字
		asc 表示升序
		desc 表示降序
	分页查询
		1. 分页查询的介绍
		2. 分页查询的语法
			select * from 表名 limit start,count
说明:

limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:

select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;
		3. 分页查询案例
			已知每页显示m条数据，求第n页显示的数据

提示: 关键是求每页的开始行索引

查询学生表，获取第n页数据的SQL语句:

select * from students limit (n-1)*m,m
		4. 小结
			使用 limit 关键字可以限制数据显示数量，通过 limit 关键可以完成分页查询
			limit 关键字后面的第一个参数是开始行索引(默认是0，不写就是0)，第二个参数是查询条数

MySQL数据库的条件查询
	聚合函数
		学习目标
			能够写出查询总行数的SQL语句
		1. 聚合函数的介绍
			聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。

常用的聚合函数:

count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值
		2. 求总行数
			-- 返回非NULL数据的总行数.
select count(height) from students; 
-- 返回总行数，包含null值记录;
select count(*) from students;
		3. 求最大值
			-- 查询女生的编号最大值
select max(id) from students where gender = 2;
		4. 求最小值
			-- 查询未删除的学生最小编号
select min(id) from students where is_delete = 0;
		5. 求和
			-- 查询男生的总身高
select sum(height) from students where gender = 1;
-- 平均身高
select sum(height) / count(*) from students where gender = 1;
		6. 求平均值
			-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
			说明
			ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。
		7. 聚合函数的特点
			聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。
		8. 小结
			count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值
	分组查询
		学习目标
			能够写出分组查询的SQL语句
		1. 分组查询介绍
			分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
		2. group by的使用
			group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
		3. group by + group_concat()的使用
			group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
		4. group by + 聚合函数的使用
			- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
		5. group by + having的使用
			having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
		6. group by + with rollup的使用
			with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
		7. 小结
			group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果
	连接查询-内连接
		学习目标
			能够写出内连接查询的SQL语句
		1. 连接查询的介绍
			连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。

连接查询可以分为:

内连接查询
左连接查询
右连接查询
自连接查询
		2. 内连接查询
			查询两个表中符合条件的共有记录
			内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;
			

		3. 小结
			内连接使用inner join .. on .., on 表示两个表的连接查询条件
			内连接根据连接查询条件取出两个表的 “交集”
	连接查询-左连接
		学习目标
			能够写出左连接查询的SQL语句
		1. 左连接查询
			以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充
			左连接查询效果图:
			左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;
		2. 小结
			左连接使用left join .. on .., on 表示两个表的连接查询条件
			左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。
	连接查询-右连接
		学习目标
			能够写出右连接查询的SQL语句
		1. 右连接查询
			以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充
			右连接查询效果图:
			右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;
		2. 小结
			右连接使用right join .. on .., on 表示两个表的连接查询条件
			右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。
	连接查询-自连接
		学习目标
			能够写出自连接查询的SQL语句
		1. 自连接查询
			左表和右表是同一个表，根据连接查询条件查询两个表中的数据。

区域表效果图

区域表

例1：查询省的名称为“山西省”的所有城市

区域表

创建areas表:

create table areas(
    id varchar(30) not null primary key, 
    title varchar(30), 
    pid varchar(30)
);
执行sql文件给areas表导入数据:

source areas.sql;
说明:

source 表示执行的sql文件
自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:

自连接查询必须对表起别名
		小结
			自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
			自连接就是一种特殊的连接方式，连接的表还是本身这张表
	子查询
		学习目标
			能够写出子查询的SQL语句
		1. 子查询的介绍
			在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.

主查询和子查询的关系:

子查询是嵌入到主查询中
子查询是辅助主查询的,要么充当条件,要么充当数据源
子查询是可以独立存在的语句,是一条完整的 select 语句
		2. 子查询的使用
			例1. 查询大于平均年龄的学生:

select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:

select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:

select * from students where (age, height) =  (select max(age), max(height) from students);

		3. 小结
			子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面
	数据库设计之三范式
		范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。
		第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。
		第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。
		第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
		E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。
		开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构
	外键SQL语句的编写
		学习目标
			能够写出删除外键约束的SQL语句
		1. 外键约束作用
			外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性
		2. 对于已经存在的字段添加外键约束
			alter table students add foreign key(cls_id) references classes(id);
			-- 为cls_id字段添加外键约束
		3. 在创建数据表时设置外键约束
			-- 创建学校表

create table school(
    id int not null primary key auto_increment, 
    name varchar(10)
);

-- 创建老师表
create table teacher(
    id int not null primary key auto_increment, 
    name varchar(10), 
    s_id int not null, 
    foreign key(s_id) references school(id)
);
		4. 删除外键约束
			-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称
show create table teacher;

-- 获取名称之后就可以根据名称来删除外键约束
alter table teacher drop foreign key 外键名;
		5. 小结
			添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);
			删除外键约束: alter table 表名 drop foreign key 外键名;
	演练-分组和聚合函数的组合使用
		学习目标
			能够写出分组和聚合函数组合使用的SQL语句
		1. 数据准备
			-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
			表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
		2. SQL语句演练
			查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;

MySQL数据库的高级使用
	将查询结果插入到其它表中
		

			-- 查询goods表中商品的分类信息

select cate_name from goods group by cate_name;

-- 将查询结果插入到good_cates表中
insert into good_cates(name) select cate_name from goods group by cate_name;

-- 添加移动设备分类信息
insert into good_cates(name) values('移动设备');
		想要完成表复制可以使用: insert into .. select .. SQL语句
	使用连接更新表中某个字段数据
		1. 更新goods表中的商品分类信息
			-- 查看goods表中的商品分类名称对应的商品分类id
select * from goods inner join good_cates on goods.cate_name = good_cates.name;

-- 把该语句中from 后的语句理解为一张虚表  
update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;
		连接更新表中数据使用: update .. join .. 语句
	创建表并给某个字段添加数据
		

			-- 查询品牌信息 

select brand_name from goods group by brand_name;

-- 通过create table ...select来创建数据表并且同时插入数据
-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值
create table good_brands (     
id int unsigned primary key auto_increment,     
name varchar(40) not null) select brand_name as name from goods group by brand_name;
			-- 将goods表中的品牌名称更改成品牌表中对应的品牌id
			update goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;
		create table .. select 列名 .. 表示创建表并插入数据
	修改goods表结构
		

			-- 查看表结构

desc goods;
-- 通过alter table语句修改表结构
alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;
		修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔
	PyMySQL的使用
		 Python程序操作MySQL数据库
			安装pymysql第三方包:

sudo pip3 install pymysql
		pymysql的使用:
			导入 pymysql 包

 import pymysql
创建连接对象

调用pymysql模块中的connect()函数来创建连接对象,代码如下:

 conn=connect(参数列表)

 * 参数host：连接的mysql主机，如果本机是'localhost'
 * 参数port：连接的mysql主机的端口，默认是3306
 * 参数user：连接的用户名
 * 参数password：连接的密码
 * 参数database：数据库的名称
 * 参数charset：通信采用的编码方式，推荐使用utf8
   连接对象操作说明:

关闭连接 conn.close()
提交数据 conn.commit()
撤销数据 conn.rollback()
获取游标对象

获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:

 # 调用连接对象的cursor()方法获取游标对象   

 cur =conn.cursor()
游标操作说明:

使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句
获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,'张三')
获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,'张三'),(2,'李四'))
关闭游标: cur.close(),表示和数据库操作完成
pymysql完成数据的查询操作

import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

# 查询 SQL 语句

sql = "select * from students;"

# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数

row_count = cursor.execute(sql)
print("SQL 语句执行影响的行数%d" % row_count)

# 取出结果集中一行数据,　例如:(1, '张三')

# print(cursor.fetchone())

# 取出结果集中的所有数据, 例如:((1, '张三'), (2, '李四'), (3, '王五'))

for line in cursor.fetchall():
    print(line)

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
pymysql完成对数据的增删改

import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

try:
    # 添加 SQL 语句
    # sql = "insert into students(name) values('刘璐'), ('王美丽');"
    # 删除 SQ L语句
    # sql = "delete from students where id = 5;"
    # 修改 SQL 语句
    sql = "update students set name = '王铁蛋' where id = 6;"
    # 执行 SQL 语句
    row_count = cursor.execute(sql)
    print("SQL 语句执行影响的行数%d" % row_count)
    # 提交数据到数据库
    conn.commit()
except Exception as e:
    # 回滚数据， 即撤销刚刚的SQL语句操作
    conn.rollback()

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
说明:

conn.commit() 表示将修改操作提交到数据库
conn.rollback() 表示回滚数据
防止SQL注入

什么是SQL注入?

用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。

如何防止SQL注入?

SQL语句参数化

SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作
将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数
防止SQL注入的示例代码:

from pymysql import connect

def main():

    find_name = input("请输入物品名称：")
    
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,user='root',password='mysql',database='jing_dong',charset='utf8')
    # 获得Cursor对象
    cs1 = conn.cursor()
    
    # 非安全的方式
    # 输入 ' or 1 = 1 or '   (单引号也要输入)
    # sql = "select * from goods where name='%s'" % find_name
    # print("""sql===>%s<====""" % sql)
    # # 执行select语句，并返回受影响的行数：查询所有数据
    # count = cs1.execute(sql)
    
    # 安全的方式
    # 构造参数列表
    params = [find_name]
    # 执行select语句，并返回受影响的行数：查询所有数据
    count = cs1.execute("select * from goods where name=%s", params)
    # 注意：
    # 如果要是有多个参数，需要进行参数化
    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可
    # %s 不需要带引号
    
    # 打印受影响的行数
    print(count)
    # 获取查询的结果
    # result = cs1.fetchone()
    result = cs1.fetchall()
    # 打印查询的结果
    print(result)
    # 关闭Cursor对象
    cs1.close()
    # 关闭Connection对象
    conn.close()

if __name__ == '__main__':
    main()
说明:

execute方法中的 %s 占位不需要带引号
			import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

try:
    # 添加 SQL 语句
    # sql = "insert into students(name) values('刘璐'), ('王美丽');"
    # 删除 SQ L语句
    # sql = "delete from students where id = 5;"
    # 修改 SQL 语句
    sql = "update students set name = '王铁蛋' where id = 6;"
    # 执行 SQL 语句
    row_count = cursor.execute(sql)
    print("SQL 语句执行影响的行数%d" % row_count)
    # 提交数据到数据库
    conn.commit()
except Exception as e:
    # 回滚数据， 即撤销刚刚的SQL语句操作
    conn.rollback()

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
		3. 小结
			导包

 import pymysql
创建连接对象

 pymysql.connect(参数列表)
获取游标对象

 cursor =conn.cursor()
执行SQL语句

 row_count = cursor.execute(sql)
获取查询结果集

 result = cursor.fetchall()
将修改操作提交到数据库

 conn.commit()
回滚数据

 conn.rollback()
关闭游标

 cursor.close()
关闭连接

 conn.close()
	事务
		学习目标
			能够知道事务的四大特性
		1. 事务的介绍
			事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
		2. 事务的四大特性
			原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
		3. 事务的使用
			在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
			-- 查看MySQL数据库支持的表的存储引擎
show engines;
		查看goods表的创表语句:
			-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
		开启事务:

begin;
或者
start transaction;
		4. 小结
			事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
	索引
		学习目标
			能够写出创建索引的SQL语句
		1. 索引的介绍
			索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
			应用场景:
			当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
		2. 索引的使用
			查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
		3. 案例-验证索引查询性能
			创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
		4. 联合索引
			联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
		5. 联合索引的最左原则
			在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
		6. MySQL中索引的优点和缺点和使用原则
			优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
		7. 小结
			索引是加快数据库的查询速度的一种手段
			创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
			删除索引使用: alter table 表名 drop index 索引名;

刷题



Linux命令总结
	一、Linux管理和目录命令
		pwd 显示当前路径地址
		cd 改变当前用户的目录
		ls 查看当前文件夹下的文件
		mkdir  新建文件夹目录
		rmdir  删除文件夹目录
		touch  新建文件
		cat    查看文本内容
		mv     移动
		cp	复制
		rm	删除
		grep	字符串查找
	二、线上查找
		man 查看当前或者一个命令的使用方法
		locate 根据一个关键字或者关键词定位
		whatis 查看某个命令的含义
	三、文件阅读命令
		head	从头开始查看
		tail 	从尾开始查看
		more	分页查看
	四、文件或目录的压缩和解压缩
		tar 
		gzip
		bizip2
		gunzip
		bunzip
	五、权限管理
		chmod	修改权限
		useradd	用户添加
		userdel 用户删除
		su	切换用户
		passwd	修改密码
		chgrp	修改文件所在组
		chown	用来修改文件的所有者
	六、文件的定位和查找
		which  定位
		whereis	查找
	七、磁盘操作
		df 查看文件系统使用情况
		du 查看文件磁盘占用情况
	八、系统命令
		reboot重启
		shutdown 关机
		halt	关机
		ps	进程
		toop	进程
		date	日期
		cal	日历
		exit	退出
		kill	结束进程
	九、网络
		ipconfig 显示网络状态
		ping	监测主机
		netstat	知道整个linux系统的网络情况或显示网络状态
Linux刷题
	1、查找文件
		find /目录 -name filename.txt
		根据名称查找/目录下的filename.txt文件



1）pwd：显示当前所在位置；

2）su：申请切换root用户，需要输入root用户密码（sudo su是当前用户暂时申请root权限，需要输入当前用户密码）；

3）grep：要搜索的字符串 要搜索的文件 --color ： 搜索命令，–color 代表高亮显示；

4）ps -ef || ps -aux：两者的区别是展示格式不同（System Ｖ风格和BSD风格）；

5）kill -9 [pid] ： 销毁进程（-9表示强制停止），先用ps查找进程，然后用kill掉；

6）find ：寻找；

7）tar -zcvf ：打包并压缩文件 ；tar -xvf 压缩文件 - C 解压的位置 : 解压压缩包；

8）free : 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存；

9）wget : 是从远程下载的工具 ； curl ；

10）top : 监控系统状况，比如CPU、内存的使用，显示系统上正在运行的进程 load average（系统负载，就是进程队列的长度）；

11）vmstat : 虚拟内存性能监控、CPU 监控。











# 计算机网络

一、网络 7 层架构(ISO/OSI协议参考模型)
	物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
	数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
	网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
	传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。
	会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
	表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
	应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。
	
	
	

二、TCP/IP 原理
	TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。
	

	1、应用层(Application Layer)
	    应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。
	2、传输层(Tramsport Layer-TCP/UDP)
	    传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
	3、网络层(Internet Layer)
	  网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP，Internet Protocol)。
	4、网络访问层(Network Access Layer)
	   网络访问层(Network Access Layer)在 TCP/IP ：是TCP/IP协议栈的最底层，它提供物理网络的接口，实现对复杂数据的发送和接收。网络访问层协议为网络接口、数据传输提供了对应的技术规范。网络访问层对应 OSI 七层网络模型的物理层和数据链路层。
	5、四层协议和对应的标准七层协议的关系如下图
	————————————————

三、TCP 三次握手/四次挥手
	1、三次握手
	SYN：同步序列编号（Synchronize Sequence Numbers）、seq：序号--sequence number、
ACK (Acknowledge character）即是确认字符  、ack number 确认序号
	第一次握手： 主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器主机 B，由 SYN=1 知道，A 要求建立联机；
	第二次握手： 主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包
	第三次握手： 主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认。
	

	2、四次挥手
	TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。
	关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u
	服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
	关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。
	客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
	————————————————
	主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到close 状态。
	为什么会有TIME_WAIT状态：
		确保有足够的时间让对方收到ACK包
		避免新旧连接混淆
	3、TCP/IP状态
		1、LISTENING（listening)
		FTP服务启动后首先处于侦听（LISTENING）状态。
		2、ESTABLISHED（established）
		建立连接。表示两台机器正在通信。
		3、CLOSE_WAIT
		对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT，此时我方要调用close()来使得连接正确关闭。
		4、TIME_WAIT
		我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。
		5、SYN_SENT
		SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED。

四、TCP 长连接与短连接
	1、长连接和短连接使用原因
	当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次挥手，所以说每个连接的建立都是需要资源消耗和时间消耗的。
	2、HTTP的长连接和短连接
	HTTP的长连接和短连接本质上是TCP长连接和短连接。
	在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
	而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
	Connection:keep-alive
	1
	在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
	3、TCP—长连接
	 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。
	连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；
	这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；
	 TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
	4、TCP—短连接
	 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；
	 连接→数据传输→关闭连接；
	5、应用场景
	 长连接： 多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。
	例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
	 短连接： 像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

五、HTTP原理
	 HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。
	1、地址解析
	如用客户端浏览器请求这个页面：http://www.lydms.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
	协议名： http
	主机名： www.lydms.com
	端口： 8080
	对象路径： /index.htm
	在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。
	2、封装 HTTP 请求数据包
	把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包
	3、封装成 TCP 包并建立连接
	封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）
	4、客户机发送请求命
	客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。
	5、服务器响应
	服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。
	6、服务器关闭 TCP 连接
	一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

六、HTTPS
	六、HTTPS
	HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：
	1、SSL/TLS之间的关系
	SSL 是英文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。
	为啥要发明 SSL 这个协议呢？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。
	到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
	很多人都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。
	2、建立连接获取证书
	SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
	3、证书验证
	Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
	4、数据加密和传输
	如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。
	

七、CDN 原理
	CND 一般包含分发服务系统、负载均衡系统和管理系统。
	1、分发服务系统
	其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。
	2、负载均衡系统
	负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。
	3、管理系统
	分为运营管理和网络管理子系统。网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。
	包括用户管理、产品管理、计费管理、统计分析等。

八、TCP/IP协议族
	TCP/IP只提供无连接、不可靠的服务。
	传输之前需要进行三次握手。
	IP的主要功能包括将上层数据(如TCP、UDP数据)或者同层的其它数据(如ICMP数据)封装到IP数据报中，将IP数据报传送到最终目的地；为了使数据能够在链路层上进行传输，对数据进行分段，确定数据报到达其它网络中的目的地的路径。
	1、应用层协议—文件传输服务(FTP)
	用来在计算机之间传输文件。
	实际Internet的FTP服务是一种匿名(anonymous)FTP服务，设置一个特殊的用户名-anonymous，供公众使用。
	匿名登录到FTP服务器后，其工作方式与常规FTP相同。通常处于安全目的，大多数匿名FTP服务器只允许下载，不允许上传文件。
	FTP在客户端到服务器建立2条TCP连接，一条是控制连接，主要用于传输命令和参数(端口21)；另一条是数据连接，主要用于传输文件(端口号20)。
	2、应用层协议—远程登录协议(Telnet)
	远程登录服务实在Telnet协议的支持下，将用户计算机和远程主机连接起来，在远程计算机上运行程序，用户输入的信息通过Telnet协议发送给远程主机，主机在TCP端口监听用户请求，并处理后，将结果通过Telnet协议返回给客户。客户再经过适当的转换显示在计算机屏幕上。因为使用Telnet命令进行远程登录，所有称为Telnet远程登录。
	由客户端软件、服务器软件以及Telnet通用协议三部分组成。
	3、应用层协议—电子邮件协议（SMTP)
	电子邮件(E-mail)利用计算机进行信息交换的电子媒体信件。
	基于客户端/服务器模式，有E-mail客户端软件、E-mail服务器、通信协议三部分组成。发送邮件，首先到达自己注册的邮件服务器主机，再在网络传输中经过多个计算机和路由中转到达目的地的邮件服务器主机，进入收件人的电子邮箱，最后邮件的接收者上网并启动电子邮件管理程序，会自动下载到自己计算机，完成接受邮件。
	SMTP：简单邮件传输协议
	MIME：Internet邮件扩充协议
	PEM：增强私密邮件保护协议
	POP：来保管用户未能及时取走的邮件，简单的纯文本协议，每次传输以正规E-mail为单位，不提供部分传输。
	4、传输层协议—TCP
	在IP提供的不可靠数据服务的基础上为应用程序提供一个可靠的、面向连接的、全双工的数据传输服务。TCP在源主机和目的之间建立和关闭连接操作是，均需要通过三次握手来确认建立和关闭是否成功。TCP虽然提供了一个可靠的数据传输服务，但是以牺牲通信量来实现的。
	TCP采用了重发技术： 发送数据时，启动定时器，在规定时间内没有收到确认信息，就重新发送数据包。
	5、传输层协议—UDP
	用户数据报协议是一种不可靠、无连接的协议，与同层面向连接的TCP相比，UDP是一种无连接的协议(无错误检测功能)。TCP有助于提供可靠的连接，UDP有助于提高传输的高速率性。不负责重新发送丢失的包，不对接收的数据进行排序，不消除重复的IP数据报，不负责建立和终止连接。(都是UDP应用程序负责的)
	TCP：交互式会话应用程序(FTP等)。
	UDP：自己进行错误检测、不需要检测错误(DNS、SNMP)。
	6、网际层协议—IP
	IP只提供无连接、不可靠的服务，把差错检测和流量控制之类的服务授权给了其他层的协议。
	IP的主要功能：
	将上层数据(TCP、UDP数据)或同层其他数据(ICMP数据)封装到IP数据报中；
	将IP数据报传送到最终目的地；
	为了使数据能够在链路层上进行传输，对数据进行分段；
	确定数据报到达其它网络中的目的地的路径。
	7、网际层协议—ICMP
	Internet控制信息协议，用于发送查错报文的协议。ICMP让IP更加稳固。也是利用IP来传送报文的。ping工具就是利用ICMP报文进行目标是否可达测试。
	5种差错报文：(源抑制、超时、目的不可达、重定向和要求分段)
	4种信息报文：回应请求、回应应答、地址屏蔽码请求和地址屏蔽码应答。
	8、网际层协议—ARP和RARP
	地址解析协议(ARP)和反地址解析协议(RARP)
	ARP的作用是将IP地址转为物理地址，RARP的作用是将物理地址转为IP地址。每台设备都有唯一的物理地址(通过网卡给出)，为了屏蔽底层协议及物理地址上的差异，IP协议又使用了IP地址。因此，在传输过程中，必须对IP地址和物理地址进行相互转换。
	9、网络接口层协议—以太网(Ethernet IEEE 802.3
	Ethernet IEEE 802.3：标准局域网，速度10Mps，传输介质为铜缆。
	Ethernet IEEE 802.3u：快速以太网，速度100Mps，传输介质为双绞线。
	Ethernet IEEE 802.3z：千兆以太网，速度1000Mps，传输介质为光纤或双绞线。
	10、网络接口层协议—令牌环网(Ethernet IEEE 802.5)
	1、只有拥有令牌才可以发送数据。
	2、发送数据时，需要捕获一个令牌。
	3、令牌不为空，需要等待。
	11、网络接口层协议—光纤分布式数据接口(FDDI)
	以光纤为传输介质。
	采用双环体系结构，两环上的信息反方向流动。双环中一环称为主环，另一个环称为次环。正常情况下，主环传输数据，次环处于空闲状态。
	双环设计的目的是提供高可靠性和稳定性。FDDI定义的传输介质有单模光纤和多模光纤两种。
	12、网络接口层协议—点对点协议(PPP)
	主要用于”拨号上网“这种广域连接模式。优点简单、具备用户验证功能、可以解决IP分配等。为各种主机、网桥和路由器之间简单连接的一种通用解决方案。
	利用以太网(Ethernet)资源在以太网上运行PPP来进行用户认证接入的方式成为PPPoE。是目前ADSL接入方式中最广泛的技术标准。
	ATM网络撒花姑娘运行PPP来管理用户再认证的方式成为PPPoA。
	PPPoA和PPPoE运行原理相同，不同的是运行环境的不同。
	13、其他—ADSL(非对称用户数据线)
	ADSL Modem上网拨号方式有3中，即专线方式(静态IP)、PPPoA和PPPoE。
	ADSL独享带宽，安全可靠。费用低廉,使用过去的电话线路，可以分离电话机和ADSL Modem(上网)。
	14、其他—IPv4和IPv6
	IPv4：32位二进制，能表示IP地址个数：2^32=40亿
	IPv6:128位二级制，能表示IP地址个数：2128=3.4*1038。

1、TCP和UDP的区别
	TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输；
	TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报；
	TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

2. TCP和UDP分别对应的常见应用层协议？
   2.1 TCP对应的应用层协议
    FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
    Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
    SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
    POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
    HTTP：从Web服务器传输超文本到本地浏览器的传送协议。
   2.2 UDP对应的应用层协议
    DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
    SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
    TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

   各协议对应的端口号

   摘自计算机网络(面试必备知识点)

3. TCP协议如何来保证传输的可靠性
   TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
   对于可靠性，TCP通过以下方式进行保证：
   数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据超时后会重发数据；
   对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
   丢弃重复数据：对于重复数据，能够丢弃重复数据；
   应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
   超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
   流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

4. 解释一下IP的定义，在哪个层上？主要作用是？TCP与UDP呢？
   IP是 Internet protocol 的缩写，是网络层的主要协议，作用是提供不可靠、无连接的数据包传输协传送。
    TCP是 Transmit Control Protocol（传输控制协议），在传输层，TCP提供一种面向连接的、可靠地字节流服务。
    UDP是 User Datagram Protocol（用户数据报协议），在传输层，UDP提供不可靠的传输控制数据服务。

5. IP地址的分类
   IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。
   　　
     每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：
    A类地址：以0开头，第一个字节范围：0~127；
    B类地址：以10开头，第一个字节范围：128~191；
    C类地址：以110开头，第一个字节范围：192~223；
    D类地址：以1110开头，第一个字节范围为224~239；
    E类地址：以1111开头，保留地址

6. 分别写出OSI、TCP/IP及五层协议的体系结构
   从上至下
   OSI：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
   TCP/IP：应用层、运输层、网际层、网络接口层；
   五层协议：应用层、运输层、网络层、数据链路层、物理层；

   6.1 OSI每一层对应的协议
   	体系	协议
   	物理层	RJ45、CLOCK、IEEE802.3 （中继器，集线器）
   	数据链路	PPP、FR、HDLC、VLAN、MAC（网桥，交换机）
   	网络层	IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、（路由器）
   	传输层	TCP、UDP、SPX
   	会话层	NFS、SQL、NETBIOS、RPC
   	表示层	JPEG、MPEG、ASII
   	应用层	FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
   	
   6.2 OSI每一层的作用
   	体系	作用
   	物理层	通过媒介传输比特,确定机械及电气规范（比特Bit）
   	数据链路层	将比特组装成帧和点到点的传递（帧Frame）
   	网络层	负责数据包从源到宿的传递和网际互连（包PackeT）
   	传输层	提供端到端的可靠报文传递和错误恢复（段Segment）
   	会话层	建立、管理和终止会话（会话协议数据单元SPDU）
   	表示层	对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
   	应用层	允许访问OSI环境的手段（应用协议数据单元APDU）
   	拓展：
   	网关的定义：一个链接两种不同协议簇的进程，为某一个特定的应用提供服务。
   	在TCP/IP协议簇中，IP层使用不可靠的服务，TCP提供可靠的服务，为了提供可靠到的服务，TCP采用了超时重传，发送和接收端到端的确认分组机制。
   	网桥是在数据链路层对网络进行互联的，路由器是在网络层对网络进行互联的。

7. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。典型的算法：DES
     由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。典型的算法：RSA

8. Get与POST的区别
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
   GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
   GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

9. ipconfig和netstat的作用？
   ipconfig显示当前TCP/IP配置的信息，帮助用户查看网络状况，可以看到很多网络信息，比如延迟，IP，主机信息，物理地址信息等。
   netstat主要用于提供系统的接口命令。可以使用相关参数打印出每一个接口的MTU、输入分组数、输入错误、冲突以及当前的输出队列长度。

10. 两台笔记本连起来后ping不同，可能是哪些原因？
    网线问题。确认网线连接是否正确，电脑之间连的线和电脑与USB之间连的线分正线、反线，是不同的。但是对于使用千兆网卡的除外，千兆位网卡有自动识别功课，既可以是正线也可以是反线。
    局域网设置问题。电脑互连是要设置的，看看是否安装了必要的网络协议，最重要的是，IP地址是否设置正确，互联的时候最好一台电脑为正，一台电脑为副，为主的设为网关。
    网卡驱动未正确安装
    防火墙设置有问题
    是否有什么软件阻止ping包

11. 运行net share返回结果是什么?
    显示本地计算机上所有共享资源相关信息。如果加上参数 ShareName ，则仅显示有关该共享的信息。

12. net use和net user 分别指什么？
     net use是对用户进行管理，如添加、删除网络使用用户等。
     net user 是对网络设备进行管理

13. 交换和路由的区别是什么，VLAN有什么特点？
    交换机是指转发和过滤帧，是交换机的工作，它在OSI参考模型的第二层。
    而路由器是指网络线路当中非直连的链路，它是路由器的工作，在OSI参考模型的第三层。
    交换和路由的区别很大。首先，交换是不需要IP的，而路由需要，因为IP就是第三层的协议，第二层需要的是MAC地址；再有，第二层可以做NAT、ACL、QOS等。
    VLAN是虚拟局域网络的英文缩写，它是一个纯二层的技术，它的特点有三个：控制广播，安全，灵活性和可扩展性。

14. 简单描述DNS域名系统的工作原理
    当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括3条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53.该应用一般不直接为用户使用，而是为其他应用服务，如HTTP,SMTP等，在其中需要完成主机名到IP地址的转换。
    ————————————————
    版权声明：本文为CSDN博主「lucky多多」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/weixin_41948075/article/details/88625382

15. 提供可靠数据流传输控制的是OSI的第几层？
    会话层

16. 在浏览器中输入www.baidu.com后执行的全部过程
    1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过该IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，通过TCP进行封装数据包，输入到网络层。
    2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口，然后使用IP层的IP地址查找目的端。
    3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过过哪个路径到达服务器。
    4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

17. ARP是地址解析协议，简单解释一下工作原理？
    首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
    当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
    当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
    源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。





![image-20230302085605768](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/image-20230302085605768-16777185673611.png)









```
http
	GET请求报文
		请求行
			---- 请求行 ----
GET / HTTP/1.1  # GET请求方式 请求资源路径 HTTP协议版本
		请求头
			---- 请求头 -----
Host: www.itcast.cn  # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Upgrade-Insecure-Requests: 1 # 让浏览器升级不安全请求，使用https请求
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36  # 用户代理，也就是客户端的名称
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 # 可接受的数据类型
Accept-Encoding: gzip, deflate # 可接受的压缩格式
Accept-Language: zh-CN,zh;q=0.9 #可接受的语言
Cookie: pgv_pvi=1246921728; # 登录用户的身份标识

		空行
			
---- 空行 ----
	POST请求报文
		请求行
			---- 请求行 ----
POST /xmweb?host=mail.itcast.cn&_t=1542884567319 HTTP/1.1 # POST请求方式 请求资源路径 HTTP协议版本
		请求头
			---- 请求头 ----
Host: mail.itcast.cn # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Content-Type: application/x-www-form-urlencoded  # 告诉服务端请求的数据类型
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 # 客户端的名称

		空行
			---- 空行 ----
		请求体
			---- 请求体 ----
username=hello&pass=hello # 请求参数
	HTTP请求格式(请求协议)
		
	HTTP响应格式（响应协议）
		

URL的组成
	URL的样子:
		https://news.163.com/18/1122/10/E178J2O4000189FH.html
	URL的组成部分:
		协议部分: https://、http://、ftp://
		域名部分: news.163.com
		资源路径部分: /18/1122/10/E178J2O4000189FH.html

```

![img](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/867021-20180322001733298-201433635-16777206451324.jpg)



![img](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/867021-20180322001744323-654009411-16777206363732.jpg)



# 如何系统自学软件测试，看这篇软件测试学习方法万字总结就够了

[![字节开发测试](https://pica.zhimg.com/v2-1d03059b2daf30b3c1a111bf64b9dbc6_l.jpg?source=172ae18b)](https://www.zhihu.com/people/destroy-79-67)

[字节开发测试](https://www.zhihu.com/people/destroy-79-67)



目录

收起

前言

下面是正文

但是在找工作之前，软件测试自学到底需要多长时间？

对于软件测试，想要去找工作，学好这几点去面试一个初级测试是没有问题的。

软件测试学习路线

一、测试与软件模型

二、测试用例设计

3 黑盒测试用例设计

三、软件测试类型

四、自动化测试

五、测试文档编写与缺陷管理

六、常用的测试工具

七、软件测试面试题总结

总结

## **前言**

之前发过一次回答，反响不错，所以我把这个又重新整理了一遍写成了文章。

我在自学软件测试的过程中个人整理了一些软件测试学习资料，什么课堂学习笔记、重点思维导图详情，作业练习等。
老规矩：想要的直接加我，到时候跟我说明来意就行。

## **下面是正文**

其实只按照学习进度来说，学到接口测试就可以了（不是）；因为到这里为止，基础的知识都掌握了，所有的系统也都可以做了。所以也可以去找工作。

但是学到当下用的技术很Low，企业开发项目的要求都是基于框架的，所以说，还是需要在学完框架之后再去找工作，会更容易一些。

## **但是在找工作之前，软件测试自学到底需要多长时间？**

以我自己为例，我用了5个月，算上找工作时间共6个月，入职薪资8k。

但我想说的是，并不是所有人都适合自学软件测试，自学是一条艰辛的自我斗争的路，能成功上岸靠的是坚持、坚持、再坚持！

而且，人跟人接收知识的速度是不一样的，这就是为什么别人学习有的只需要3-5个月，有的则需要1年的时间。
我是非科班转行学的，深知学软件测试的难度，所以从决定要自学的那一刻，其实就做好了准备，包括心理方面和其他方面。

心理方面主要就是要始终保持一颗终身学习的心，不能放弃。

![img](https://pic1.zhimg.com/80/v2-22c3b0701627c1e0d72ee868a1be49f8_720w.webp)

其他方面就都是一些客观因素，比如要付出半年多的时间以及要放弃一些娱乐和游戏的时间，还有就意味着自己这半年多没有收入，能否支撑自己坚持下去等等。我是辞职在家自学的，生活方面和家里人住在一起，所以基本上也没有什么负担。

通过这5个月的学习，我总结了自己的学习进度和经验，个人认为学习周期的长短主要取决于学习时间安排以及学习的量。

我综合了一些网上其他人自学时间案例，做出一个表格，列举大家自学的时间，以及多久面试，入职薪资等，希望大家能通过这个表格对自己有个清晰的认知，到底是属于哪种阶段，好对症下药。

*Ps：下面是我整理全网的软件测试自学资料，更多案例在最下方链接里，仅供参考。*

## 对于软件测试，想要去找工作，学好这几点去面试一个初级测试是没有问题的。

**第一步,测试基础。测试计划编写、设计测试用例、编写测试报告、编写BUG报告单、跟踪BUG修复情况、还需要良好的沟通能力、以及各种测试阶段所使用的测试方法、单元测试、 功能测试、集成测试、系统测试等。**

**第二步:学习脚本语言。python语言,当然python是-一门相对简单的计算机语言，考虑长远发展，需要了解C语言或者java。**

**第三步:计算机硬件知识。性能测试过程中硬件性能也是-个非常重要的指标，如CPU、 内存、I0、带宽等等。**

【面试理论知识】

1、你的测试职业发展是什么?

2、你认为测试人员需要具备哪些素质

3、你为什么能够做测试这一行

4、测试的目的是什么?

5、测试分为哪几个阶段?

6、单元测试的测试对象、目的、测试依据、测试方法?

7、怎样看待加班问题

8、结合你以前的学习和工作经验，你认为如何做好测试。

9、你为什么选择软件测试行业

10、根据你以前的工作或学习经验描述一下软件开发、测试过程，由哪些角色负责，你做什么

11、根据你的经验说说你对软件测试/质量保证的理解

12、软件测试的流程是什么?

13、你对SQA的职责和工作活动(如软件度量)的理解?

14、说说你对软件配置管理的理解

15、怎样写测试计划和测试用例

16、说说主流的软件工程思想(如CMM、CMMI、RUP,XP,PSP,TSP等)的大致情况及对他们的理解

17、你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度的保证软件的质量?

18、基于目前中国的国情，大多数公司的项目进度紧张、人员较少、需求文档根本没有或者很不规范，你认为在这种情况下怎样保证软件的质量?(大多数公司最想知道的就是在这种困难面前你该怎么保证软件的质量，因为这些公司一般就是这种情况--既不想投入过多又想保证质量)

19、一个测试工程师应该具备哪些素质和技能?

20、做好软件测试的一些关键点

21、软件测试员自身素质培养

22、为什要在一个团队中开展测试工作?

23、你所熟悉的软件测试类型有哪些?

24、你认为做好测试用例设计工作的关键是什么

25、请详细介绍一下各种测试类型的含义

26、测试计划工作的目的是什么?测试计划工作的内容都包括什么?其中哪些是最重要的?

27、您认为做好测试计划工作的关键是什么?

28、当开发人员说不是BUG时，你如何应付?

29、你自认为测试的优势在哪里?

30、什么是系统瓶颈?

31、文档测试主要包含什么内容?

32、功能测试用例需要详细到什么程度才是合格的?

33、配置和兼容性测试的区别是什么?

34、软件文档测试主要包含什么?

35、没有产品说明书和需求文档地情况下能够进行黑盒测试吗?

36、测试中的“杀虫剂怪事”是指什么?

37、在配置测试中，如何判断发现的缺陷是普通问题还是特定的配置问题?

38、为什么尽量不要让时间有富裕的员工去做一些测试?

39、完全测试程序是可能的吗?

40、软件测试的风险主要体现在哪里?

41、发现的缺陷越多，说明软件缺陷越多吗?

42、所有的软件缺陷都能修复吗?所有的软件缺陷都要修复吗?

43、软件测试人员就是QA吗?

44、如何减少测试人员跳槽带来的损失?

45、测试产品与测试项目的区别是什么?

46、和用户共同测试(UAT测试)的注意点有哪些?

47、如何编写提交给用户的测试报告?

48、测试工具在测试工作中是什么地位?

49、常见的测试用例设计方法都有哪些?请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。

50、您认为做好测试用例设计工作的关键是什么?

51、详细的描述一个测试活动完整的过程。

52、以往是否曾经从事过性能测试工作?请尽可能的详细描述您以往的性能测试工作的完整过程。

53、在您以往的工作中，一条软件缺陷(或者叫bug)记录都包含了哪些内容?如何提交高质量的软件缺陷(bug)记录?

54、您在从事性能测试工作时，是否使用过一些测试工具?如果有，请试述该工具的工作原理，并以一个具体的工作中的例子描述该工具是如何在实际工作中应用的。

55、您认为性能测试工作的目的是什么?做好性能测试工作的关键是什么?

\56. 请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。

57、是否有初始化或终止性错误？

58、测试计划工作的目的是什么？测试计划工作的内容都包括什么？其中哪些是最重要的？

59、您认为做好测试计划工作的关键是什么？

60、您所熟悉的测试用例设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。

61、您以往是否曾经从事过性能测试工作？如果有请尽可能的详细描述您以往的性能测试工作的完整过程。

62、系统测试是什么？需要考虑哪些方面？

63、怎样才能成为一个合格的软件测试工程师？

64、一名军官要求24名士兵站成6排，每排都是5人，士兵们全犯傻了。最后一名士兵终于想出了一个好办法。他是怎样安排的？

65、您认为做好测试计划工作的关键是什么？

66、软件测试的流程是什么？

## **软件测试学习路线**

**学习规划图：需要的可以点击最下方卡片自取**

![img](https://pic1.zhimg.com/80/v2-2bb80784ef7d3399ba3e66f2a4e8dab4_720w.webp)

## 一、测试与软件模型

软件开发生命周期模型指的是软件开发全过程、活动和任务的结构性框架。软件项目的开发包括：需求、设计、编码、测试、稳定、部署、维护等阶段。

常见的软件开发模型有瀑布模型、迭代开发、螺旋开发和敏捷开发。

**1 瀑布模型**

瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。瀑布式的主要有以下问题：

1. 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；
2. 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；
3. 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。

因此，瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。

**2 迭代开发模型**

迭代式开发是一种与传统的瀑布式开发相反的软件开发过程，具有更高的成功率和生产率。在迭代开发中，整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，逐步逐步的完成，故为迭代。每一次迭代都包括需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。迭代开发具有以下优点：

1. 降低风险。如果开发人员重复某个迭代，那么损失只是这一个开发有误的迭代的花费。
2. 适应需求变更。由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的。
3. 持续的测试与集成，降低后期的工作量与风险。

**3 螺旋开发模型**

螺旋开发，将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。“螺旋模型”刚开始规模很小，当项目被定义得更好、更稳定时，逐渐展开。 “螺旋模型”的核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。您轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到您满意的最终产品。 螺旋开发分为以下四个阶段：

1. 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；
2. 风险分析：分析评估所选方案，考虑如何识别和消除风险；
3. 实施工程：实施软件开发和验证；
4. 客户评估：评价开发工作，提出修正建议，制定下一步计划。

一个阶段首先是确定该阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建 造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。

**4 敏捷开发模型**

敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。

1. **个体和互动**重于流程和工具。
2. **可工作的软件**重于求全而完备的文档。
3. **客户协作**重于合同谈判。
4. **应对变化**重于遵循计划。

其中位于右边的内容虽然也有其价值，但是左边的内容最为重要。人员彼此信任，人少但是精干，可以面对面的沟通。

敏捷开发小组主要的工作方式可以归纳为：作为一个整体工作；按短迭代周期工作；每次迭代交付一些成果；关注业务优先；检查与调整。

最重要的因素恐怕是项目的规模。规模增长，面对面的沟通就愈加困难，因此敏捷方法更适用于较小的队伍，40、30、20、10人或者更少。

**5 四种模型比较**

传统的瀑布式开发，也就是从需求到设计，从设计到编码，从编码到测试，从测试到提交大概这样的流程，要求每一个开发阶段都要做到最好。特别是前期阶段，设计的越完美，提交后的成本损失就越少。

迭代式开发，不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间，最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。

螺旋开发，很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。

敏捷开发，相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。

适应性的方法集中在快速适应现实的变化。当项目的需求起了变化，团队应该迅速适应。这个团队可能很难确切描述未来将会如何变化。

**6 软件开发过程中的测试**

在前面介绍的软件开发过程中，测试都是一个重要的组成部分。尤其对于中大型项目，从项目开始指出就要制定测试计划、对需求进行测试、设计测试和测试用例、执行测试，最后对测试的结果进行总结和分析。软件缺陷发现得越早，修复软件缺陷所需的代价越小。

TDD（测试驱动开发）的思路就是通过测试推动整个开发的进行，开发代码之前，先编写测试代码。在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。并且，软件测试的活动贯穿整个软件开发生命周期的始终。

**7 软件测试的目的与原则**

测试的定义：使用人工或自动手段来运行或测定某个系统的过程，其目的在于检查它是否满足规定的需求或是弄清预期结果与实际结果之间的差别。

软件测试的目的：发现程序中的错误，保证软件产品的最终质量。

1. 测试是程序的执行过程，目的在于发现错误
2. 一个成功的测试用例在于发现至今未发现的错误
3. 一个成功的测试是发现了至今未发现的错误的测试
4. 确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。
5. 确保产品满足性能和效率的要求
6. 确保产品是健壮的和适应用户环境的

**软件测试的原则：**

1. 测试用例中一个必须部分是对预期输出或接口进行定义
2. 程序员应避免测试自己编写的程序
3. 编写软件的组织不应当测试自己编写的软件
4. 应当彻底检查每个测试的执行结果
5. 测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况
6. 检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”
7. 应避免测试用例用后即弃，除非软件本身就是个一次性的软件
8. 计划测试工作时不应默许假定不会发现错误
9. 程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比

**8 软件的可测性**

软件的可测性太差会导致测试的难度相当大，甚至无法测试。这种情况往往是由于极差的软件架构设计和极为不规范的软件开发工作导致的。

1. 紧耦合。不把大半个系统实例化就无法测试。
2. 弱内聚。这个类实现了太多功能，导致测试非常复杂。
3. 冗余。同一个方法在多处使用，每一处都得测。

好的软件架构应该是松耦合、高内聚的。提高软件的测试性的同时也提高了软件的可维护性和可管理性。

## 二、测试用例设计

测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。测试用例是执行的最小实体。简单地说，测试用例就是设计一个场景，使软件程序在这种场景下，必须能够正常运行并且达到程序所设计的执行结果。

**1 黑盒测试与白盒测试**

黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。白盒测试：已知产品的内部工作过程，可以进行测试证明每种内部操作是否符合设计规格要求，所有内部成分是否经过检查。

合理的测试策略是将这两种测试要素组合起来。我们可以通过使用特定的面向黑盒测试的测试用例设计方法，而后使用白盒测试方法对程序的逻辑结构进行检查以补充这些测试用例，借此来设计出一个相当严格的测试。

白盒测试方法有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖。黑盒测试方法有等价类划分、边界值分析、因果图分析、错误测试、状态图、场景法等。

**2 白盒测试用例设计**

白盒测试关注的是测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。完全的白盒测试是将程序中每条路径都执行到，然而对一个带有循环的程序来说，完全的路径测试并不切合实际。白盒测试的特点：依据软件设计说明书进行测试、对程序内部细节的严密检验、针对特定条件设计测试用例、对软件的逻辑路径进行覆盖测试。

**语句覆盖**是最起码的结构覆盖要求，语句覆盖要求设计足够多的测试用例，使得程序中每条语句至少被执行一次。可以很直观地从源代码得到测试用例，无须细分每条判定表达式。由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐式逻辑分支，是无法测试的。**（遗漏隐藏的逻辑分支）**

**判定覆盖**要求必须编写足够的测试用例，使得每一个判断都至少有一个为“真”和为“假”的输出结果。判定覆盖比语句覆盖要多几乎一倍的测试路径，当然也就具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。往往大部分的判定语句是由多个逻辑条件组合而成（如，判定语句中包含AND、OR、CASE），若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。**（遗漏组合判定中的某些条件取值）**

**条件覆盖**要求设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，**而不考虑所有的判定结果**。

**判定/条件覆盖**要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。判定/条件覆盖满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。判定/条件覆盖准则的缺点是**未考虑条件的组合情况**。

**多重条件覆盖**要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。多重条件覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。更改的判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身的所有可能结果也至少出现一次。并且每个条件都显示能单独影响判定结果。缺点是线性地增加了测试用例的数量。

**路径覆盖**要求设计足够的测试用例，覆盖程序中所有可能的路径。由于路径覆盖需要对所有可能的路径进行测试（包括循环、条件组合、分支选择等），那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。而在有些情况下，一些执行路径是不可能被执行的，这样不仅降低了测试效率，而且大量的测试结果的累积，也为排错带来麻烦。

## 3 黑盒测试用例设计

**（1）等价类划分**

等价类划分是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类分为有效等价类和无效等价类，其中，有效等价类是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合；而无效等价类是指对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合。设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。划分等价类有以下原则：

1. 在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0～100；则小于0和大于100的为无效等价类，0~100之间的为有效等价类。
2. 在输入条件规定了输入值的集合或者规定了"必须如何"的条件的情况下，可确立一个有效等价类和一个无效等价类。
3. 在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。
4. 在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。
5. 在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；
6. 在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。

在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：

1. 为每一个等价类规定一个唯一的编号；
2. 设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；
3. 设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。

**（2）边界值分析**

边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。

长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。

**（3）因果图**

因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。

等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。

**（4） 错误测试**

错误测试是基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。

如测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：

1. 输入的线性表为空表；
2. 表中只含有一个元素；
3. 输入表中所有元素已排好序；
4. 输入表已按逆序排好；
5. 输入表中部分或全部元素相同。

**4 测试用例设计综合策略**

Myers提出了使用各种测试方法的综合策略：

1. 在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。
2. 必要时用等价类划分方法补充一些测试用例。
3. 用错误推测法再追加一些测试用例。
4. 对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。
5. 如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。

测试用例的设计步骤：1)构造根据设计规格得出的基本功能测试用例；2)边界值测试用例；3)状态转换测试用例；4)错误猜测测试用例；5)异常测试用例；6)性能测试用例；7)压力测试用例。

## 三、软件测试类型

**单元测试**

单元测试并不是对整个程序进行测试，而是对构成程序的较小模块进行测试。单元测试减小了调试的难度（一旦某个错误被发现出来，我们就知道它在哪个具体的模块中）；单元测试提供了同时测试多个模块的可能，将并行工程引入软件测试中。

在为模块单元测试设计测试用例时，需要使用两种类型的信息：模块的规格说明和模块的源代码。规格说明一般都规定了模块的输入和输出参数以及模块的功能。单元测试总体上是面向白盒测试的，因此，单元测试的测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。

**集成测试**

自顶向下集成和自底向上集成

**功能测试**

功能测试的目的是为了暴露程序的错误以及与规格说明不一致之处，而不是为了证明程序符合其外部规格说明。

功能测试是一种黑盒测试，功能测试常用步骤有：根据需求来细分功能点，根据功能点派生测试需求，根据测试需求设计功能测试用例。

**系统测试**

**系统测试的目的是为了证明程序不能实现其目标**，系统测试的测试用例设计有以下14种类型：

1. 能力测试：是判断目标文档提及的每一项能力（或功能）是否都确实已经实现。
2. 容量测试：使程序经受大容量数据的检验。容量测试的目的是为了证明程序不能处理目标文档中规定的数据容量。
3. 强度测试：使程序承受高负载或强度的检验。所谓高强度是指在很短的时间间隔内达到的数据或操作的数量峰值。
4. 易用性测试：试图发现人为因素或易用性的问题。
5. 安全性测试：设计测试用例来突破程序安全检查的过程。举例来说，我们可以设计测试用例来规避操作系统的内存保护机制，破坏数据库管理系统的数据安全机制。
6. 性能测试：很多软件都有特定的性能或效率目标，这终特性描述为在特定负载和配置环境下程序的响应时间和吞吐率。
7. 存储测试：
8. 配置测试：
9. 兼容性测试。
10. 安装测试：有些类型的软件系统安装过程非常复杂，测试安装过程是系统测试中的一个重要部分。对于包含在软件包中的自动安装系统而言，这尤其重要。安装程序如果出现故障，会影响用户对软件的成功体验。
11. 可靠性测试：所有类型的测试都是为了提高软件的可靠性，但是如果软件的目标中包含了对可靠性的特别描述，就必须设计专门的可靠性测试。
12. 可恢复性测试：诸如操作系统、数据库管理系统和远程处理系统等软件通常都有可恢复性目标，说明系统如何从程序错误、硬件失效和数据错误中恢复过来。系统测试的一个目标是证明这些恢复机制不能够正确发挥作用。我们可以故意将程序错误置入某个系统中，判断系统是否可以从中恢复。
13. 适用性测试
14. 文档测试：检查用户文档的正确性。用户文档应成为审查的对象，检查其正确性和清晰性。在文档中描述的任何范例应编成测试用例，并提交给程序。

## 四、自动化测试

自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。

冒烟测试:就是在一个新版本出来的时候，将软件的全部功能过一遍，看有没有什么大问题。如果功能可以正常运行，不会影响测试进行，那么这个版本就可以真正开始测试了。如果功能有重大问题或影响测试进行，那么这个版本就是不合格的，不用进行进一步的测试。比如，拿到QQ的app新版本，登陆都登陆不上，那么这个版本肯定无法继续测下去。或者，游戏中新的模块出现，但是新的模块总是崩溃、卡死，测试进行不下去，那么冒烟的结果就是不合格的。

回归测试:就是以前版本中发现的bug在新的版本中验证是否存在且是否引发新的bug。

**1 自动化测试的优势**

1. **回归测试更方便、可靠**。由于回归测试的业务流程操作和测试用例是预先设计好的，预期结果也是完全在项目人员掌握之中的，将回归测试交给计算机自动运行，可以极大提高测试效率，缩短回归测试时间。
2. 可运行更多更繁琐的测试，且快速高效。
3. 可执行一些对于手工测试来说相当困难或根本做不到的测试。比如，对大量用户的并发测试等。
4. 具有**一致性和可重复性**的特点。
5. 自动化测试脚本完全具有**复用性**。由于自动化测试通常以脚本的方式实现，这样在不同的版本之间，就可能只需要做少量的维护甚至不做任何修改，实现在不同的测试版本中使用相同的测试脚本执行相同的测试用例。

**2 自动化测试的劣势**

1. 永远不可能完全取代手工测试。自动化测试无法做到手工测试的覆盖率，不是每个测试用例都适合转换成自动化测试用例的。
2. 无法保证测试的正确性。测试脚本本身也可能存在缺陷。
3. 手工测试能发现的缺陷远比自动化测试多。自动化测试几乎是无法发现新缺陷。
4. 自动化测试工具是死的，它本身没有任何想象力。
5. 自动化测试对测试工程师来说必须有一定的开发技术背景。

**3 引入自动化测试的时机**

1. 项目周期长，系统版本不断。主要在于回归测试。
2. 需求变更不频繁。
3. 系统中的测试对象基本可以正常识别，不存在大批量第三方控件。
4. 需要反复测试，如可靠性测试需要进行上千次的系统测试。

**4 何时避免展开自动化测试**

1. 项目周期短，需求变更频繁。项目周期短的情况下引入自动化测试，不但收不回成本，而且会延长产品的发布时间。需求频繁改变会使老功能的业务逻辑被修改，从而导致相应的测试脚本也需相应修改。
2. 软件版本还没稳定。
3. 多数对象无法识别以及脚本维护频繁与艰难。

**5 自动化测试用例设计**

在项目的测试过程中，测试工程师都会首先分析测试需求，产出测试计划后，编写和设计测试用例，设计开发测试脚本。

1. 自动化测试用例的范围往往是核心业务流程或者重复执行率较高的。并不需要覆盖所有的手工测试用例。
2. 自动化测试用例的选择一般以“正向”为主。正常情况即为“正向”，异常情况即为“反向”。功能自动化测试主要还是用于回归测试，回归测试的目的就是保证新增功能后老功能是否能够正常运作。
3. 手工测试用例可以不用回归原点，而自动化用例往往是必须的。所谓回归原点就是执行的测试用例最终需要恢复其在执行前的初始状态。比如添加用户功能，由于用户名是唯一的，第一次执行时没有问题，第二次执行时程序就会出现用户名重复而报错；这种情况下，就需要在自动化测试用例最后增加删除该用户的步骤。
4. 自动化测试用例与手工测试用例不同，不需要每个步骤都写预期结果。

## 五、测试文档编写与缺陷管理

测试文档包括：测试计划文档，测试设计规格文档，测试用例，软件缺陷报告，状态报告。

测试用例对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。测试用例一般包括验证测试用例和证伪测试用例；验证测试用例用于验证代码是否按照预期执行，得到预期结果；证伪测试用例验证代码是否对异常和错误条件进行了适当处理。

缺陷报告包括：问题/错误的简单描述，重现的环境配置要求，保证多次精确重复的特定输入，期望结果与实际结果的对比，优先级与严重性，对客户的影响等。

## 六、常用的测试工具

**1 功能测试UFT**

**UFT自动化测试的原理**

1. 封装真实被测对象并转化为UFT对象到对象库。
2. 对比对象库里的对象鉴别属性和运行时的真实被测对象的鉴别属性。
3. 对比结果一致，则说明对象成功匹配并可以继续对该真实被测对象进行后续操作；如果不一致则报错，提示对象无法识别。

**封装对象模型**

在UFT里的封装对象共分两个概念，Test Objects（测试对象，TO）和Runtime Objects（运行时对象，RO）。TO就是被被添加到对象库中的对象，RO就是被测试软件在运行实际所运行的对象。他们都是UFT封装的对象，TO是为了识别RO而存在的。

UFT识别对象通常先在对象库中添加测试对象，然后在被测软件运行的时候，根据脚本中调用的对象名称，在对象库中找到相应的测试对象，并根据这些对象的特征属性，在被测试软件中搜索相匹配的正在运行的对象，最后就可以对这些实际运行的测试对象进行操作。

GetTOProperty()
基本含义：获取对象库中某个对象的某个属性的值。
公式：ReturnValue = 对象.GetTOProperty("封装属性名")

SetTOProperty()
基本含义：设置对象库中某个对象的某个属性的值。
公式：对象.SetTOProperty "封装属性名" "封装属性值"
注：使用代码形式的修改对象属性属于临时性的，只在脚本运行时有效，一旦脚本运行结束，对象库里的属性值就会还原。

GetROProperty()
基本含义：获取实际运行时的某个对象的某个属性的值。
公式：ReturnValue = 对象.GetROProperty("封装属性名")
注：使用GetROProperty这个方法来动态获取实际运行时的一些确认信息，然后和所预期的测试数据做对比。如注册功能，在提交一些注册信息以后，一般都要到接下来的确认页面去验证一些信息，这就可以使用GetROProperty来动态获取实际运行时的一些确认信息。

**对象无法识别的解决办法**

1. 设置虚拟对象。不推荐，虚拟对象非常脆弱，难以维护；即使对象没有发生变化，但只要对象在界面是那个的方位发生变化，虚拟对象就会识别失败。
2. 使用相对坐标配合WSH去定位对象。
3. 使用DOM组建接口应用技术。只适用于Web项目。
4. 使用UFT自定义扩展SDK Customer来进行二次开发使UFT能够识别对象。难度大。
5. 开发提供专属插件。
6. 把无法识别的对象的一些方法封装到一个dll中并使用UFT调用。

**数据驱动与场景恢复**

数据驱动Data Table的应用：实现测试数据和脚本业务的分离。
场景恢复：场景恢复可以应对多种类型的错误并进行恢复操作。

**2 性能测试LoadRunner**

LoadRunner是一种适用于各种体系架构的自动负载测试工具，它能预测系统行为并优化系统性能。LoadRunner的测试对象是整个企业的系统，它通过模拟实际用户的操作行为和实时性能监测，来帮助测试人员更快地查找和发现问题。

1. 轻松创建虚拟用户。Virtual User Generator能够生成虚拟用于，以虚拟用户的方式模拟真实用户的业务操作行为。它先记录下业务流程，然后将其转化为测试脚本，并进行参数化操作（Data Wizard直接连接数据服务器获取数据）。利用虚拟用户可以在不同操作系统上同时产生成千上万用户访问，能极大的减少负载测试所需要的硬件和人力资源。
2. 创建真实负载。建立虚拟用户后，需要设定负载方案、业务流程组合和虚拟用户数量。用Controller能够很快地组织多用户测试方案。
3. 定位性能问题。LoadRunner内含一个实时检测器，在负载测试过程的任何时候都能观察到应用系统的运行性能。
4. 分析结果。一旦测试完毕，LoadRunner收集汇总所有的测试数据，并提供高级的分析和报告工具，一遍迅速找到性能问题并做出相应的调整。

## 七、软件测试面试题总结

**1. 给你一个网站，你如何测试？**

首先，查找需求说明、网站设计等相关文档，分析测试需求。

制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试；界面测试；性能测试；数据库测试；安全性测试；兼容性测试

**功能性测试**可以包括，但不限于以下几个方面：

1. 链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的出错信息返回。
2. 提交功能的测试。
3. 多媒体元素是否可以正确加载和显示。
4. 多语言支持是否能够正确显示选择的语言等。

**界面测试**可以包括但不限于一下几个方面：

1. 页面是否风格统一，美观
2. 页面布局是否合理，重点内容和热点内容是否突出
3. 控件是否正常使用
4. 对于必须但未安装的控件，是否提供自动下载并安装的功能
5. 文字检查

**性能测试**一般从以下两个方面考虑：压力测试；负载测试；强度测试

**数据库测试**要具体决定是否需要开展。数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。

**安全性测试：**

1. 基本的登录功能的检查
2. 是否存在溢出错误，导致系统崩溃或者权限泄露
3. 相关开发语言的常见安全性问题检查，例如SQL注入等
4. 如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者获取支持

**兼容性测试**，根据需求说明的内容，确定支持的平台组合：

1. 浏览器的兼容性；
2. 操作系统的兼容性；
3. 软件平台的兼容性；
4. 数据库的兼容性

开展测试，并记录缺陷。合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系（例如，需求变更、风险、配置、测试文档、缺陷报告、人力资源等内容）。

定期评审，对测试进行评估和总结，调整测试的内容。

**2. 在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。**

1. 建立测试计划，确定测试标准和测试范围
2. 设计典型场景的测试用例，覆盖常用业务流程和不常用的业务流程等
3. 根据测试用例，开发自动测试脚本和场景：

录制测试脚本：新建一个脚本（Web/HTML协议）；点击录制按钮，在弹出的对话框的URL中输入”about:blank”；在打开的浏览器中进行正常操作流程后，结束录制；调试脚本并保存，可能要注意到字符集的关联。

设置测试场景：针对性能设置测试场景，主要判断在正常情况下，系统的平均事务响应时间是否达标；针对压力负载设置测试场景，主要判断在长时间处于满负荷或者超出系统承载能力的条件下，系统是否会崩溃；执行测试，获取测试结果，分析测试结果。

**3. 一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?**

300个用户在一个客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。300个用户在一个客户端上，需要更大的带宽。

IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。

所有用户在一个客户端上，不必考虑分布式管理的问题；而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。

**4. 目前主要的测试用例设计方法是什么？**

白盒测试：逻辑覆盖、循环覆盖、基本路径覆盖

黑盒测试：边界值分析法、等价类划分、错误猜测法、因果图法、状态图法、测试大纲法、随机测试、场景法

**5. 软件的安全性应从哪几个方面去测试？**

软件安全性测试包括程序、数据库安全性测试。根据系统安全指标不同测试策略也不同。

用户认证安全的测试要考虑问题： 明确区分系统中不同用户权限 、系统中会不会出现用户冲突 、系统会不会因用户的权限的改变造成混乱 、用户登陆密码是否是可见、可 、是否可以通过绝对途径登陆系统（拷贝用户登陆后的链接直接进入系统）、用户退出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入系统 、系统网络安全的测试要考虑问题 、测试采取的防护措施是否正确装配好，有关系统的补丁是否打上 、模拟非授权攻击，看防护系统是否坚固 、采用成熟的网络漏洞检查工具检查系统相关漏洞（即用最专业的黑客攻击工具攻击试一下，现在最常用的是 NBSI 系列和 IPhacker IP ） 、采用各种木马检查工具检查系统木马情况 、采用各种防外挂工具检查系统各组程序的外挂漏洞

数据库安全考虑问题： 系统数据是否机密（比如对银行系统，这一点就特别重要，一般的网站就没有太高要求）、系统数据的完整性（我刚刚结束的企业实名核查服务系统中就曾存在数据的不完整，对于这个系统的功能实现有了障碍） 、系统数据可管理性 、系统数据的独立性 、系统数据可备份和恢复能力（数据备份是否完整，可否恢复，恢复是否可以完整）

**6. 简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试**

静态测试是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。

动态测试是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。

黑盒测试一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。

白盒测试根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。

α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。

β测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。

**7. 软件测试分为几个阶段，各阶段的测试策略和要求是什么?**

和开发过程相对应，测试过程会依次经历单元测试、集成测试、系统测试、验收测试四个主要阶段：

1. 单元测试：单元测试是针对软件设计的最小单位––程序模块甚至代码段进行正确性检验的测试工作，通常由开发人员进行。
2. 集成测试：集成测试是将模块按照设计要求组装起来进行测试，主要目的是发现与接口有关的问题。由于在产品提交到测试部门前，产品开发小组都要进行联合调试，因此在大部分企业中集成测试是由开发人员来完成的。
3. 系统测试：系统测试是在集成测试通过后进行的，目的是充分运行系统，验证各子系统是否都能正常工作并完成设计的要求。它主要由测试部门进行，是测试部门最大最重要的一个测试，对产品的质量有重大的影响。
4. 验收测试：验收测试以需求阶段的《需求规格说明书》为验收标准，测试时要求模拟实际用户的运行环境。对于实际项目可以和客户共同进行，对于产品来说就是最后一次的系统测试。测试内容为对功能模块的全面测试，尤其要进行文档测试。
5. 单元测试测试策略：
6. 自顶向下的单元测试策略：比孤立单元测试的成本高很多，不是单元测试的一个好的选择。
7. 自底向上的单元测试策略：比较合理的单元测试策略，但测试周期较长。
8. 集成测试的测试策略：
9. 大爆炸集成：适应于一个维护型项目或被测试系统较小
10. 自顶向下集成：适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。
11. 自底向上集成：适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。
12. 基于进度的集成
13. 优点：具有较高的并行度；能够有效缩短项目的开发进度。
14. 缺点：桩和驱动工作量较大；有些接口测试不充分；有些测试重复和浪费。

系统测试的测试策略：数据和数据库完整性测试；功能测试；用户界面测试；性能评测；负载测试；强度测试；容量测试；安全性和访问控制测试；故障转移和恢复测试；配置测试；安装测试；加密测试；可用性测试；版本验证测试；文档测试

**8. 软件测试各个阶段通常完成什么工作？各个阶段的结果文件是什么？包括什么内容？**

单元测试阶段：各独立单元模块在与系统地其他部分相隔离的情况下进行测试，单元测试针对每一个程序模块进行正确性校验，检查各个程序模块是否正确地实现了规定的功能。生成单元测试报告，提交缺陷报告。

集成测试阶段：集成测试是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动。该阶段生成集成测试报告，提交缺陷报告。

系统测试阶段：将通过确认测试的软件，作为整个给予计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行全面的功能覆盖。该阶段需要提交测试总结和缺陷报告。

**9. 一条软件缺陷（或者叫Bug）记录都包含了哪些内容？**

一条Bug记录最基本应包含：

1. bug编号；
2. bug严重级别，优先级；
3. bug产生的模块；
4. 首先要有bug摘要，阐述bug大体的内容；
5. bug对应的版本；
6. bug详细现象描述，包括一些截图、录像....等等；
7. bug出现时的测试环境，产生的条件即对应操作步骤；

**10. 黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！**

黑盒测试的优点有：比较简单，不需要了解程序内部的代码及实现；与软件的内部实现无关； 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；在做软件自动化测试时较为方便。

黑盒测试的缺点有：不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；自动化测试的复用性较低。

白盒测试的优点有：帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐 藏的问题。

白盒测试的缺点有：程序运行会有很多不同的路径，不可能测试所有的运行路径；测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；系统庞大时，测试开销会非常大。

**11. 如何测试一个纸杯？**

功能度：用水杯装水看漏不漏；水能不能被喝到
安全性：杯子有没有毒或细菌
可靠性：杯子从不同高度落下的损坏程度
可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用
兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等
易用性：杯子是否烫手、是否有防滑措施、是否方便饮用
用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述
疲劳测试：将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等
压力测试：用根针并在针上面不断加重量，看压强多大时会穿透

**12. 黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。**

1）等价类划分： 等价类是指某个输入域的子集合.在该子集合中,各个输入数据对于揭露程序中的错误都是等效的.并合理地假定:测试某等价类的代表值就等于对这一类其它值的测试.因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况:有效等价类和无效等价类.

2）边界值分析法：是对等价类划分方法的补充。测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误.

使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或刚刚小于边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据.

3）错误猜测法：基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法.

错误推测方法的基本思想: 列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例. 例如, 在单元测试时曾列出的许多在模块中常见的错误. 以前产品测试中曾经发现的错误等, 这些就是经验的总结. 还有, 输入数据和输出数据为0的情况. 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况. 可选择这些情况下的例子作为测试用例.

4）因果图方法：前面介绍的等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系, 相互组合等. 考虑输入条件之间的相互组合,可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多. 因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例. 这就需要利用因果图（逻辑模型）. 因果图方法最终生成的就是判定表. 它适合于检查程序输入条件的各种组合情况.

5）正交表分析法：可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。

6）场景分析方法：指根据用户场景来模拟用户的操作步骤，这个比较类似因果图，但是可能执行的深度和可行性更好。

7）状态图法：通过输入条件和系统需求说明得到被测系统的所有状态，通过输入条件和状态得出输出条件；通过输入条件、输出条件和状态得出被测系统的测试用例。

8）大纲法：大纲法是一种着眼于需求的方法，为了列出各种测试条件，就将需求转换为大纲的形式。大纲表示为树状结构，在根和每个叶子结点之间存在唯一的路径。大纲中的每条路径定义了一个特定的输入条件集合，用于定义测试用例。树中叶子的数目或大纲中的路径给出了测试所有功能所需测试用例的大致数量。

**13. 详细的描述一个测试活动完整的过程。（供参考，本答案主要是瀑布模型的做法）**

项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审，评审的内容包括：需求描述不清楚的地方和可能有明显冲突或者无法实现的功能的地方。项目经理通过综合开发人员，测试人员以及客户的意见，完成项目计划。然后SQA进入项目，开始进行统计和跟踪

开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或双方理解不同的地方。测试人员完成测试计划文档，测试计划包括的内容上面有描述。

测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。

测试用例完成后，测试和开发需要进行评审。

测试人员搭建环境

开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现BUG后提交给BugZilla。

开发提交第二个版本，包括Bug Fix以及增加了部分功能，测试人员进行测试。

重复上面的工作，一般是3-4个版本后BUG数量减少，达到出货的要求。

如果有客户反馈的问题，需要测试人员协助重现并重新测试。

**14. 说说你对集成测试中自顶向下集成和自底向上集成两个策略的理解，要谈出它们各自的优缺点和主要适应于哪种类型测试**

**自顶向下集成**

1. 优点：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。
2. 缺点：柱的开发量大；底层验证被推迟；底层组件测试不充分。
3. 适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。
4. **自底向上集成**
5. 优点：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。
6. 缺点：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。
7. 适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。

**15. 设计测试用例时应该考虑哪些方面，即不同的测试用例针对那些方面进行测试？**

设计测试用例时需要注意的是，除了对整体流程及功能注意外，还要注意强度测试、性能测试、压力测试、边界值测试、稳定性测试、安全性测试等多方面。（测试用例需要考虑的四个基本要素是输入、输出、操作和测试环境；另外，测试用例需要考虑的是测试类型（功能、性能、安全……），这部分可以参照TP做答。此外，还需要考虑用例的重要性和优先级）

**16. 在windows下保存一个文本文件时会弹出保存对话框，如果为文件名建立测试用例，等价类应该怎样划分？**

单字节，如A；双字节， AA、我我；特殊字符 /‘。‘；、=-等；保留字，如com；文件格式为8.3格式的；文件名格式为非8.3格式的；/,,*等九个特殊字符。

假设有一个文本框要求输入10个字符的邮政编码，对于该文本框应该怎样划分等价类？

特殊字符，如10个*或￥；英文字母，如ABCDefghik；小于十个字符，如123；大于十个字符，如11；数字和其他混合，如123AAAAAAA；空字符；保留字符

**17. 单元测试、集成测试、系统测试的侧重点是什么？**

1. 单元测试针对的是软件设计的最小单元--程序模块（面向过程中是函数、过程；面向对象中是类。）,进行正确性检验的测试工作,在于发现每个程序模块内部可能存在的差错.一般有两个步骤:人工静态检查\动态执行跟踪
2. 集成测试针对的是通过了单元测试的各个模块所集成起来的组件进行检验,其主要内容是各个单元模块之间的接口,以及各个模块集成后所实现的功能.
3. 系统测试针对的是集成好的软件系统，作为整个计算机系统的一个元素,与计算机硬件\外设\某些支持软件\数据和人员等其他系统元素结合在一起,要在实际的运行环境中,对计算机系统进行一系列的集成测试和确认测试.

**18. 你所了解的的软件测试类型都有哪些，简单介绍一下。**

按测试策略分类：

1、静态与动态测试

2、黑盒与白盒测试

3、手工和自动测试

4、冒烟测试

5、回归测试；

按测试阶段分类：单元测试、集成测试、系统测试；

其他常见测试方法：

1、功能测试

2、性能测试

3、压力测试

4、负载测试

5、易用性测试

6、安装测试

7、界面测试

8、配置测试

9、文档测试

10、兼容性测试

11、安全性测试

12、恢复测试

**19. 您认为做好测试用例设计工作的关键是什么？**

白盒测试用例设计的关键是以较少的用例覆盖尽可能多的内部程序逻辑结果

黑盒法用例设计的关键同样也是以较少的用例覆盖模块输出和输入接口。不可能做到完全测试，以最少的用例在合理的时间内发现最多的问题

**20. 一套完整的测试应该由哪些阶段组成？**

可行性分析、需求分析、概要设计、详细设计、编码、单元测试、集成测试、系统测试、验收测试

**21. 面向对象的测试用例设计有几种方法？如何实现？**

给类中的每个构造函数设计一组测试用例

组合类中的类变量、实例变量

组合类中的各种方法

根据前置条件和后置条件设计测试用例根据代码设计测试用例

## **总结**

看到这儿，如果你能按着我上面写的内容做到90%，那你去找工作就不成问题了。剩下的百分之十代表什么呢？

# Python 必备知识点总结

​     **python中装饰器是随着程序的加载运行而自动加载的，跟调不调用方法没有关系.所以只要是装饰器内部函数以外的部分都会自动加载执行，不用调用。注释的分类**

- 单行： `# 注释内容`，快捷键ctrl+/
- 多行：`""" 注释内容 """` 或 `''' 注释内容 '''`

变量就是一个存储数据的的时候当前数据所在的内存地址的名字而已。

##  命名习惯

- ```python
  >>> a = [1,2,3]
  >>> b = [4,5,6]
  >>> c = [4,5,6,7,8]
  >>> zipped = zip(a,b)     # 返回一个对象
  >>> zipped
  <zip object at 0x103abc288>
  >>> list(zipped)  # list() 转换为列表
  [(1, 4), (2, 5), (3, 6)]
  >>> list(zip(a,c))              # 元素个数与最短的列表一致
  [(1, 4), (2, 5), (3, 6)]
  
  >>> a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
  >>> list(a1)
  [1, 2, 3]
  >>> list(a2)
  [4, 5, 6]
  >>>
  
  
  
  
  ```

  

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 

- 见名知义。

- 大驼峰：即每个单词首字母都大写，例如：`MyName`。

- 小驼峰：第二个（含）以后的单词首字母大写，例如：`myName`。

- 下划线：例如：`my_name`。

![image-20220906211220415](%E5%88%B7%E9%A2%98.assets/image-20220906211220415-16624699434721.png)

> `

```python
a = 1
print(type(a))  # <class 'int'> -- 整型

b = 1.1
print(type(b))  # <class 'float'> -- 浮点型

c = True
print(type(c))  # <class 'bool'> -- 布尔型

d = '12345'
print(type(d))  # <class 'str'> -- 字符串

e = [10, 20, 30]
print(type(e))  # <class 'list'> -- 列表

f = (10, 20, 30)
print(type(f))  # <class 'tuple'> -- 元组

h = {10, 20, 30}
print(type(h))  # <class 'set'> -- 集合

g = {'name': 'TOM', 'age': 20}
print(type(g))  # <class 'dict'> -- 字典
```

# 总结

- 定义变量的语法

``` python
变量名 = 值
```

- 标识符
  - 由数字、字母、下划线组成
  - 不能数字开头
  - 不能使用内置关键字
  - 严格区分大小写
- 数据类型
  - 整型：int
  - 浮点型：float
  - 字符串：str
  - 布尔型：bool
  - 元组：tuple
  - 集合：set
  - 字典：dict

格式化字符串除了%s，还可以写为`f'{表达式}'`

```python
age = 18 
name = 'TOM'
weight = 75.5
student_id = 1

# 我的名字是TOM
print('我的名字是%s' % name)

# 我的学号是0001
print('我的学号是%4d' % student_id)

# 我的体重是75.50公斤
print('我的体重是%.2f公斤' % weight)

# 我的名字是TOM，今年18岁了
print('我的名字是%s，今年%d岁了' % (name, age))

# 我的名字是TOM，明年19岁了
print('我的名字是%s，明年%d岁了' % (name, age + 1))

# 我的名字是TOM，明年19岁了
print(f'我的名字是{name}, 明年{age + 1}岁了')
```

> f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。

# 总结

- 格式化符号
  - %s：格式化输出字符串
  - %d：格式化输出整数
  - %f：格式化输出浮点数
- f-字符串
  - f'{表达式}'
- 转义字符
  - \n：换行
  - \t：制表符
- print结束符

``` python
print('内容', end="")
```

# 总结

- 输入功能
  - input('提示文字')
- 输入的特点
  - 一般将input接收的数据存储到变量
  - input接收的任何数据默认都是字符串数据类型

# 二. 转换数据类型的函数

|          函数          |                        说明                         |
| :--------------------: | :-------------------------------------------------: |
|  ==int(x [,base ])==   |                  将x转换为一个整数                  |
|     ==float(x )==      |                 将x转换为一个浮点数                 |
| complex(real [,imag ]) |        创建一个复数，real为实部，imag为虚部         |
|      ==str(x )==       |                将对象 x 转换为字符串                |
|        repr(x )        |             将对象 x 转换为表达式字符串             |
|     ==eval(str )==     | 用来计算在字符串中的有效Python表达式,并返回一个对象 |
|     ==tuple(s )==      |               将序列 s 转换为一个元组               |
|      ==list(s )==      |               将序列 s 转换为一个列表               |
|        chr(x )         |           将一个整数转换为一个Unicode字符           |
|        ord(x )         |           将一个字符转换为它的ASCII整数值           |
|        hex(x )         |         将一个整数转换为一个十六进制字符串          |
|        oct(x )         |          将一个整数转换为一个八进制字符串           |
|        bin(x )         |          将一个整数转换为一个二进制字符串           |

# 四. 实验

``` python
# 1. float() -- 转换成浮点型
num1 = 1
print(float(num1))
print(type(float(num1)))

# 2. str() -- 转换成字符串类型
num2 = 10
print(type(str(num2)))

# 3. tuple() -- 将一个序列转换成元组
list1 = [10, 20, 30]
print(tuple(list1))
print(type(tuple(list1)))


# 4. list() -- 将一个序列转换成列表
t1 = (100, 200, 300)
print(list(t1))
print(type(list(t1)))

# 5. eval() -- 将字符串中的数据转换成Python表达式原本类型
str1 = '10'
str2 = '[1, 2, 3]'
str3 = '(1000, 2000, 3000)'
print(type(eval(str1)))
print(type(eval(str2)))
print(type(eval(str3)))
```

## 1. 算数运算符

| 运算符 |  描述  | 实例                                                  |
| :----: | :----: | ----------------------------------------------------- |
|   +    |   加   | 1 + 1 输出结果为 2                                    |
|   -    |   减   | 1-1 输出结果为 0                                      |
|   *    |   乘   | 2 * 2 输出结果为 4                                    |
|   /    |   除   | 10 / 2 输出结果为 5                                   |
|   //   |  整除  | 9 // 4 输出结果为2                                    |
|   %    |  取余  | 9 % 4 输出结果为 1                                    |
|   **   |  指数  | 2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2                |
|   ()   | 小括号 | 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 |

> 注意：

- 混合运算优先级顺序：`()`高于 `**` 高于 `*` `/` `//` `%` 高于 `+` `-`

## 2. 赋值运算符

| 运算符 | 描述 | 实例                                |
| ------ | ---- | ----------------------------------- |
| =      | 赋值 | 将`=`右侧的结果赋值给等号左侧的变量 |

- 



## 3. 复合赋值运算符 

| 运算符 | 描述           | 实例                       |
| ------ | -------------- | -------------------------- |
| +=     | 加法赋值运算符 | c += a 等价于 c = c + a    |
| -=     | 减法赋值运算符 | c -= a 等价于 c = c- a     |
| *=     | 乘法赋值运算符 | c *= a 等价于 c = c * a    |
| /=     | 除法赋值运算符 | c /= a 等价于 c = c / a    |
| //=    | 整除赋值运算符 | c //= a 等价于 c = c // a  |
| %=     | 取余赋值运算符 | c %= a 等价于 c = c % a    |
| **=    | 幂赋值运算符   | c ** = a 等价于 c = c ** a |

```python
a = 100
a += 1
# 输出101  a = a + 1,最终a = 100 + 1
print(a)

b = 2
b *= 3
# 输出6  b = b * 3,最终b = 2 * 3
print(b)

c = 10
c += 1 + 2
# 输出13, 先算运算符右侧1 + 2 = 3， c += 3 , 推导出c = 10 + 3
print(c)
```



## 4. 比较运算符

比较运算符也叫关系运算符， 通常用来判断。

| 运算符 | 描述                                                         | 实例                                                        |
| ------ | ------------------------------------------------------------ | ----------------------------------------------------------- |
| ==     | 判断相等。如果两个操作数的结果相等，则条件结果为真(True)，否则条件结果为假(False) | 如a=3,b=3，则（a == b) 为 True                              |
| !=     | 不等于 。如果两个操作数的结果不相等，则条件为真(True)，否则条件结果为假(False) | 如a=3,b=3，则（a == b) 为 True如a=1,b=3，则(a != b) 为 True |
| >      | 运算符左侧操作数结果是否大于右侧操作数结果，如果大于，则条件为真，否则为假 | 如a=7,b=3，则(a > b) 为 True                                |
| <      | 运算符左侧操作数结果是否小于右侧操作数结果，如果小于，则条件为真，否则为假 | 如a=7,b=3，则(a < b) 为 False                               |
| >=     | 运算符左侧操作数结果是否大于等于右侧操作数结果，如果大于，则条件为真，否则为假 | 如a=7,b=3，则(a < b) 为 False如a=3,b=3，则(a >= b) 为 True  |
| <=     | 运算符左侧操作数结果是否小于等于右侧操作数结果，如果小于，则条件为真，否则为假 | 如a=3,b=3，则(a <= b) 为 True                               |

```python
a = 7
b = 5
print(a == b)  # False
print(a != b)  # True
print(a < b)   # False
print(a > b)   # True
print(a <= b)  # False
print(a >= b)  # True
```

## 5. 逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                                     |
| ------ | ---------- | ------------------------------------------------------------ | ---------------------------------------- |
| and    | x and y    | 布尔"与"：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 | True and False， 返回 False。            |
| or     | x or y     | 布尔"或"：如果 x 是 True，它返回 True，否则它返回 y 的值。   | False or True， 返回 True。              |
| not    | not x      | 布尔"非"：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not True 返回 False, not False 返回 True |

```python
a = 1
b = 2
c = 3
print((a < b) and (b < c))  # True
print((a > b) and (b < c))  # False
print((a > b) or (b < c))   # True
print(not (a > b))          # True
```

### 5.1 拓展

数字之间的逻辑运算

``` python
a = 0
b = 1
c = 2

# and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字
print(a and b)  # 0
print(b and a)  # 0
print(a and c)  # 0
print(c and a)  # 0
print(b and c)  # 2
print(c and b)  # 1

# or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字
print(a or b)  # 1
print(a or c)  # 2
print(b or c)  # 1
```

# 总结

- 算数运算的优先级
  - 混合运算优先级顺序：`()`高于 `**` 高于 `*` `/` `//` `%` 高于 `+` `-`
- 赋值运算符
  - =
- 复合赋值运算符
  - +=
  - -=
  - 优先级
    1. 先算复合赋值运算符右侧的表达式
    2. 再算复合赋值运算的算数运算
    3. 最后算赋值运算
- 比较运算符
  - 判断相等： == 
  - 大于等于： >=
  - 小于等于：<=
  - 不等于： !=
- 逻辑运算符
  - 与： and
  - 或：or
  - 非：not

# 二. if 语法

## 2.1 语法

``` python
if 条件:
    条件成立执行的代码1
    条件成立执行的代码2
    ......
```



## 2.2 快速体验

``` python
if True:
    print('条件成立执行的代码1')
    print('条件成立执行的代码2')

# 下方的代码没有缩进到if语句块，所以和if条件无关
print('我是无论条件是否成立都要执行的代码')
```

执行结果如下：

![image-20190103113457876](%E5%88%B7%E9%A2%98.assets/image-20190103113457876-6486497.png)



# 三. 实例：上网

需求分析：如果用户年龄大于等于18岁，即成年，输出"已经成年，可以上网"。

## 3.1 简单版

``` python
age = 20
if age >= 18:
    print('已经成年，可以上网')

print('系统关闭')
```

## 3.2 进阶版

新增需求：用户可以输出自己的年龄，然后系统进行判断是否成年，成年则输出"您的年龄是'用户输入的年龄'，已经成年，可以上网"。

``` python
# input接受用户输入的数据是字符串类型，条件是age和整型18做判断，所以这里要int转换数据类型
age = int(input('请输入您的年龄：'))

if age >= 18:
    print(f'您的年龄是{age},已经成年，可以上网')


print('系统关闭')
```



# 四. if...else...

作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。

> 思考：网吧上网的实例，如果成年，允许上网，如果不成年呢？是不是应该回复用户不能上网？

## 4.1 语法

``` python
if 条件:
    条件成立执行的代码1
    条件成立执行的代码2
    ......
else:
    条件不成立执行的代码1
    条件不成立执行的代码2
    ......
```

## 4.2 实用版：网吧上网

``` python
age = int(input('请输入您的年龄：'))

if age >= 18:
    print(f'您的年龄是{age},已经成年，可以上网')
else:
    print(f'您的年龄是{age},未成年，请自行回家写作业')

print('系统关闭')
```

> 注意：如果条件成立执行了某些代码，那么其他的情况的代码将不会执行。

# 五、多重判断

> 思考：中国合法工作年龄为18-60岁，即如果年龄小于18的情况为童工，不合法；如果年龄在18-60岁之间为合法工龄；大于60岁为法定退休年龄。

## 5.1 语法

``` python
if 条件1:
    条件1成立执行的代码1
    条件1成立执行的代码2
    ......
elif 条件2：
	条件2成立执行的代码1
    条件2成立执行的代码2
    ......
......
else:
    以上条件都不成立执行执行的代码
```

> 多重判断也可以和else配合使用。一般else放到整个if语句的最后，表示以上条件都不成立的时候执行的代码。



## 5.2 实例：工龄判断

``` python
age = int(input('请输入您的年龄：'))
if age < 18:
    print(f'您的年龄是{age},童工一枚')
elif (age >= 18) and (age <= 60):
    print(f'您的年龄是{age},合法工龄')
elif age > 60:
    print(f'您的年龄是{age},可以退休')
```

> 拓展：`age >= 18 and age <= 60`可以化简为`18 <= age <= 60`。

# 六、if嵌套

> 思考：坐公交：如果有钱可以上车，没钱不能上车；上车后如果有空座，则可以坐下；如果没空座，就要站着。怎么书写程序？

## 6.1 语法

``` python
if 条件1：
	条件1成立执行的代码
    条件1成立执行的代码
    
    if 条件2：
    	条件2成立执行的代码
        条件2成立执行的代码
    
```

> 注意：条件2的if也是处于条件1成立执行的代码的缩进关系内部。



## 6.2 实例：坐公交

### 6.2.1 判断是否能上车

``` python
"""
1. 如果有钱，则可以上车
    2. 上车后，如果有空座，可以坐下
    上车后，如果没有空座，则站着等空座位
如果没钱，不能上车
"""
# 假设用 money = 1 表示有钱, money = 0表示没有钱
money = 1
if money == 1:
    print('土豪，不差钱，顺利上车')
else:
    print('没钱，不能上车，追着公交车跑')
```



### 6.2.2 判断是否能坐下

``` python
"""
1. 如果有钱，则可以上车
    2. 上车后，如果有空座，可以坐下
    上车后，如果没有空座，则站着等空座位
如果没钱，不能上车
"""
# 假设用 money = 1 表示有钱, money = 0表示没有钱; seat = 1 表示有空座，seat = 0 表示没有空座
money = 1
seat = 0
if money == 1:
    print('土豪，不差钱，顺利上车')
    if seat == 1:
        print('有空座，可以坐下')
    else:
        print('没有空座，站等')
else:
    print('没钱，不能上车，追着公交车跑')
```

# 七. 应用：猜拳游戏

需求分析：

- 参与游戏的角色

  - 玩家
    - 手动出拳
  - 电脑
    - 随机出拳

- 判断输赢

  - 玩家获胜

  | 玩家 | 电脑 |
  | ---- | ---- |
  | 石头 | 剪刀 |
  | 剪刀 | 布   |
  | 布   | 石头 |

  - 平局
    - 玩家出拳 和 电脑出拳相同
  - 电脑获胜

随机做法：

 	1. 导出random模块
 	2. random.randint(开始,结束)

``` python
"""
提示：0-石头，1-剪刀，2-布
1. 出拳
玩家输入出拳
电脑随机出拳

2. 判断输赢
玩家获胜
平局
电脑获胜
"""

# 导入random模块
import random

# 计算电脑出拳的随机数字
computer = random.randint(0, 2)
print(computer)

player = int(input('请出拳：0-石头，1-剪刀，2-布：'))

# 玩家胜利 p0:c1 或 p1:c2 或 p2:c0
if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0):
    print('玩家获胜')

# 平局：玩家 == 电脑
elif player == computer:
    print('平局')
else:
    print('电脑获胜')
```

# 八.  三目运算符

三目运算符也叫三元运算符。

语法如下：

``` python
值1 if 条件 else 值2
```

快速体验：

``` python
a = 1
b = 2

c = a if a > b else b
print(c)
```



# 二. while的语法

``` python
while 条件:
    条件成立重复执行的代码1
    条件成立重复执行的代码2
    ......
```

## 2.1 快速体验

需求：复现重复执行100次`print('媳妇儿，我错了')`（输出更简洁一些，我们这里设置5次）。

分析：初始值是0次，终点是5次，重复做的事情输出“媳妇儿， 我错了”。

``` python
# 循环的计数器
i = 0
while i < 5:
    print('媳妇儿，我错了')
    i += 1

print('任务结束')
```

# 三. while的应用

## 3.1 应用一：计算1-100累加和

分析：1-100的累加和，即1 + 2 + 3 + 4 +….，即前两个数字的相加结果 + 下一个数字( 前一个数字 + 1)。

``` python
i = 1
result = 0
while i <= 100:
    result += i
    i += 1

# 输出5050
print(result)
```

> 注意：为了验证程序的准确性，可以先改小数值，验证结果正确后，再改成1-100做累加。

## 3.2 应用二：计算1-100偶数累加和

分析：1-100的偶数和，即 2 + 4 + 6 + 8....，得到偶数的方法如下：

- 偶数即是和2取余结果为0的数字，可以加入条件语句判断是否为偶数，为偶数则累加
- 初始值为0 / 2 , 计数器每次累加2

### 3.2.1 方法一：条件判断和2取余数则累加

``` python
# 方法一：条件判断和2取余数为0则累加计算
i = 1
result = 0
while i <= 100:
    if i % 2 == 0:
        result += i
    i += 1

# 输出2550
print(result)
```

### 3.2.2 方法二：计数器控制

``` python
# 方法二：计数器控制增量为2
i = 0
result = 0
while i <= 100:
    result += i
    i += 2

# 输出2550
print(result)
```

# 四、break和continue

break和continue是循环中满足一定条件退出循环的两种不同方式。

## 4.1 理解

举例：一共吃5个苹果，吃完第一个，吃第二个…，这里"吃苹果"的动作是不是重复执行？

情况一：如果吃的过程中，吃完第三个吃饱了，则不需要再吃第4个和第五个苹果，即是吃苹果的动作停止，这里就是break控制循环流程，即==终止此循环==。

情况二：如果吃的过程中，吃到第三个吃出一个大虫子...,是不是这个苹果就不吃了，开始吃第四个苹果，这里就是continue控制循环流程，即==退出当前一次循环继而执行下一次循环代码==。

### 4.1.1 情况一：break

``` python
i = 1
while i <= 5:
    if i == 4:
        print(f'吃饱了不吃了')
        break
    print(f'吃了第{i}个苹果')
    i += 1
```

执行结果：

![image-20190124114340900](%E5%88%B7%E9%A2%98.assets/image-20190124114340900.png)

### 4.1.2 情况二：continue

``` python
i = 1
while i <= 5:
    if i == 3:
        print(f'大虫子，第{i}个不吃了')
        # 在continue之前一定要修改计数器，否则会陷入死循环
        i += 1
        continue
    print(f'吃了第{i}个苹果')
    i += 1
```

执行结果：

![image-20190124114514775](%E5%88%B7%E9%A2%98.assets/image-20190124114514775.png)

# 五. while循环嵌套

## 5.1 应用场景

故事梗概：有天女朋友又生气了，惩罚：说3遍“媳妇儿， 我错了”，这个程序是不是循环即可？但如果女朋友说：还要刷今天晚饭的碗，这个程序怎么书写？

``` python
while 条件:
    print('媳妇儿， 我错了')
print('刷晚饭的碗')
```

但如果女朋友还是生气，把这套惩罚要连续3天都执行，有如何书写程序？

``` python
while 条件:
    while 条件:
        print('媳妇儿， 我错了')
    print('刷晚饭的碗')
```

## 5.2 语法

``` python
while 条件1:
    条件1成立执行的代码
    ......
    while 条件2:
        条件2成立执行的代码
        ......
```

> 总结：所谓while循环嵌套，就是一个while里面嵌套一个while的写法，每个while和之前的基础语法是相同的。

## 5.3 快速体验：复现场景

### 5.3.1 代码

``` python
j = 0
while j < 3:
    i = 0
    while i < 3:
        print('媳妇儿，我错了')
        i += 1
    print('刷晚饭的碗')
    print('一套惩罚结束----------------')
    j += 1
```

### 5.3.2 执行结果

![image-20190104161506542](%E5%88%B7%E9%A2%98.assets/image-20190104161506542-6589706.png)

### 5.3.3 理解执行流程

当内部循环执行完成之后，再执行下一次外部循环的条件判断。

![](%E5%88%B7%E9%A2%98.assets/while2.png)

# 六. while循环嵌套应用

## 6.1 应用一：打印星号(正方形)

### 6.1.1 需求

``` html
*****
*****
*****
*****
*****
```

### 6.1.2 代码

分析：一行输出5个星号，重复打印5行

``` python
# 重复打印5行星星
j = 0
while j <= 4:
    # 一行星星的打印
    i = 0
    while i <= 4:
        # 一行内的星星不能换行，取消print默认结束符\n
        print('*', end='')
        i += 1
    # 每行结束要换行，这里借助一个空的print，利用print默认结束符换行
    print()
    j += 1
```

## 6.2 应用二：打印星号(三角形)

### 6.2.1 需求

``` html
*
**
***
****
*****
```

### 6.2.2 代码

分析：==一行输出星星的个数和行号是相等的==，每行：重复打印行号数字个星号，将打印行星号的命令重复执行5次实现打印5行。

``` python
# 重复打印5行星星
# j表示行号
j = 0
while j <= 4:
    # 一行星星的打印
    i = 0
    # i表示每行里面星星的个数，这个数字要和行号相等所以i要和j联动
    while i <= j:
        print('*', end='')
        i += 1
    print()
    j += 1
```

## 6.3 九九乘法表

### 6.3.1 执行结果

![image-20190104163553616](%E5%88%B7%E9%A2%98.assets/image-20190104163553616-6590953.png)

### 6.3.2 代码

``` python
# 重复打印9行表达式
j = 1
while j <= 9:
    # 打印一行里面的表达式 a * b = a*b
    i = 1
    while i <= j:
        print(f'{i}*{j}={j*i}', end='\t')
        i += 1
    print()
    j += 1
```

# 七、for循环

## 7.1 语法

``` python
for 临时变量 in 序列:
    重复执行的代码1
    重复执行的代码2
    ......
```

## 7.2 快速体验

``` python
str1 = 'itheima'
for i in str1:
    print(i)
```

执行结果：

![image-20190104164152311](%E5%88%B7%E9%A2%98.assets/image-20190104164152311-6591312.png)

## 7.3 break

``` python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        break
    print(i)
```

执行结果：

![image-20190104165242555](%E5%88%B7%E9%A2%98.assets/image-20190104165242555-6591962.png)

## 7.4 continue

```python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        continue
    print(i)
```

执行结果：

![image-20190104165413160](%E5%88%B7%E9%A2%98.assets/image-20190104165413160-6592053.png)

# 八. else

循环可以和else配合使用，else下方缩进的代码指的是==当循环正常结束之后要执行的代码==。

## 8.1 while...else

需求：女朋友生气了，要惩罚：连续说5遍“媳妇儿，我错了”，如果道歉正常完毕女朋友就原谅我了，这个程序怎么写？

``` python
i = 1
while i <= 5:
    print('媳妇儿，我错了')
    i += 1
print('媳妇儿原谅我了...')
```

> 思考： 这个print是不是没有循环也能执行？

### 8.1.1 语法

``` python
while 条件:
    条件成立重复执行的代码
else:
    循环正常结束之后要执行的代码
```

### 8.1.2 示例

``` python
i = 1
while i <= 5:
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125111816497](%E5%88%B7%E9%A2%98.assets/image-20190125111816497.png)

### 8.1.3 退出循环的方式

需求：女朋友生气，要求道歉5遍：媳妇儿，我错了。道歉到第三遍的时候，媳妇埋怨这一遍说的不真诚，是不是就是要退出循环了？这个退出有两种可能性：

- 更生气，不打算原谅，也不需要道歉了，程序如何书写？
- 只一遍不真诚，可以忍受，继续下一遍道歉，程序如何书写？

1. break

``` python
i = 1
while i <= 5:
    if i == 3:
        print('这遍说的不真诚')
        break
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125111952693](%E5%88%B7%E9%A2%98.assets/image-20190125111952693.png)

> 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。

2. continue

``` python
i = 1
while i <= 5:
    if i == 3:
        print('这遍说的不真诚')
        i += 1
        continue
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125112111170](%E5%88%B7%E9%A2%98.assets/image-20190125112111170.png)

> 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。

## 8.2 for...else

### 8.2.1 语法

``` python
for 临时变量 in 序列:
    重复执行的代码
    ...
else:
    循环正常结束之后要执行的代码
```

> 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。

### 8.2.2 示例

``` python
str1 = 'itheima'
for i in str1:
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

### 8.2.3 退出循环的方式



刷题：

```
描述
计算的世界，除了二进制与十进制，使用最多的就是十六进制了，现在使用input读入一个十六进制的数字，输出它的十进制数字是多少？
输入描述：
input读入一个十六进制数字，按照字符串的形式包括数字0-9、字母A-F。
输出描述：
输出读入数字的十进制大小。


num = list(input())
num.reverse()
dict1 = {"A":10,"B":11,"C":12,"D":13,"E":14,"F":15}
one_to_night = [0,1,2,3,4,5,6,7,8,9]
long_num = len(num)
Base_library = []
position = 0

for cl in num:
    if cl in dict1:
        intermediary = dict1[cl]
        Base_library.append(intermediary)
    elif int(cl) in one_to_night:
        Base_library.append(int(cl))

for i in range(0,long_num):
    multiplier = 16**i
    num2 = Base_library[i] * multiplier
    position = position + num2


print(position)



num16 = input()
num10 = int(num16,16)
print(num10)

```



1. break终止循环

``` python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        break
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

执行结果：

![image-20190104165551501](%E5%88%B7%E9%A2%98.assets/image-20190104165551501-6592151.png)

> 没有执行else缩进的代码。

2. continue控制循环

``` python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        continue
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

执行结果：

![image-20190104165714740](%E5%88%B7%E9%A2%98.assets/image-20190104165714740-6592234.png)

> 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。



# 总结

- 循环的作用：控制代码重复执行
- while语法

``` python
while 条件:
    条件成立重复执行的代码1
    条件成立重复执行的代码2
    ......
```

- while循环嵌套语法

```python
while 条件1:
    条件1成立执行的代码
    ......
    while 条件2:
        条件2成立执行的代码
        ......
```

- for循环语法

``` python
for 临时变量 in 序列:
    重复执行的代码1
    重复执行的代码2
    ......
```

- break退出整个循环
- continue退出本次循环，继续执行下一次重复执行的代码
- else
  - while和for都可以配合else使用
  - else下方缩进的代码含义：当循环正常结束后执行的代码
  - break终止循环不会执行else下方缩进的代码
  - continue退出循环的方式执行else下方缩进的代码

# 总结

- if语句语法

``` python
if 条件:
    条件成立执行的代码
```

- if...else...

``` python
if 条件:
    条件成立执行的代码
else:
    条件不成立执行的代码
```

- 多重判断

``` python
if 条件1:
    条件1成立执行的代码
elif 条件2:
    条件2成立执行的代码
else:
    以上条件都不成立执行的代码
```

- if嵌套

``` python
if 条件1:
    条件1成立执行的代码
    if 条件2:
        条件2成立执行的代码
        ....
```



# 课程：字符串

# 目标

- 认识字符串
- 下标
- 切片
- 常用操作方法

# 一. 认识字符串

字符串是 Python 中最常用的数据类型。我们一般使用引号来创建字符串。创建字符串很简单，只要为变量分配一个值即可。

``` python
a = 'hello world'
b = "abcdefg"
print(type(a))
print(type(b))
```

> 注意：控制台显示结果为`<class 'str'>`， 即数据类型为str(字符串)。

## 1.1 字符串特征

- 一对引号字符串

``` python
name1 = 'Tom'
name2 = "Rose"
```



- 三引号字符串

``` python
name3 = ''' Tom '''
name4 = """ Rose """
a = ''' i am Tom, 
        nice to meet you! '''

b = """ i am Rose, 
        nice to meet you! """
```

> 注意：三引号形式的字符串支持换行。

> 思考：如果创建一个字符串` I'm Tom`?

``` python
c = "I'm Tom"
d = 'I\'m Tom'
```

## 1.2 字符串输出

``` python
print('hello world')

name = 'Tom'
print('我的名字是%s' % name)
print(f'我的名字是{name}')
```



## 1.3 字符串输入

在Python中，使用`input()`接收用户输入。

- 代码

``` python
name = input('请输入您的名字：')
print(f'您输入的名字是{name}')
print(type(name))

password = input('请输入您的密码：')
print(f'您输入的密码是{password}')
print(type(password))
```

- 输出结果

![image-20190129172920882](%E5%88%B7%E9%A2%98.assets/image-20190129172920882.png)



# 二、下标

`“下标”`又叫`“索引”`，就是编号。比如火车座位号，座位号的作用：按照编号快速找到对应的座位。同理，下标的作用即是通过下标快速找到对应的数据。

![image-20190129173606647](%E5%88%B7%E9%A2%98.assets/image-20190129173606647.png)

## 2.1 快速体验

需求：字符串`name = "abcdef"`，取到不同下标对应的数据。

- 代码

``` python
name = "abcdef"

print(name[1])
print(name[0])
print(name[2])
```

- 输出结果

![image-20190129174231104](%E5%88%B7%E9%A2%98.assets/image-20190129174231104.png)

> 注意：下标从==0==开始。

![image-20190129174231104](%E5%88%B7%E9%A2%98.assets/2.png)



# 三、切片

切片是指对操作的对象截取其中一部分的操作。**字符串、列表、元组**都支持切片操作。

## 3.1 语法

``` python
序列[开始位置下标:结束位置下标:步长]


个人梳理理解：  开始位置下标定位开始位置  ，  结束位置下标定位结束位置  ，步长正负决定方向、大小决定跨度
```

> 注意

 	1. 不包含结束位置下标对应的数据， 正负整数均可；
 	2. 步长是选取间隔，正负整数均可，默认步长为1。

## 3.2 体验

``` python
name = "abcdefg"

print(name[2:5:1])  # cde
print(name[2:5])  # cde
print(name[:5])  # abcde
print(name[1:])  # bcdefg
print(name[:])  # abcdefg
print(name[::2])  # aceg
print(name[:-1])  # abcdef, 负1表示倒数第一个数据
print(name[-4:-1])  # def
print(name[::-1])  # gfedcba
```



# 四、常用操作方法

字符串的常用操作方法有查找、修改和判断三大类。

## 4.1 查找

所谓字符串查找方法即是查找子串在字符串中的位置或出现的次数。

- find()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则返回-1。

1. 语法

``` python
字符串序列.find(子串, 开始位置下标, 结束位置下标)
```

> 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

print(mystr.find('and'))  # 12
print(mystr.find('and', 15, 30))  # 23
print(mystr.find('ands'))  # -1
```



- index()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则报异常。

1. 语法

``` python
字符串序列.index(子串, 开始位置下标, 结束位置下标)
```

> 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

print(mystr.index('and'))  # 12
print(mystr.index('and', 15, 30))  # 23
print(mystr.index('ands'))  # 报错
```



- rfind()： 和find()功能相同，但查找方向为==右侧==开始。
- rindex()：和index()功能相同，但查找方向为==右侧==开始。
- count()：返回某个子串在字符串中出现的次数

1. 语法

``` python
字符串序列.count(子串, 开始位置下标, 结束位置下标)
```

> 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

print(mystr.count('and'))  # 3
print(mystr.count('ands'))  # 0
print(mystr.count('and', 0, 20))  # 1
```



## 4.2 修改

所谓修改字符串，指的就是通过函数的形式修改字符串中的数据。

- replace()：替换

1. 语法

``` python
字符串序列.replace(旧子串, 新子串, 替换次数)
```

> 注意：替换次数如果查出子串出现次数，则替换次数为该子串出现次数。

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：hello world he itcast he itheima he Python
print(mystr.replace('and', 'he'))
# 结果：hello world he itcast he itheima he Python
print(mystr.replace('and', 'he', 10))
# 结果：hello world and itcast and itheima and Python
print(mystr)
```

> 注意：数据按照是否能直接修改分为==可变类型==和==不可变类型==两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。



- split()：按照指定字符分割字符串。

1. 语法

``` python
字符串序列.split(分割字符, num)
```

> 注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：['hello world ', ' itcast ', ' itheima ', ' Python']
print(mystr.split('and'))
# 结果：['hello world ', ' itcast ', ' itheima and Python']
print(mystr.split('and', 2))
# 结果：['hello', 'world', 'and', 'itcast', 'and', 'itheima', 'and', 'Python']
print(mystr.split(' '))
# 结果：['hello', 'world', 'and itcast and itheima and Python']
print(mystr.split(' ', 2))
```

> 注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。

- join()：用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。

1. 语法

``` python
字符或子串.join(多字符串组成的序列)
```

2. 快速体验

``` python
list1 = ['chuan', 'zhi', 'bo', 'ke']
t1 = ('aa', 'b', 'cc', 'ddd')
# 结果：chuan_zhi_bo_ke
print('_'.join(list1))
# 结果：aa...b...cc...ddd
print('...'.join(t1))
```



- capitalize()：将字符串第一个字符转换成大写。

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：Hello world and itcast and itheima and python
print(mystr.capitalize())
```

> 注意：capitalize()函数转换后，只字符串第一个字符大写，其他的字符全都小写。



- title()：将字符串每个单词首字母转换成大写。

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：Hello World And Itcast And Itheima And Python
print(mystr.title())
```



- lower()：将字符串中大写转小写。

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：hello world and itcast and itheima and python
print(mystr.lower())
```



- upper()：将字符串中小写转大写。

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：HELLO WORLD AND ITCAST AND ITHEIMA AND PYTHON
print(mystr.upper())
```



- lstrip()：删除字符串左侧空白字符。

![image-20190129213453010](%E5%88%B7%E9%A2%98.assets/image-20190129213453010.png)



- rstrip()：删除字符串右侧空白字符。

![image-20190129213558850](%E5%88%B7%E9%A2%98.assets/image-20190129213558850.png)



- strip()：删除字符串两侧空白字符。

![image-20190129213637584](%E5%88%B7%E9%A2%98.assets/image-20190129213637584.png)



- ljust()：返回一个原字符串左对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串。

1. 语法

``` python
字符串序列.ljust(长度, 填充字符)
```

2. 输出效果

![image-20190130141125560](%E5%88%B7%E9%A2%98.assets/image-20190130141125560.png)



- rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。
- center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。

![image-20190130141442074](%E5%88%B7%E9%A2%98.assets/image-20190130141442074.png)



## 4.3 判断

所谓判断即是判断真假，返回的结果是布尔型数据类型：True 或 False。

- startswith()：检查字符串是否是以指定子串开头，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。

1. 语法

``` python
字符串序列.startswith(子串, 开始位置下标, 结束位置下标)
```

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python   "

# 结果：True
print(mystr.startswith('hello'))

# 结果False
print(mystr.startswith('hello', 5, 20))
```



- endswith()：：检查字符串是否是以指定子串结尾，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。

1. 语法

``` python
字符串序列.endswith(子串, 开始位置下标, 结束位置下标)
```

2. 快速体验

``` python
mystr = "hello world and itcast and itheima and Python"

# 结果：True
print(mystr.endswith('Python'))

# 结果：False
print(mystr.endswith('python'))

# 结果：False
print(mystr.endswith('Python', 2, 20))
```



- isalpha()：如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False。

``` python
mystr1 = 'hello'
mystr2 = 'hello12345'

# 结果：True
print(mystr1.isalpha())

# 结果：False
print(mystr2.isalpha())
```



- isdigit()：如果字符串只包含数字则返回 True 否则返回 False。

``` python
mystr1 = 'aaa12345'
mystr2 = '12345'

# 结果： False
print(mystr1.isdigit())

# 结果：False
print(mystr2.isdigit())
```



- isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False。

``` python
mystr1 = 'aaa12345'
mystr2 = '12345-'

# 结果：True
print(mystr1.isalnum())

# 结果：False
print(mystr2.isalnum())
```



- isspace()：如果字符串中只包含空白，则返回 True，否则返回 False。

``` python
mystr1 = '1 2 3 4 5'
mystr2 = '     '

# 结果：False
print(mystr1.isspace())

# 结果：True
print(mystr2.isspace())
```



# 五. 总结

- 下标
  - 计算机为数据序列中每个元素分配的从0开始的编号
- 切片

``` python
序列名[开始位置下标:结束位置下标:步长]
```

- 常用操作方法
  - find()
  - index()

# 课程：列表

# 目标

- 列表的应用场景
- 列表的格式
- 列表的常用操作
- 列表的循环遍历
- 列表的嵌套使用

# 一. 列表的应用场景

思考：有一个人的姓名(TOM)怎么书写存储程序？

答：变量。

思考：如果一个班级100位学生，每个人的姓名都要存储，应该如何书写程序？声明100个变量吗？

答：列表即可， 列表一次性可以存储多个数据。

# 二. 列表的格式

``` python
[数据1, 数据2, 数据3, 数据4......]
```

列表可以一次性存储多个数据，且可以为不同数据类型。

# 三. 列表的常用操作

列表的作用是一次性存储多个数据，程序员可以对这些数据进行的操作有：增、删、改、查。

## 3.1 查找

### 3.1.1 下标

``` python
name_list = ['Tom', 'Lily', 'Rose']

print(name_list[0])  # Tom
print(name_list[1])  # Lily
print(name_list[2])  # Rose
```

### 3.1.2 函数

- index()：返回指定数据所在位置的下标 。

1. 语法

``` python
列表序列.index(数据, 开始位置下标, 结束位置下标)
```

2. 快速体验

``` python
name_list = ['Tom', 'Lily', 'Rose']

print(name_list.index('Lily', 0, 2))  # 1
```

> 注意：如果查找的数据不存在则报错。

- count()：统计指定数据在当前列表中出现的次数。

``` python
name_list = ['Tom', 'Lily', 'Rose']

print(name_list.count('Lily'))  # 1
```

- len()：访问列表长度，即列表中数据的个数。

``` python
name_list = ['Tom', 'Lily', 'Rose']

print(len(name_list))  # 3
```



### 3.1.3 判断是否存在

- in：判断指定数据在某个列表序列，如果在返回True，否则返回False

``` python
name_list = ['Tom', 'Lily', 'Rose']

# 结果：True
print('Lily' in name_list)

# 结果：False
print('Lilys' in name_list)
```



- not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False

``` python
name_list = ['Tom', 'Lily', 'Rose']

# 结果：False
print('Lily' not in name_list)

# 结果：True
print('Lilys' not in name_list)
```

- 体验案例

需求：查找用户输入的名字是否已经存在。

``` python
name_list = ['Tom', 'Lily', 'Rose']

name = input('请输入您要搜索的名字：')

if name in name_list:
    print(f'您输入的名字是{name}, 名字已经存在')
else:
    print(f'您输入的名字是{name}, 名字不存在')
```



## 3.2 增加

作用：增加指定数据到列表中。

- append()：列表结尾追加数据。

1. 语法

``` python
列表序列.append(数据)
```

2. 体验

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list.append('xiaoming')

# 结果：['Tom', 'Lily', 'Rose', 'xiaoming']
print(name_list)
```

![image-20190130160154636](%E5%88%B7%E9%A2%98.assets/image-20190130160154636.png)

> 列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。

3. 注意点

如果append()追加的数据是一个序列，则追加整个序列到列表

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list.append(['xiaoming', 'xiaohong'])

# 结果：['Tom', 'Lily', 'Rose', ['xiaoming', 'xiaohong']]
print(name_list)
```



- extend()：列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。

1. 语法

```python
列表序列.extend(数据)
```

2. 快速体验

   2.1 单个数据

```python
name_list = ['Tom', 'Lily', 'Rose']

name_list.extend('xiaoming')

# 结果：['Tom', 'Lily', 'Rose', 'x', 'i', 'a', 'o', 'm', 'i', 'n', 'g']
print(name_list)
```

​	2.2 序列数据

```python
name_list = ['Tom', 'Lily', 'Rose']

name_list.extend(['xiaoming', 'xiaohong'])

# 结果：['Tom', 'Lily', 'Rose', 'xiaoming', 'xiaohong']
print(name_list)
```



- insert()：指定位置新增数据。

1. 语法

``` python
列表序列.insert(位置下标, 数据)
```

2. 快速体验

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list.insert(1, 'xiaoming')

# 结果：['Tom', 'xiaoming', 'Lily', 'Rose']
print(name_list)
```



## 3.3 删除

- del

1. 语法

``` python
del 目标
```

2. 快速体验

   2.1 删除列表

``` python
name_list = ['Tom', 'Lily', 'Rose']

# 结果：报错提示：name 'name_list' is not defined
del name_list
print(name_list)
```

​	2.2 删除指定数据

``` python
name_list = ['Tom', 'Lily', 'Rose']

del name_list[0]

# 结果：['Lily', 'Rose']
print(name_list)
```



- pop()：删除指定下标的数据(默认为最后一个)，并返回该数据。

1. 语法

``` python
列表序列.pop(下标)
```

2. 快速体验

``` python
name_list = ['Tom', 'Lily', 'Rose']

del_name = name_list.pop(1)

# 结果：Lily
print(del_name)

# 结果：['Tom', 'Rose']
print(name_list)
```



- remove()：移除列表中某个数据的第一个匹配项。

1. 语法

``` python
列表序列.remove(数据)
```

2. 快速体验

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list.remove('Rose')

# 结果：['Tom', 'Lily']
print(name_list)
```



- clear()：清空列表

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list.clear()
print(name_list) # 结果： []
```



## 3.4 修改

- 修改指定下标数据

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_list[0] = 'aaa'

# 结果：['aaa', 'Lily', 'Rose']
print(name_list)
```



- 逆置：reverse()

``` python
num_list = [1, 5, 2, 3, 6, 8]

num_list.reverse()

# 结果：[8, 6, 3, 2, 5, 1]
print(num_list)
```



- 排序：sort()

1. 语法

``` python
列表序列.sort( key=None, reverse=False)
```

> 注意：reverse表示排序规则，**reverse = True** 降序， **reverse = False** 升序（默认）

2. 快速体验

``` python
num_list = [1, 5, 2, 3, 6, 8]

num_list.sort()

# 结果：[1, 2, 3, 5, 6, 8]
print(num_list)
```



## 3.5 复制

函数：copy()

``` python
name_list = ['Tom', 'Lily', 'Rose']

name_li2 = name_list.copy()

# 结果：['Tom', 'Lily', 'Rose']
print(name_li2)
```



# 四. 列表的循环遍历

需求：依次打印列表中的各个数据。

## 4.1 while

- 代码

``` python
name_list = ['Tom', 'Lily', 'Rose']

i = 0
while i < len(name_list):
    print(name_list[i])
    i += 1
```

- 执行结果

![image-20190130164205143](%E5%88%B7%E9%A2%98.assets/image-20190130164205143.png)



## 4.2 for

- 代码

``` python
name_list = ['Tom', 'Lily', 'Rose']

for i in name_list:
    print(i)
```



- 执行结果

![image-20190130164227739](%E5%88%B7%E9%A2%98.assets/image-20190130164227739.png)

# 五. 列表嵌套

所谓列表嵌套指的就是一个列表里面包含了其他的子列表。

应用场景：要存储班级一、二、三三个班级学生姓名，且每个班级的学生姓名在一个列表。

``` python
name_list = [['小明', '小红', '小绿'], ['Tom', 'Lily', 'Rose'], ['张三', '李四', '王五']]
```

> 思考： 如何查找到数据"李四"？

``` python
# 第一步：按下标查找到李四所在的列表
print(name_list[2])

# 第二步：从李四所在的列表里面，再按下标找到数据李四
print(name_list[2][1])
```

# 六. 综合应用 -- 随机分配办公室

需求：有三个办公室，8位老师，8位老师随机分配到3个办公室



# 七. 总结

- 列表的格式

``` python
[数据1, 数据2, 数据3]
```

- 常用操作方法
  - index()
  - len()
  - append()
  - pop()
  - remove()
- 列表嵌套

``` python
name_list = [['小明', '小红', '小绿'], ['Tom', 'Lily', 'Rose'], ['张三', '李四', '王五']]
name_list[2][1]
```



一个元组可以存储多个数据，元组内的数据是不能修改的。

# 二. 定义元组

元组特点：定义元组使用==小括号==，且==逗号==隔开各个数据，数据可以是不同的数据类型。

``` python
# 多个数据元组
t1 = (10, 20, 30)

# 单个数据元组
t2 = (10,)
```

> 注意：如果定义的元组只有一个数据，那么这个数据后面也好添加逗号，否则数据类型为唯一的这个数据的数据类型

``` python
t2 = (10,)
print(type(t2))  # tuple

t3 = (20)
print(type(t3))  # int

t4 = ('hello')
print(type(t4))  # str
```



# 三. 元组的常见操作

元组数据不支持修改，只支持查找，具体如下：

- 按下标查找数据

``` python
tuple1 = ('aa', 'bb', 'cc', 'bb')
print(tuple1[0])  # aa
```



- index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。

``` python
tuple1 = ('aa', 'bb', 'cc', 'bb')
print(tuple1.index('aa'))  # 0
```



- count()：统计某个数据在当前元组出现的次数。

``` python
tuple1 = ('aa', 'bb', 'cc', 'bb')
print(tuple1.count('bb'))  # 2
```



- len()：统计元组中数据的个数。

``` python
tuple1 = ('aa', 'bb', 'cc', 'bb')
print(len(tuple1))  # 4
```

> 注意：元组内的直接数据如果修改则立即报错

``` python
tuple1 = ('aa', 'bb', 'cc', 'bb')
tuple1[0] = 'aaa'
```

> 但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。

``` python
tuple2 = (10, 20, ['aa', 'bb', 'cc'], 50, 30)
print(tuple2[2])  # 访问到列表

# 结果：(10, 20, ['aaaaa', 'bb', 'cc'], 50, 30)
tuple2[2][0] = 'aaaaa'
print(tuple2)
```



# 四. 总结

- 定义元组

``` python
t1 = (10, 20, 30)

t2 = (10,)
```

- 常用操作方法
  - index()
  - len()

# 课程：字典

# 目标

- 字典的应用场景
- 创建字典的语法
- 字典常见操作
- 字典的循环遍历

# 一. 字典的应用场景

思考1： 如果有多个数据，例如：'Tom', '男', 20，如何快速存储？

答：列表

``` python
list1 = ['Tom', '男', 20]
```

思考2：如何查找到数据'Tom'？

答：查找到下标为0的数据即可。

``` python
list1[0]
```

思考3：如果将来数据顺序发生变化，如下所示，还能用`list1[0]`访问到数据'Tom'吗？。

``` python
list1 = ['男', 20, 'Tom']
```

答：不能，数据'Tom'此时下标为2。

思考4：数据顺序发生变化，每个数据的下标也会随之变化，如何保证数据顺序变化前后能使用同一的标准查找数据呢？

答：字典，字典里面的数据是以==键值对==形式出现，字典数据和数据顺序没有关系，即字典不支持下标，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。



# 二. 创建字典的语法

字典特点：

- 符号为==大括号==
- 数据为==键值对==形式出现
- 各个键值对之间用==逗号==隔开

``` python
# 有数据字典
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}

# 空字典
dict2 = {}

dict3 = dict()
```

> 注意：一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。

# 三. 字典常见操作

## 3.1 增

写法：==字典序列[key] = 值==

> 注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}

dict1['name'] = 'Rose'
# 结果：{'name': 'Rose', 'age': 20, 'gender': '男'}
print(dict1)

dict1['id'] = 110

# {'name': 'Rose', 'age': 20, 'gender': '男', 'id': 110}
print(dict1)

a=list
b=list

dict1 = dict(zip(a, b))
```

> 注意：字典为可变类型。



## 3.2 删

- del() / del：删除字典或删除字典中指定键值对。

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}

del dict1['gender']
# 结果：{'name': 'Tom', 'age': 20}
print(dict1)
```



- clear()：清空字典

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}

dict1.clear()
print(dict1)  # {}
```



## 3.3 改

写法：==字典序列[key] = 值==

> 注意：如果key存在则修改这个key对应的值 ；如果key不存在则新增此键值对。

## 3.4 查

### 3.4.1 key值查找

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
print(dict1['name'])  # Tom
print(dict1['id'])  # 报错
```

> 如果当前查找的key存在，则返回对应的值；否则则报错。



### 3.4.2 get()

- 语法

``` python
字典序列.get(key, 默认值)
```

> 注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。

- 快速体验

``` python 
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
print(dict1.get('name'))  # Tom
print(dict1.get('id', 110))  # 110
print(dict1.get('id'))  # None
```

### 3.4.3 keys()

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
print(dict1.keys())  # dict_keys(['name', 'age', 'gender'])
```



### 3.4.4 values()

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
print(dict1.values())  # dict_values(['Tom', 20, '男'])
```



### 3.4.5 items()

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
print(dict1.items())  # dict_items([('name', 'Tom'), ('age', 20), ('gender', '男')])
```



# 四. 字典的循环遍历

## 4.1 遍历字典的key

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
for key in dict1.keys():
    print(key)
```

![image-20190212103905553](%E5%88%B7%E9%A2%98.assets/image-20190212103905553.png)



## 4.2 遍历字典的value

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
for value in dict1.values():
    print(value)
```

![image-20190212103957777](%E5%88%B7%E9%A2%98.assets/image-20190212103957777.png)



## 4.3 遍历字典的元素

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
for item in dict1.items():
    print(item)
```

![image-20190212104046564](%E5%88%B7%E9%A2%98.assets/image-20190212104046564.png)



## 4.4 遍历字典的键值对

``` python
dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}
for key, value in dict1.items():
    print(f'{key} = {value}')
```

![image-20190212104223143](%E5%88%B7%E9%A2%98.assets/image-20190212104223143.png)



# 五. 总结

- 定义字典

``` python
dict1 = {'name': 'Python', 'age': 30}

dict2 = {}

dict3 = dict()
```

- 常见操作
  - 增/改

``` python
字典序列[key] = 值
```

- 查找
  - 字典序列[key]
  - keys()
  - values()
  - items()

# 课程：集合

# 目标

- 创建集合
- 集合数据的特点
- 集合的常见操作



# 一. 创建集合

创建集合使用`{}`或`set()`， 但是如果要创建空集合只能使用`set()`，因为`{}`用来创建空字典。

``` python
s1 = {10, 20, 30, 40, 50}
print(s1)

s2 = {10, 30, 20, 10, 30, 40, 30, 50}
print(s2)

s3 = set('abcdefg')
print(s3)

s4 = set()
print(type(s4))  # set

s5 = {}
print(type(s5))  # dict
```

![image-20190318104620690](%E5%88%B7%E9%A2%98.assets/image-20190318104620690.png)

> 特点：
>
> 1. 集合可以去掉重复数据；
> 2. 集合数据是无序的，故不支持下标



# 二. 集合常见操作方法

## 2.1 增加数据

- add()

``` python
s1 = {10, 20}
s1.add(100)
s1.add(10)
print(s1)  # {100, 10, 20}
```

> 因为集合有去重功能，所以，当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。

- update(), 追加的数据是序列。

``` python
s1 = {10, 20}
# s1.update(100)  # 报错
s1.update([100, 200])
s1.update('abc')
print(s1)
```

![image-20190318121424514](%E5%88%B7%E9%A2%98.assets/image-20190318121424514.png)

## 2.2 删除数据

- remove()，删除集合中的指定数据，如果数据不存在则报错。

``` python
s1 = {10, 20}

s1.remove(10)
print(s1)

s1.remove(10)  # 报错
print(s1)
```



- discard()，删除集合中的指定数据，如果数据不存在也不会报错。

``` python
s1 = {10, 20}

s1.discard(10)
print(s1)

s1.discard(10)
print(s1)
```



- pop()，随机删除集合中的某个数据，并返回这个数据。

``` python
s1 = {10, 20, 30, 40, 50}

del_num = s1.pop()
print(del_num)
print(s1)
```



## 2.3 查找数据

- in：判断数据在集合序列
- not in：判断数据不在集合序列

``` python
s1 = {10, 20, 30, 40, 50}

print(10 in s1)
print(10 not in s1)
```



# 三. 总结

- 创建集合

  - 有数据集合

  ``` python
  s1 = {数据1, 数据2, ...}
  ```

  - 无数据集合

  ``` python
  s1 = set()
  ```

- 常见操作

  - 增加数据
    - add()
    - update()
  - 删除数据
    - remove()
    - discard()

# 课程：公共操作

# 目标

- 运算符
- 公共方法
- 容器类型转换



# 一. 运算符1.1 +

``` python
# 1. 字符串 
str1 = 'aa'
str2 = 'bb'
str3 = str1 + str2
print(str3)  # aabb


# 2. 列表 
list1 = [1, 2]
list2 = [10, 20]
list3 = list1 + list2
print(list3)  # [1, 2, 10, 20]

# 3. 元组 
t1 = (1, 2)
t2 = (10, 20)
t3 = t1 + t2
print(t3)  # (10, 20, 100, 200)
```

## 1.2 *

``` python
# 1. 字符串
print('-' * 10)  # ----------

# 2. 列表
list1 = ['hello']
print(list1 * 4)  # ['hello', 'hello', 'hello', 'hello']

# 3. 元组
t1 = ('world',)
print(t1 * 4)  # ('world', 'world', 'world', 'world')
```

## 1.3 in或not in

``` python
# 1. 字符串
print('a' in 'abcd')  # True
print('a' not in 'abcd')  # False

# 2. 列表
list1 = ['a', 'b', 'c', 'd']
print('a' in list1)  # True
print('a' not in list1)  # False

# 3. 元组
t1 = ('a', 'b', 'c', 'd')
print('aa' in t1)  # False
print('aa' not in t1)  # True
```



## 2.1 len()

``` python
# 1. 字符串
str1 = 'abcdefg'
print(len(str1))  # 7

# 2. 列表
list1 = [10, 20, 30, 40]
print(len(list1))  # 4

# 3. 元组
t1 = (10, 20, 30, 40, 50)
print(len(t1))  # 5

# 4. 集合
s1 = {10, 20, 30}
print(len(s1))  # 3

# 5. 字典
dict1 = {'name': 'Rose', 'age': 18}
print(len(dict1))  # 2
```

## 2.2 del()

``` python
# 1. 字符串
str1 = 'abcdefg'
del str1
print(str1)

# 2. 列表
list1 = [10, 20, 30, 40]
del(list1[0])
print(list1)  # [20, 30, 40]
```

## 2.3 max()

``` python
# 1. 字符串
str1 = 'abcdefg'
print(max(str1))  # g

# 2. 列表
list1 = [10, 20, 30, 40]
print(max(list1))  # 40
```

## 2.4 min()

``` python
# 1. 字符串
str1 = 'abcdefg'
print(min(str1))  # a

# 2. 列表
list1 = [10, 20, 30, 40]
print(min(list1))  # 10
```

## 2.5 range()

``` python
# 1 2 3 4 5 6 7 8 9
for i in range(1, 10, 1):
    print(i)

# 1 3 5 7 9
for i in range(1, 10, 2):
    print(i)

# 0 1 2 3 4 5 6 7 8 9
for i in range(10):
    print(i)
```

> 注意：range()生成的序列不包含end数字。

## 2.6 enumerate()

- 语法

``` python
enumerate(可遍历对象, start=0)
```

> 注意：start参数用来设置遍历数据的下标的起始值，默认为0。

- 快速体验

``` python
list1 = ['a', 'b', 'c', 'd', 'e']

for i in enumerate(list1):
    print(i)

for index, char in enumerate(list1, start=1):
    print(f'下标是{index}, 对应的字符是{char}')
```

![image-20190213115919040](%E5%88%B7%E9%A2%98.assets/image-20190213115919040.png)



# 三. 容器类型转换

## 3.1 tuple()

作用：将某个序列转换成元组

``` python
list1 = [10, 20, 30, 40, 50, 20]
s1 = {100, 200, 300, 400, 500}

print(tuple(list1))
print(tuple(s1))
```



## 3.2 list()

作用：将某个序列转换成列表

``` python
t1 = ('a', 'b', 'c', 'd', 'e')
s1 = {100, 200, 300, 400, 500}

print(list(t1))
print(list(s1))
```



## 3.3 set()

作用：将某个序列转换成集合

``` python
list1 = [10, 20, 30, 40, 50, 20]
t1 = ('a', 'b', 'c', 'd', 'e')

print(set(list1))
print(set(t1))
```

> 注意：

 	1. 集合可以快速完成列表去重
 	2. 集合不支持下标



# 四. 总结

- 运算符
  - +
  - in / not in
- 公共方法
  - len()
  - del()
  - range()
  - enumerate()
- 数据类型转换
  - tuple()
  - list()
  - set()

# 课程：推导式

# 目标

- 列表推导式
- 字典推导式
- 集合推导式

# 一. 列表推导式

作用：用一个表达式创建一个有规律的列表或控制一个有规律列表。

列表推导式又叫列表生成式。

## 1.1 快速体验

需求：创建一个0-10的列表。

- while循环实现

``` python
# 1. 准备一个空列表
list1 = []

# 2. 书写循环，依次追加数字到空列表list1中
i = 0
while i < 10:
    list1.append(i)
    i += 1

print(list1)
```

- for循环实现

``` python
list1 = []
for i in range(10):
    list1.append(i)

print(list1)
```

- 列表推导式实现

``` python 
list1 = [i for i in range(10)]
print(list1)
```

## 1.2 带if的列表推导式

需求：创建0-10的偶数列表

- 方法一：range()步长实现

``` python
list1 = [i for i in range(0, 10, 2)]
print(list1)
```

- 方法二：if实现

``` python
list1 = [i for i in range(10) if i % 2 == 0]
print(list1)
```

## 1.3 多个for循环实现列表推导式

需求：创建列表如下：

``` html
[(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

- 代码如下：

``` python
list1 = [(i, j) for i in range(1, 3) for j in range(3)]
print(list1)
```



# 二. 字典推导式

思考：如果有如下两个列表：

``` python
list1 = ['name', 'age', 'gender']
list2 = ['Tom', 20, 'man']
```

如何快速合并为一个字典？

答：字典推导式

字典推导式作用：快速合并列表为字典或提取字典中目标数据。

# 2.1 快速体验

1. 创建一个字典：字典key是1-5数字，value是这个数字的2次方。

``` python
dict1 = {i: i**2 for i in range(1, 5)}
print(dict1)  # {1: 1, 2: 4, 3: 9, 4: 16}
```



2. 将两个列表合并为一个字典

``` python 
list1 = ['name', 'age', 'gender']
list2 = ['Tom', 20, 'man']

dict1 = {list1[i]: list2[i] for i in range(len(list1))}
print(dict1)
```

3. 提取字典中目标数据

``` python
counts = {'MBP': 268, 'HP': 125, 'DELL': 201, 'Lenovo': 199, 'acer': 99}

# 需求：提取上述电脑数量大于等于200的字典数据
count1 = {key: value for key, value in counts.items() if value >= 200}
print(count1)  # {'MBP': 268, 'DELL': 201}
```



# 三. 集合推导式

需求：创建一个集合，数据为下方列表的2次方。

``` python
list1 = [1, 1, 2]
```

代码如下：

``` python
list1 = [1, 1, 2]
set1 = {i ** 2 for i in list1}
print(set1)  # {1, 4}
```

> 注意：集合有数据去重功能。



# 四. 总结

- 推导式的作用：简化代码
- 推导式写法

``` python
# 列表推导式
[xx for xx in range()]

# 字典推导式
{xx1: xx2 for ... in ...}

# 集合推导式
{xx for xx in ...}
```



# 课程：函数

# 目标

- 函数的作用
- 函数的使用步骤
- 函数的参数作用
- 函数的返回值作用
- 函数的说明文档
- 函数嵌套

# 一. 函数的作用

需求：用户到ATM机取钱：

1. 输入密码后显示"选择功能"界面
2. 查询余额后显示"选择功能"界面
3. 取2000钱后显示"选择功能"界面

> 特点：显示“选择功能”界面需要重复输出给用户，怎么实现？

![image-20181231211912413](%E5%88%B7%E9%A2%98.assets/image-20181231211912413-6262352.png)

函数就是将==一段具有独立功能的代码块== 整合到一个整体并命名，在需要的位置==调用这个名称==即可完成对应的需求。

> 函数在开发过程中，可以更高效的实现==代码重用==。



# 二. 函数的使用步骤

## 2.1 定义函数

``` python
def 函数名(参数):
    代码1
    代码2
    ......
```



## 2.2 调用函数

``` python
函数名(参数)
```

> 注意：

 	1. 不同的需求，参数可有可无。
 	2. 在Python中，函数必须==先定义后使用==。



## 2.3 快速体验

需求：复现ATM取钱功能。

1. 搭建整体框架(复现需求)

```python
print('密码正确登录成功')

# 显示"选择功能"界面

print('查询余额完毕')

# 显示"选择功能"界面

print('取了2000元钱')

# 显示"选择功能"界面
```

2. 确定“选择功能”界面内容

```python
print('查询余额')
print('存款')
print('取款')
```

3. 封装"选择功能"

> 注意：一定是先定义函数，后调用函数。

```python
# 封装ATM机功能选项 -- 定义函数
def select_func():
    print('-----请选择功能-----')
    print('查询余额')
    print('存款')
    print('取款')
    print('-----请选择功能-----')
```

4. 调用函数

在需要显示“选择功能”函数的位置调用函数。

```python
print('密码正确登录成功')
# 显示"选择功能"界面 -- 调用函数
select_func()

print('查询余额完毕')
# 显示"选择功能"界面 -- 调用函数
select_func()

print('取了2000元钱')
# 显示"选择功能"界面 -- 调用函数
select_func()
```



# 三.函数的参数作用

思考：完成需求如下：一个函数完成两个数1和2的加法运算，如何书写程序？

``` python 
# 定义函数
def add_num1():
    result = 1 + 2
    print(result)


# 调用函数
add_num1()
```

思考：上述add_num1函数只能完成数字1和2的加法运算，如果想要这个函数变得更灵活，可以计算任何用户指定的两个数字的和，如何书写程序？

分析：用户要在调用函数的时候指定具体数字，那么在定义函数的时候就需要接收用户指定的数字。函数调用时候指定的数字和定义函数时候接收的数字即是函数的参数。

``` python
# 定义函数时同时定义了接收用户数据的参数a和b，a和b是形参
def add_num2(a, b):
    result = a + b
    print(result)


# 调用函数时传入了真实的数据10 和 20，真实数据为实参
add_num2(10, 20)
```



# 四.函数的返回值作用

例如：我们去超市购物，比如买烟，给钱之后，是不是售货员会返回给我们烟这个商品，在函数中，如果需要返回结果给用户需要使用函数返回值。

``` python
def buy():
    return '烟'

# 使用变量保存函数返回值
goods = buy()
print(goods)
```

## 4.1 应用

需求：制作一个计算器，计算任意两数字之和，并保存结果。

``` python
def sum_num(a, b):
    return a + b


# 用result变量保存函数返回值
result = sum_num(1, 2)
print(result)
```



# 五.函数的说明文档

思考：定义一个函数后，程序员如何书写程序能够快速提示这个函数的作用？

答：注释

思考：如果代码多，我们是不是需要在很多代码中找到这个函数定义的位置才能看到注释？如果想更方便的查看函数的作用怎么办？

答：函数的说明文档

> 函数的说明文档也叫函数的文档说明。

## 5.1 语法

- 定义函数的说明文档

``` python
def 函数名(参数):
    """ 说明文档的位置 """
    代码
    ......
```

- 查看函数的说明文档

``` python
help(函数名)
```

## 5.2 快速体验

``` python
def sum_num(a, b):
    """ 求和函数 """
    return a + b


help(sum_num)
```

![image-20190219112749727](%E5%88%B7%E9%A2%98.assets/image-20190219112749727.png)



# 六.函数嵌套调用

所谓函数嵌套调用指的是==一个函数里面又调用了另外一个函数==。

- 示例

``` python
def testB():
    print('---- testB start----')
    print('这里是testB函数执行的代码...(省略)...')
    print('---- testB end----')

def testA():
    print('---- testA start----')
    testB()
    print('---- testA end----')

testA()
```

- 效果

![image-20190219113648783](%E5%88%B7%E9%A2%98.assets/image-20190219113648783.png)

- 执行流程

![image-20190219113648783](%E5%88%B7%E9%A2%98.assets/1.png)

> - 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置。

# 七. 函数应用

## 7.1 打印图形

1. 打印一条横线

``` python
def print_line():
    print('-' * 20)


print_line()
```

![image-20190219155107988](%E5%88%B7%E9%A2%98.assets/image-20190219155107988.png)

2. 打印多条横线

``` python 
def print_line():
    print('-' * 20)


def print_lines(num):
    i = 0
    while i < num:
        print_line()
        i += 1


print_lines(5)
```

![image-20190219155040124](%E5%88%B7%E9%A2%98.assets/image-20190219155040124.png)

## 7.2 函数计算

1. 求三个数之和

``` python
def sum_num(a, b, c):
    return a + b + c


result = sum_num(1, 2, 3)
print(result)  # 6
```



2. 求三个数平均值

``` python
def average_num(a, b, c):
    sumResult = sum_num(a, b, c)
    return sumResult / 3

result = average_num(1, 2, 3)
print(result)  # 2.0
```

# 八. 总结

- 函数的作用：封装代码，高效的代码重用

- 函数使用步骤

  - 定义函数

  ``` python
  def 函数名():
      代码1
      代码2
      ...
  ```

  - 调用函数

  ``` python
  函数名()
  ```

- 函数的参数：函数调用的时候可以传入真实数据，增大函数的使用的灵活性

  - 形参：函数定义时书写的参数(非真实数据)
  - 实参：函数调用时书写的参数(真实数据)

- 函数的返回值

  - 作用：函数调用后，返回需要的计算结果
  - 写法

  ``` python
  return 表达式
  ```

- 函数的说明文档

  - 作用：保存函数解释说明的信息
  - 写法

  ``` python
  def 函数名():
      """ 函数说明文档 """
  ```

- 函数嵌套调用：一个函数内部嵌套调用另外一个函数

# 课程：函数

# 目标

- 变量作用域
- 多函数程序执行流程
- 函数的返回值
- 函数的参数
- 拆包和交换两个变量的值
- 引用
- 可变和不可变类型

# 一. 变量作用域g

变量作用域指的是变量生效的范围，主要分为两类：==局部变量==和==全局变量==。

- 局部变量

所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效。

``` python
def testA():
    a = 100

    print(a)


testA()  # 100
print(a)  # 报错：name 'a' is not defined
```

> 变量a是定义在`testA`函数内部的变量，在函数外部访问则立即报错。

局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。

- 全局变量

所谓全局变量，指的是在函数体内、外都能生效的变量。

思考：如果有一个数据，在函数A和函数B中都要使用，该怎么办？

答：将这个数据存储在一个全局变量里面。

``` python
# 定义全局变量a
a = 100


def testA():
    print(a)  # 访问全局变量a，并打印变量a存储的数据


def testB():
    print(a)  # 访问全局变量a，并打印变量a存储的数据


testA()  # 100
testB()  # 100
```

思考：`testB`函数需求修改变量a的值为200，如何修改程序？

``` python
a = 100


def testA():
    print(a)


def testB():
    a = 200
    print(a)


testA()  # 100
testB()  # 200
print(f'全局变量a = {a}')  # 全局变量a = 100
```

思考：在`testB`函数内部的`a = 200`中的变量a是在修改全局变量`a`吗？

答：不是。观察上述代码发现，15行得到a的数据是100，仍然是定义全局变量a时候的值，而没有返回

`testB`函数内部的200。综上：`testB`函数内部的`a = 200`是定义了一个局部变量。

思考：如何在函数体内部修改全局变量？

``` python 
a = 100


def testA():
    print(a)


def testB():
    # global 关键字声明a是全局变量
    global a
    a = 200
    print(a)


testA()  # 100
testB()  # 200
print(f'全局变量a = {a}')  # 全局变量a = 200
```

# 二. 多函数程序执行流程

一般在实际开发过程中，一个程序往往由多个函数（后面知识中会讲解类）组成，并且多个函数共享某些数据，如下所示：

- 共用全局变量

``` python
# 1. 定义全局变量
glo_num = 0


def test1():
    global glo_num
    # 修改全局变量
    glo_num = 100


def test2():
    # 调用test1函数中修改后的全局变量
    print(glo_num)
    

# 2. 调用test1函数，执行函数内部代码：声明和修改全局变量
test1()
# 3. 调用test2函数，执行函数内部代码：打印
test2()  # 100
```

- 返回值作为参数传递

``` python
def test1():
    return 50


def test2(num):
    print(num)


# 1. 保存函数test1的返回值
result = test1()


# 2.将函数返回值所在变量作为参数传递到test2函数
test2(result)  # 50
```

# 三. 函数的返回值

思考：如果一个函数如些两个return (如下所示)，程序如何执行？

``` python 
def return_num():
    return 1
    return 2


result = return_num()
print(result)  # 1
```

答：只执行了第一个return，原因是因为return可以退出当前函数，导致return下方的代码不执行。

思考：如果一个函数要有多个返回值，该如何书写代码？

``` python
def return_num():
    return 1, 2


result = return_num()
print(result)  # (1, 2)
```

> 注意：
>
> 1. `return a, b`写法，返回多个数据的时候，默认是元组类型。
> 2. return后面可以连接列表、元组或字典，以返回多个值。



# 四. 函数的参数

## 4.1 位置参数

位置参数：调用函数时根据函数定义的参数位置来传递参数。

``` python
def user_info(name, age, gender):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')


user_info('TOM', 20, '男')
```

> 注意：传递和定义参数的顺序及个数必须一致。



## 4.2 关键字参数

函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。

``` python
def user_info(name, age, gender):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')


user_info('Rose', age=20, gender='女')
user_info('小明', gender='男', age=16)
```

注意：**函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。**



## 4.3 缺省参数

缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。

``` python
def user_info(name, age, gender='男'):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')


user_info('TOM', 20)
user_info('Rose', 18, '女')
```

> 注意：函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。

## 4.4 不定长参数

不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。

- 包裹位置传递

``` python
def user_info(*args):
    print(args)


# ('TOM',)
user_info('TOM')
# ('TOM', 18)
user_info('TOM', 18)
```

> 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。

- 包裹关键字传递

``` python
def user_info(**kwargs):
    print(kwargs)


# {'name': 'TOM', 'age': 18, 'id': 110}
user_info(name='TOM', age=18, id=110)
```

> 综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。



# 五. 拆包和交换变量值

## 5.1 拆包

- 拆包：元组

``` python
def return_num():
    return 100, 200


num1, num2 = return_num()
print(num1)  # 100
print(num2)  # 200
```

- 拆包：字典

``` python
dict1 = {'name': 'TOM', 'age': 18}
a, b = dict1

# 对字典进行拆包，取出来的是字典的key
print(a)  # name
print(b)  # age

print(dict1[a])  # TOM
print(dict1[b])  # 18
```



## 5.2 交换变量值

需求：有变量`a = 10`和`b = 20`，交换两个变量的值。

- 方法一

借助第三变量存储数据。

``` python
# 1. 定义中间变量
c = 0

# 2. 将a的数据存储到c
c = a

# 3. 将b的数据20赋值到a，此时a = 20
a = b

# 4. 将之前c的数据10赋值到b，此时b = 10
b = c

print(a)  # 20
print(b)  # 10
```

- 方法二

``` python
a, b = 1, 2
a, b = b, a
print(a)  # 2
print(b)  # 1
```

# 六. 引用

## 6.1 了解引用

在python中，值是靠引用来传递来的。

**我们可以用`id()`来判断两个变量是否为同一个值的引用。** 我们可以将id值理解为那块内存的地址标识。

``` python
# 1. int类型
a = 1
b = a

print(b)  # 1

print(id(a))  # 140708464157520
print(id(b))  # 140708464157520

a = 2
print(b)  # 1,说明int类型为不可变类型 

print(id(a))  # 140708464157552，此时得到是的数据2的内存地址
print(id(b))  # 140708464157520


# 2. 列表
aa = [10, 20]
bb = aa

print(id(aa))  # 2325297783432
print(id(bb))  # 2325297783432


aa.append(30)
print(bb)  # [10, 20, 30], 列表为可变类型

print(id(aa))  # 2325297783432
print(id(bb))  # 2325297783432
```

## 6.2 引用当做实参

代码如下：

``` python
def test1(a):
    print(a)
    print(id(a))

    a += a

    print(a)
    print(id(a))


# int：计算前后id值不同
b = 100
test1(b)

# 列表：计算前后id值相同
c = [11, 22]
test1(c)
```

效果图如下：

![image-20190220111744493](%E5%88%B7%E9%A2%98.assets/image-20190220111744493.png)

# 七. 可变和不可变类型

所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变.

- 可变类型
  - 列表
  - 字典
  - 集合
- 不可变类型
  - 整型
  - 浮点型
  - 字符串
  - 元组



# 八. 总结

- 变量作用域
  - 全局：函数体内外都能生效
  - 局部：当前函数体内部生效
- 函数多返回值写法

``` python
return 表达式1, 表达式2...
```

- 函数的参数
  - 位置参数
    - 形参和实参的个数和书写顺序必须一致
  - 关键字参数
    - 写法： `key=value`
    - 特点：形参和实参的书写顺序可以不一致；关键字参数必须书写在位置参数的后面
  - 缺省参数
    - 缺省参数就是默认参数
    - 写法：`key=vlaue`
  - 不定长位置参数
    - 收集所有位置参数，返回一个元组
  - 不定长关键字参数
    - 收集所有关键字参数，返回一个字典
- 引用：Python中，数据的传递都是通过引用

# 课程：函数加强

# 目标

- 应用：学员管理系统
- 递归
- lambda 表达式
- 高阶函数

# 一. 应用：学员管理系统

## 1.1 系统简介

需求：进入系统显示系统功能界面，功能如下：

- 1、添加学员
- 2、删除学员
- 3、修改学员信息
- 4、查询学员信息
- 5、显示所有学员信息
- 6、退出系统

系统共6个功能，用户根据自己需求选取。



## 1.2 步骤分析

1. 显示功能界面

2. 用户输入功能序号

3. 根据用户输入的功能序号，执行不同的功能(函数)

   3.1 定义函数

   3.2 调用函数



## 1.3 需求实现

### 1.3.1 显示功能界面

定义函数`print_info`，负责显示系统功能。

``` python
def print_info():
    print('-' * 20)
    print('欢迎登录学员管理系统')
    print('1: 添加学员')
    print('2: 删除学员')
    print('3: 修改学员信息')
    print('4: 查询学员信息')
    print('5: 显示所有学员信息')
    print('6: 退出系统')
    print('-' * 20)
    
    
print_info()
```

### 1.3.2 用户输入序号，选择功能

``` python
user_num = input('请选择您需要的功能序号：')
```

### 1.3.3 根据用户选择，执行不同的功能

``` python
if user_num == '1':
    print('添加学员')
elif user_num == '2':
    print('删除学员')
elif user_num == '3':
    print('修改学员信息')
elif user_num == '4':
    print('查询学员信息')
elif user_num == '5':
    print('显示所有学员信息')
elif user_num == '6':
    print('退出系统')
```

> 工作中，需要根据实际需求调优代码。
>
> 1. 用户选择系统功能的代码需要循环使用，直到用户主动退出系统。
> 2. 如果用户输入1-6以外的数字，需要提示用户。

``` python
while True:
    # 1. 显示功能界面
    print_info()
    
    # 2. 用户选择功能
    user_num = input('请选择您需要的功能序号：')

    # 3. 根据用户选择，执行不同的功能
    if user_num == '1':
        print('添加学员')
    elif user_num == '2':
        print('删除学员')
    elif user_num == '3':
        print('修改学员信息')
    elif user_num == '4':
        print('查询学员信息')
    elif user_num == '5':
        print('显示所有学员信息')
    elif user_num == '6':
        print('退出系统')
    else:
        print('输入错误，请重新输入!!!')
```

### 1.3.4 定义不同功能的函数

所有功能函数都是操作学员信息，所有存储所有学员信息应该是一个==全局变量==，数据类型为==列表==。

``` python
info = []
```



#### 1.3.4.1 添加学员

- 需求分析

1. 接收用户输入学员信息，并保存

2. 判断是否添加学员信息

   2.1 如果学员姓名已经存在，则报错提示

   2.2 如果学员姓名不存在，则准备空字典，将用户输入的数据追加到字典，再列表追加字典数据

3. 对应的if条件成立的位置调用该函数

- 代码实现

``` python
def add_info():
    """ 添加学员 """
    # 接收用户输入学员信息
    new_id = input('请输入学号：')
    new_name = input('请输入姓名：')
    new_tel = input('请输入手机号：')
    

    # 声明info是全局变量
    global info

    # 检测用户输入的姓名是否存在，存在则报错提示
    for i in info:
        if new_name == i['name']:
            print('该用户已经存在！')
            return

    # 如果用户输入的姓名不存在，则添加该学员信息
    info_dict = {}
    
    # 将用户输入的数据追加到字典
    info_dict['id'] = new_id
    info_dict['name'] = new_name
    info_dict['tel'] = new_tel
    
    # 将这个学员的字典数据追加到列表
    info.append(info_dict)
    
    print(info)
```

#### 1.3.4.2 删除学员

- 需求分析

按用户输入的学员姓名进行删除

 1. 用户输入目标学员姓名

 2. 检查这个学员是否存在

    2.1 如果存在，则列表删除这个数据

    2.2 如果不存在，则提示“该用户不存在”

3. 对应的if条件成立的位置调用该函数

- 代码实现

``` python
# 删除学员
def del_info():
    """删除学员"""
    # 1. 用户输入要删除的学员的姓名
    del_name = input('请输入要删除的学员的姓名：')

    global info
    # 2. 判断学员是否存在:如果输入的姓名存在则删除，否则报错提示
    for i in info:
        if del_name == i['name']:
            info.remove(i)
            break
    else:
        print('该学员不存在')

    print(info)
```

#### 1.3.4.3 修改学员信息

- 需求分析

1. 用户输入目标学员姓名

2. 检查这个学员是否存在

   2.1 如果存在，则修改这位学员的信息，例如手机号

   2.2 如果不存在，则报错

3. 对应的if条件成立的位置调用该函数

- 代码实现

``` python
# 修改函数
def modify_info():
    """修改函数"""
    # 1. 用户输入要修改的学员的姓名
    modify_name = input('请输入要修改的学员的姓名：')

    global info
    # 2. 判断学员是否存在：如果输入的姓名存在则修改手机号，否则报错提示
    for i in info:
        if modify_name == i ['name']:
            i['tel'] = input('请输入新的手机号：')
            break
    else:
        print('该学员不存在')
    
    print(info)
```



#### 1.3.4.4 查询学员信息

- 需求分析

1. 用户输入目标学员姓名

2. 检查学员是否存在

   2.1 如果存在，则显示这个学员的信息

   2.2 如果不存在，则报错提示

3. 对应的if条件成立的位置调用该函数

- 代码实现

``` python
# 查询学员
def search_info():
    """查询学员"""
    # 1. 输入要查找的学员姓名：
    search_name = input('请输入要查找的学员姓名：')

    global info
    # 2. 判断学员是否存在：如果输入的姓名存在则显示这位学员信息，否则报错提示
    for i in info:
        if search_name == i['name']:
            print('查找到的学员信息如下：----------')
            print(f"该学员的学号是{i['id']}, 姓名是{i['name']}, 手机号是{i['tel']}")
            break
    else:
        print('该学员不存在')
```



#### 1.3.4.5 显示所有学员信息

- 需求分析

打印所有学员信息

- 代码实现

``` python
# 显示所有学员信息
def print_all():
    """ 显示所有学员信息 """
    print('学号\t姓名\t手机号')
    for i in info:
        print(f'{i["id"]}\t{i["name"]}\t{i["tel"]}')
```



#### 1.3.4.6 退出系统

在用户输入功能序号`6`的时候要退出系统，代码如下：

``` python
    ......
    elif user_num == '6':
        exit_flag = input('确定要退出吗？yes or no')
        if exit_flag == 'yes':
            break
```

# 二. 递归

## 2.1 递归的应用场景

递归是一种编程思想，应用场景：

1. 在我们日常开发中，如果要遍历一个文件夹下面所有的文件，通常会使用递归来实现；
2. 在后续的算法课程中，很多算法都离不开递归，例如：快速排序。

### 2.1.1 递归的特点

- 函数内部自己调用自己
- 必须有出口



## 2.2 应用：3以内数字累加和

- 代码

```python
# 3 + 2 + 1
def sum_numbers(num):
    # 1.如果是1，直接返回1 -- 出口
    if num == 1:
        return 1
    # 2.如果不是1，重复执行累加并返回结果
    return num + sum_numbers(num-1)


sum_result = sum_numbers(3)
# 输出结果为6
print(sum_result)
```

- 执行结果

![image-20181229145115121](%E5%88%B7%E9%A2%98.assets/1-16624722079392.png)

# 三. lambda 表达式

## 3.1 lambda的应用场景

如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化。



## 3.2 lambda语法

```python
lambda 参数列表 ： 表达式
```

> 注意

- lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。
- lambda表达式能接收任何数量的参数但只能返回一个表达式的值。

### 快速入门

```python
# 函数
def fn1():
    return 200


print(fn1)
print(fn1())


# lambda表达式
fn2 = lambda: 100
print(fn2)
print(fn2())
```

> 注意：直接打印lambda表达式，输出的是此lambda的内存地址



## 3.3 示例：计算a + b

### 3.3.1 函数实现

```python
def add(a, b):
    return a + b


result = add(1, 2)
print(result)
```

> 思考：需求简单，是否代码多？

### 3.3.2 lambda实现

```python
fn1 = lambda a, b: a + b
print(fn1(1, 2))
```



## 3.4 lambda的参数形式

### 3.4.1.无参数

```python
fn1 = lambda: 100
print(fn1())
```

### 3.4.2.一个参数

```python
fn1 = lambda a: a
print(fn1('hello world'))
```

### 3.4.3.默认参数

```python
fn1 = lambda a, b, c=100: a + b + c
print(fn1(10, 20))
```

### 3.4.4.可变参数：*args

```python
fn1 = lambda *args: args
print(fn1(10, 20, 30))
```

> 注意：这里的可变参数传入到lambda之后，返回值为元组。

### 3.4.5.可变参数：**kwargs

```python
fn1 = lambda **kwargs: kwargs
print(fn1(name='python', age=20))
```



## 3.5 lambda的应用

### 3.5.1. 带判断的lambda

```python
fn1 = lambda a, b: a if a > b else b
print(fn1(1000, 500))
```

### 3.5.2. 列表数据按字典key的值排序

```python
students = [
    {'name': 'TOM', 'age': 20},
    {'name': 'ROSE', 'age': 19},
    {'name': 'Jack', 'age': 22}
]

# 按name值升序排列
students.sort(key=lambda x: x['name'])
print(students)

# 按name值降序排列
students.sort(key=lambda x: x['name'], reverse=True)
print(students)

# 按age值升序排列
students.sort(key=lambda x: x['age'])
print(students)
```



# 四. 高阶函数

==把函数作为参数传入==，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。

## 4.1 体验高阶函数

在Python中，`abs()`函数可以完成对数字求绝对值计算。

``` python
abs(-10)  # 10
```

`round()`函数可以完成对数字的四舍五入计算。

``` python
round(1.2)  # 1
round(1.9)  # 2
```

需求：任意两个数字，按照指定要求整理数字后再进行求和计算。

- 方法1

``` python
def add_num(a, b):
    return abs(a) + abs(b)


result = add_num(-1, 2)
print(result)  # 3
```

- 方法2

``` python
def sum_num(a, b, f):
    return f(a) + f(b)


result = sum_num(-1, 2, abs)
print(result)  # 3
```

> 注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。

函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。



## 4.2 内置高阶函数

### 4.2.1 map()

map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。

需求：计算`list1`序列中各个数字的2次方。

``` python
list1 = [1, 2, 3, 4, 5]


def func(x):
    return x ** 2


result = map(func, list1)

print(result)  # <map object at 0x0000013769653198>
print(list(result))  # [1, 4, 9, 16, 25]

####注意map函数返回的是map对象 并不是list不能拿来直接用需要list（xxx）一下



```



### 4.2.2 reduce()

reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。

> 注意：reduce()传入的参数func必须接收2个参数。

需求：计算`list1`序列中各个数字的累加和。

``` python
import functools

list1 = [1, 2, 3, 4, 5]


def func(a, b):
    return a + b


result = functools.reduce(func, list1)

print(result)  # 15
```



### 4.2.3 filter()

filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。

``` python
list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


def func(x):
    return x % 2 == 0


result = filter(func, list1)

print(result)  # <filter object at 0x0000017AF9DC3198>
print(list(result))  # [2, 4, 6, 8, 10]
```



# 五. 总结

- 递归

  - 函数内部自己调用自己
  - 必须有出口

- lambda

  - 语法

  ``` python
  lambda 参数列表: 表达式
  ```

  - lambda的参数形式

    - 无参数

    ``` python
    lambda: 表达式
    ```

    - 一个参数

    ``` python
    lambda 参数: 表达式
    ```

    - 默认参数

    ``` python
    lambda key=value: 表达式
    ```

    - 不定长位置参数

    ``` python
    lambda *args: 表达式
    ```

    - 不定长关键字参数

    ``` python
    lambda **kwargs: 表达式
    ```

- 高阶函数

  - 作用：把函数作为参数传入，化简代码
  - 内置高阶函数
    - map()
    - reduce()
    - filter()

# 课程：文件操作

# 目标

- 文件操作的作用
- 文件的基本操作
  - 打开
  - 读写
  - 关闭
- 文件备份
- 文件和文件夹的操作



# 一. 文件操作的作用

思考：什么是文件？

![](%E5%88%B7%E9%A2%98.assets/1.jpg)

思考：文件操作包含什么？

答：打开、关闭、读、写、复制....

思考：文件操作的的作用是什么？

答：读取内容、写入内容、备份内容......

> 总结：文件操作的作用就是==把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力==。



# 二. 文件的基本操作

## 2.1 文件操作步骤

1. 打开文件
2. 读写等操作
3. 关闭文件

> 注意：可以只打开和关闭文件，不进行任何读写操作。

### 2.1.1  打开

在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：

``` python
open(name, mode)
```

name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。

mode：设置打开文件的模式(访问模式)：只读、写入、追加等。



#### 2.1.1.1 打开文件模式

| 模式 | 描述                                                         |
| :--: | ------------------------------------------------------------ |
|  r   | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
|  rb  | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 |
|  r+  | 打开一个文件用于读写。文件指针将会放在文件的开头。           |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 |
|  w   | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
|  wb  | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
|  w+  | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
|  a   | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
|  ab  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
|  a+  | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |



#### 2.1.1.2 快速体验

``` python
f = open('test.txt', 'w')
```

> 注意：此时的`f`是`open`函数的文件对象。

### 2.1.2 文件对象方法

##### 2.1.2.1 写

- 语法

``` python
对象对象.write('内容')
```

- 体验

``` python
# 1. 打开文件
f = open('test.txt', 'w')

# 2.文件写入
f.write('hello world')

# 3. 关闭文件
f.close()
```

> 注意：
>
> 1. `w	`和`a`模式：如果文件不存在则创建该文件；如果文件存在，`w`模式先清空再写入，`a`模式直接末尾追加。
> 2. `r`模式：如果文件不存在则报错。



##### 2.1.2.2 读

- read()

``` python
文件对象.read(num)
```

> num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。



- readlines()

readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。

``` python
f = open('test.txt')
content = f.readlines()

# ['hello world\n', 'abcdefg\n', 'aaa\n', 'bbb\n', 'ccc']
print(content)

# 关闭文件
f.close()
```



- readline()

readline()一次读取一行内容。

``` python
f = open('test.txt')

content = f.readline()
print(f'第一行：{content}')

content = f.readline()
print(f'第二行：{content}')

# 关闭文件
f.close()
```

![image-20190222105332438](%E5%88%B7%E9%A2%98.assets/image-20190222105332438.png)



##### 2.1.2.3 seek()

作用：用来移动文件指针。

语法如下：

``` python
文件对象.seek(偏移量, 起始位置)
```

> 起始位置：
>
> - 0：文件开头
> - 1：当前位置
> - 2：文件结尾



### 2.1.3 关闭

```open
文件对象.close()
```



# 三. 文件备份

需求：用户输入当前目录下任意文件名，程序完成对该文件的备份功能(备份文件名为xx[备份]后缀，例如：test[备份].txt)。

## 3.1 步骤

1. 接收用户输入的文件名
2. 规划备份文件名
3. 备份文件写入数据

## 3.2 代码实现

1. 接收用户输入目标文件名

``` python
old_name = input('请输入您要备份的文件名：')
```



2. 规划备份文件名

   2.1 提取目标文件后缀

   2.2 组织备份的文件名，xx[备份]后缀

> ``` python
> # 2.1 提取文件后缀点的下标
> index = old_name.rfind('.')
> 
> # print(index)  # 后缀中.的下标
> 
> # print(old_name[:index])  # 源文件名（无后缀）
> 
> # 2.2 组织新文件名 旧文件名 + [备份] + 后缀
> new_name = old_name[:index] + '[备份]' + old_name[index:]
> 
> # 打印新文件名（带后缀）
> # print(new_name)
> ```

3. 备份文件写入数据

   3.1 打开源文件 和 备份文件

   3.2 将源文件数据写入备份文件

   3.3 关闭文件

``` python
# 3.1 打开文件
old_f = open(old_name, 'rb')
new_f = open(new_name, 'wb')

# 3.2 将源文件数据写入备份文件
while True:
    con = old_f.read(1024)
    if len(con) == 0:
        break
    new_f.write(con)

# 3.3 关闭文件
old_f.close()
new_f.close()
```



## 3.3 思考

如果用户输入`.txt`，这是一个无效文件，程序如何更改才能限制只有有效的文件名才能备份？

答：添加条件判断即可。

``` python
old_name = input('请输入您要备份的文件名：')

index = old_name.rfind('.')


if index > 0:
    postfix = old_name[index:]

new_name = old_name[:index] + '[备份]' + postfix

old_f = open(old_name, 'rb')
new_f = open(new_name, 'wb')

while True:
    con = old_f.read(1024)
    if len(con) == 0:
        break
    new_f.write(con)

old_f.close()
new_f.close()
```



# 四. 文件和文件夹的操作

在Python中文件和文件夹的操作要借助os模块里面的相关功能，具体步骤如下：

1. 导入os模块

``` python
import os
```

2. 使用`os`模块相关功能

``` python
os.函数名()
```

## 4.1 文件重命名

``` python
os.rename(目标文件名, 新文件名)
```



## 4.2 删除文件

``` python
os.remove(目标文件名)
```



## 4.3 创建文件夹

``` python
os.mkdir(文件夹名字)
```



## 4.4 删除文件夹

``` python
os.rmdir(文件夹名字)
```



## 4.5 获取当前目录

``` python
os.getcwd()
```



## 4.6 改变默认目录

``` python
os.chdir(目录)
```



## 4.7 获取目录列表

``` python
os.listdir(目录)
```



# 五.应用案例

需求：批量修改文件名，既可添加指定字符串，又能删除指定字符串。

- 步骤

1. 设置添加删除字符串的的标识
2. 获取指定目录的所有文件
3. 将原有文件名添加/删除指定字符串，构造新名字
4. os.rename()重命名



- 代码

``` python
import os

# 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符
flag = 1

# 获取指定目录
dir_name = './'

# 获取指定目录的文件列表
file_list = os.listdir(dir_name)
# print(file_list)


# 遍历文件列表内的文件
for name in file_list:

    # 添加指定字符
    if flag == 1:
        new_name = 'Python-' + name
    # 删除指定字符
    elif flag == 2:
        num = len('Python-')
        new_name = name[num:]

    # 打印新文件名，测试程序正确性
    print(new_name)
    
    # 重命名
    os.rename(dir_name+name, dir_name+new_name)
```



# 六. 总结

- 文件操作步骤

  - 打开

  ``` python
  文件对象 = open(目标文件, 访问模式)
  ```

  - 操作

    - 读

    ``` python
    文件对象.read()
    文件对象.readlines()
    文件对象.readline()
    ```

    - 写

    ``` python
    文件对象.write()
    ```

    - seek()

  - 关闭

  ``` python
  文件对象.close()
  ```


- 主访问模式
  - w：写，文件不存在则新建该文件
  - r：读，文件不存在则报错
  - a：追加

- 文件和文件夹操作
  - 重命名：os.rename()
  - 获取当前目录：os.getcwd()
  - 获取目录列表：os.listdir()

# 面向对象基础

# 目标

- 理解面向对象
- 类和对象
- 添加和获取对象属性
- 魔法方法



# 一. 理解面向对象

面向对象是一种抽象化的编程思想，很多编程语言中都有的一种思想。

例如：洗衣服

思考：几种途径可以完成洗衣服？

答： 手洗 和 机洗。

手洗：找盆 - 放水 - 加洗衣粉 - 浸泡 - 搓洗 - 拧干水 - 倒水 - 漂洗N次 - 拧干 - 晾晒。

机洗：打开洗衣机 - 放衣服 - 加洗衣粉 - 按下开始按钮 - 晾晒。

思考：对比两种洗衣服途径，同学们发现了什么？

答：机洗更简单

思考：机洗，只需要找到一台洗衣机，加入简单操作就可以完成洗衣服的工作，而不需要关心洗衣机内部发生了什么事情。

> 总结：==面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。==



# 二. 类和对象

思考：洗衣机洗衣服描述过程中，洗衣机其实就是一个事物，即对象，洗衣机对象哪来的呢？

答：洗衣机是由工厂工人制作出来。

思考：工厂工人怎么制作出的洗衣机？

答：工人根据设计师设计的功能图纸制作洗衣机。

总结：图纸  → 洗衣机 → 洗衣服。

在面向对象编程过程中，有两个重要组成部分：==类== 和 ==对象==。

==类和对象的关系：用类去创建一个对象。==

## 2.1 理解类和对象

### 2.1.1 类

类是对一系列具有相同==特征==和==行为==的事物的统称，是一个==抽象的概念==，不是真实存在的事物。

- 特征即是属性
- 行为即是方法

类比如是制造洗衣机时要用到的图纸，也就是说==类是用来创建对象==。

![image-20190222154356953](%E5%88%B7%E9%A2%98.assets/image-20190222154356953.png)



### 2.1.2 对象

对象是类创建出来的真实存在的事物，例如：洗衣机。

> 注意：开发中，先有类，再有对象。

![image-20190222154727379](%E5%88%B7%E9%A2%98.assets/image-20190222154727379.png)





## 2.2 面向对象实现方法

### 2.2.1 定义类

Python2中类分为：经典类 和 新式类

- 语法

```python
class 类名():
    代码
    ......
```

> 注意：类名要满足标识符命名规则，同时遵循==大驼峰命名习惯==。

- 体验

``` python
class Washer():
    def wash(self):
        print('我会洗衣服')
```

- 拓展：经典类

不由任意内置类型派生出的类，称之为经典类

``` python
class 类名:
    代码
    ......
```





### 2.2.2 创建对象

对象又名实例。

- 语法

``` python
对象名 = 类名()
```

- 体验

``` python
# 创建对象
haier1 = Washer()

# <__main__.Washer object at 0x0000018B7B224240>
print(haier1)

# haier对象调用实例方法
haier1.wash()
```

> 注意：创建对象的过程也叫实例化对象。

### 2.2.3 self

self指的是调用该函数的对象。

``` python
# 1. 定义类
class Washer():
    def wash(self):
        print('我会洗衣服')
        # <__main__.Washer object at 0x0000024BA2B34240>
        print(self)


# 2. 创建对象
haier1 = Washer()
# <__main__.Washer object at 0x0000018B7B224240>
print(haier1)
# haier1对象调用实例方法
haier1.wash()


haier2 = Washer()
# <__main__.Washer object at 0x0000022005857EF0>
print(haier2)
```

> 注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。



# 三. 添加和获取对象属性

属性即是特征，比如：洗衣机的宽度、高度、重量...

对象属性既可以在类外面添加和获取，也能在类里面添加和获取。

## 3.1 类外面添加对象属性

- 语法

``` python
对象名.属性名 = 值
```

- 体验

``` python
haier1.width = 500
haier1.height = 800
```



## 3.2 类外面获取对象属性

- 语法

``` python
对象名.属性名
```

- 体验

``` python
print(f'haier1洗衣机的宽度是{haier1.width}')
print(f'haier1洗衣机的高度是{haier1.height}')
```



## 3.3 类里面获取对象属性

- 语法

``` python
self.属性名
```

- 体验

``` python
# 定义类
class Washer():
    def print_info(self):
        # 类里面获取实例属性
        print(f'haier1洗衣机的宽度是{self.width}')
        print(f'haier1洗衣机的高度是{self.height}')

# 创建对象
haier1 = Washer()

# 添加实例属性
haier1.width = 500
haier1.height = 800

haier1.print_info()
```



# 四. 魔法方法

在Python中，`__xx__()`的函数叫做魔法方法，指的是具有特殊功能的函数。

## 4.1 `__init__()`

### 4.1.1 体验`__init__()`

思考：洗衣机的宽度高度是与生俱来的属性，可不可以在生产过程中就赋予这些属性呢？

答：理应如此。

==`__init__()`方法的作用：初始化对象。==

``` python
class Washer():
    
    # 定义初始化功能的函数
    def __init__(self):
        # 添加实例属性
        self.width = 500
        self.height = 800


    def print_info(self):
        # 类里面调用实例属性
        print(f'洗衣机的宽度是{self.width}, 高度是{self.height}')


haier1 = Washer()
haier1.print_info()
```

> 注意：
>
> - `__init__()`方法，在创建一个对象时默认被调用，不需要手动调用
> - `__init__(self)`中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。



### 4.1.2 带参数的`__init__()`

思考：一个类可以创建多个对象，如何对不同的对象设置不同的初始化属性呢？

答：传参数。

``` python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def print_info(self):
        print(f'洗衣机的宽度是{self.width}')
        print(f'洗衣机的高度是{self.height}')


haier1 = Washer(10, 20)
haier1.print_info()


haier2 = Washer(30, 40)
haier2.print_info()
```



## 4.2  `__str__()`

当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了`__str__`方法，那么就会打印从在这个方法中 return 的数据。

``` python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __str__(self):
        return '这是海尔洗衣机的说明书'


haier1 = Washer(10, 20)
# 这是海尔洗衣机的说明书
print(haier1)
```



## 4.3  `__del__()`

当删除对象时，python解释器也会默认调用`__del__()`方法。

``` python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __del__(self):
        print(f'{self}对象已经被删除')


haier1 = Washer(10, 20)

# <__main__.Washer object at 0x0000026118223278>对象已经被删除
del haier1
```



# 五. 综合应用

## 5.1 烤地瓜

### 5.1.1 需求

需求主线：

 1. 被烤的时间和对应的地瓜状态：

    0-3分钟：生的

    3-5分钟：半生不熟

    5-8分钟：熟的

    超过8分钟：烤糊了

    

 2. 添加的调料：

    用户可以按自己的意愿添加调料

    

### 5.1.2 步骤分析

需求涉及一个事物： 地瓜，故案例涉及一个类：地瓜类。

#### 5.1.2.1 定义类

- 地瓜的属性
  - 被烤的时间
  - 地瓜的状态
  - 添加的调料
- 地瓜的方法
  - 被烤
    - 用户根据意愿设定每次烤地瓜的时间
    - 判断地瓜被烤的总时间是在哪个区间，修改地瓜状态
  - 添加调料
    - 用户根据意愿设定添加的调料
    - 将用户添加的调料存储

- 显示对象信息



#### 5.1.2.2 创建对象，调用相关实例方法



### 5.1.3 代码实现

#### 5.1.3.1 定义类

- 地瓜属性
  - 定义地瓜初始化属性，后期根据程序推进更新实例属性

``` python
class SweetPotato():
    def __init__(self):
        # 被烤的时间
        self.cook_time = 0
        # 地瓜的状态
        self.cook_static = '生的'
        # 调料列表
        self.condiments = []
```



#### 5.1.3.2 定义烤地瓜方法

``` python
class SweetPotato():
    ......
    
    def cook(self, time):
        """烤地瓜的方法"""
        self.cook_time += time
        if 0 <= self.cook_time < 3:
            self.cook_static = '生的'
        elif 3 <= self.cook_time < 5:
            self.cook_static = '半生不熟'
        elif 5 <= self.cook_time < 8:
            self.cook_static = '熟了'
        elif self.cook_time >= 8:
            self.cook_static = '烤糊了'
```



#### 5.1.3.3 书写str魔法方法，用于输出对象状态

``` python
class SweetPotato():
		......

    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}'

```



#### 5.1.3.4  创建对象，测试实例属性和实例方法

``` python 
digua1 = SweetPotato()
print(digua1)
digua1.cook(2)
print(digua1)
```



#### 5.1.3.5 定义添加调料方法，并调用该实例方法

``` python
class SweetPotato():
		......

    def add_condiments(self, condiment):
        """添加调料"""
        self.condiments.append(condiment)
    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'
      

digua1 = SweetPotato()
print(digua1)

digua1.cook(2)
digua1.add_condiments('酱油')
print(digua1)

digua1.cook(2)
digua1.add_condiments('辣椒面儿')
print(digua1)

digua1.cook(2)
print(digua1)

digua1.cook(2)
print(digua1)
```



### 5.1.4 代码总览

``` python
# 定义类
class SweetPotato():
    def __init__(self):
        # 被烤的时间
        self.cook_time = 0
        # 地瓜的状态
        self.cook_static = '生的'
        # 调料列表
        self.condiments = []

    def cook(self, time):
        """烤地瓜的方法"""
        self.cook_time += time
        if 0 <= self.cook_time < 3:
            self.cook_static = '生的'
        elif 3 <= self.cook_time < 5:
            self.cook_static = '半生不熟'
        elif 5 <= self.cook_time < 8:
            self.cook_static = '熟了'
        elif self.cook_time >= 8:
            self.cook_static = '烤糊了'

    def add_condiments(self, condiment):
        """添加调料"""
        self.condiments.append(condiment)

    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'


digua1 = SweetPotato()
print(digua1)

digua1.cook(2)
digua1.add_condiments('酱油')
print(digua1)

digua1.cook(2)
digua1.add_condiments('辣椒面儿')
print(digua1)

digua1.cook(2)
print(digua1)

digua1.cook(2)
print(digua1)
```



## 5.2 搬家具

### 5.2.1 需求

将小于房子剩余面积的家具摆放到房子中



### 5.2.2 步骤分析

需求涉及两个事物：房子 和 家具，故被案例涉及两个类：房子类 和 家具类。

#### 5.2.2.1 定义类

- 房子类
  - 实例属性
    - 房子地理位置
    - 房子占地面积
    - 房子剩余面积
    - 房子内家具列表
  - 实例方法
    - 容纳家具
  - 显示房屋信息



- 家具类
  - 家具名称
  - 家具占地面积

#### 5.2.2.2 创建对象并调用相关方法



### 5.2.3 代码实现

#### 5.2.3.1 定义类

- 家具类

``` python
class Furniture():
    def __init__(self, name, area):
        # 家具名字
        self.name = name
        # 家具占地面积
        self.area = area
```



- #### 房子类

``` python
class Home():
    def __init__(self, address, area):
        # 地理位置
        self.address = address
        # 房屋面积
        self.area = area
        # 剩余面积
        self.free_area = area
        # 家具列表
        self.furniture = []

    def __str__(self):
        return f'房子坐落于{self.address}, 占地面积{self.area}, 剩余面积{self.free_area}, 家具有{self.furniture}'

    def add_furniture(self, item):
        """容纳家具"""
        if self.free_area >= item.area:
            self.furniture.append(item.name)
            # 家具搬入后，房屋剩余面积 = 之前剩余面积 - 该家具面积
            self.free_area -= item.area
        else:
            print('家具太大，剩余面积不足，无法容纳')
```



#### 5.2.3.2 创建对象并调用实例属性和方法

``` python
bed = Furniture('双人床', 6)
jia1 = Home('北京', 1200)
print(jia1)

jia1.add_furniture(bed)
print(jia1)

sofa = Furniture('沙发', 10)
jia1.add_furniture(sofa)
print(jia1)

ball = Furniture('篮球场', 1500)
jia1.add_furniture(ball)
print(jia1)
```



# 六. 总结

- 面向对象重要组成部分

  - 类
    - 创建类

  ``` python
  class 类名():
    代码
  ```

  - 对象

  ``` python
  对象名 = 类名()
  ```

- 添加对象属性

  - 类外面

  ``` python
  对象名.属性名 = 值
  ```

  - 类里面

  ``` python
  self.属性名 = 值
  ```

- 获取对象属性

  - 类外面

  ``` python
  对象名.属性名
  ```

  - 类里面

  ``` python
  self.属性名
  ```

- 魔法方法

  - `__init__()`: 初始化
  - `__str__()`:输出对象信息
  - `__del__()`:删除对象时调用

# 课程：面向对象-继承

# 目标

- 继承的概念
- 单继承
- 多继承
- 子类重写父类的同名属性和方法
- 子类调用父类的同名属性和方法
- 多层继承
- super()
- 私有属性和私有方法

# 一. 继承的概念

生活中的继承，一般指的是子女继承父辈的财产。

![](%E5%88%B7%E9%A2%98.assets/1-16624722381533.png)

- 拓展1：经典类或旧式类

不由任意内置类型派生出的类，称之为经典类。

```python
class 类名:
    代码
    ......
```

- 拓展2：新式类

```python
class 类名(object):
  代码
```



Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下：

``` python
# 父类A
class A(object):
    def __init__(self):
        self.num = 1

    def info_print(self):
        print(self.num)

# 子类B
class B(A):
    pass


result = B()
result.info_print()  # 1
```

> 在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。



# 二. 单继承

> 故事主线：一个煎饼果子老师傅，在煎饼果子界摸爬滚打多年，研发了一套精湛的摊煎饼果子的技术。师父要把这套技术传授给他的唯一的最得意的徒弟。

分析：徒弟是不是要继承师父的所有技术？

``` python
# 1. 师父类
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')

        
# 2. 徒弟类
class Prentice(Master):
    pass


# 3. 创建对象daqiu
daqiu = Prentice()
# 4. 对象访问实例属性
print(daqiu.kongfu)
# 5. 对象调用实例方法
daqiu.make_cake()
```



# 三. 多继承

> 故事推进：daqiu是个爱学习的好孩子，想学习更多的煎饼果子技术，于是，在百度搜索到黑马程序员，报班学习煎饼果子技术。

所谓多继承意思就是一个类同时继承了多个父类。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


# 创建学校类
class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class Prentice(School, Master):
    pass


daqiu = Prentice()
print(daqiu.kongfu)
daqiu.make_cake()
```

> 注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。



# 四. 子类重写父类同名方法和属性

> 故事：daqiu掌握了师父和培训的技术后，自己潜心钻研出自己的独门配方的一套全新的煎饼果子技术。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


# 独创配方
class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


daqiu = Prentice()
print(daqiu.kongfu)
daqiu.make_cake()

print(Prentice.__mro__)
```

> 子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。



# 五. 子类调用父类的同名方法和属性

> 故事：很多顾客都希望也能吃到古法和黑马的技术的煎饼果子。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果子配方]'

    def make_cake(self):
        # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化
        self.__init__()
        print(f'运用{self.kongfu}制作煎饼果子')

    # 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)


daqiu = Prentice()

daqiu.make_cake()

daqiu.make_master_cake()

daqiu.make_school_cake()

daqiu.make_cake()
```



# 六. 多层继承

> 故事：N年后，daqiu老了，想要把所有技术传承给自己的徒弟。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果子配方]'

    def make_cake(self):
        self.__init__()
        print(f'运用{self.kongfu}制作煎饼果子')

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)


# 徒孙类
class Tusun(Prentice):
    pass


xiaoqiu = Tusun()

xiaoqiu.make_cake()

xiaoqiu.make_school_cake()

xiaoqiu.make_master_cake()

```



# 七. super()调用父类方法

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(Master):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')

        # 方法2.1
        # super(School, self).__init__()
        # super(School, self).make_cake()

        # 方法2.2
        super().__init__()
        super().make_cake()


class Prentice(School):
    def __init__(self):
        self.kongfu = '[独创煎饼果子技术]'

    def make_cake(self):
        self.__init__()
        print(f'运用{self.kongfu}制作煎饼果子')

    # 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

    # 一次性调用父类的同名属性和方法
    def make_old_cake(self):
        # 方法一：代码冗余；父类类名如果变化，这里代码需要频繁修改
        # Master.__init__(self)
        # Master.make_cake(self)
        # School.__init__(self)
        # School.make_cake(self)

        # 方法二: super()
        # 方法2.1 super(当前类名, self).函数()
        # super(Prentice, self).__init__()
        # super(Prentice, self).make_cake()

        # 方法2.2 super().函数()
        super().__init__()
        super().make_cake()


daqiu = Prentice()

daqiu.make_old_cake()
```

> 注意：使用super() 可以自动查找父类。调用顺序遵循 `__mro__` 类属性的顺序。比较适合单继承使用。



# 八. 私有权限

## 8.1 定义私有属性和方法

在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。

> 故事：daqiu把技术传承给徒弟的同时，不想把自己的钱(2000000个亿)继承给徒弟，这个时候就要为`钱`这个实例属性设置私有权限。

设置私有权限的方法：在属性名和方法名 前面 加上两个下划线 __。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果子配方]'
        # 定义私有属性
        self.__money = 2000000

    # 定义私有方法
    def __info_print(self):
        print(self.kongfu)
        print(self.__money)

    def make_cake(self):
        self.__init__()
        print(f'运用{self.kongfu}制作煎饼果子')

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)


# 徒孙类
class Tusun(Prentice):
    pass


daqiu = Prentice()
# 对象不能访问私有属性和私有方法
# print(daqiu.__money)
# daqiu.__info_print()

xiaoqiu = Tusun()
# 子类无法继承父类的私有属性和私有方法
# print(xiaoqiu.__money)  # 无法访问实例属性__money
# xiaoqiu.__info_print()
```

> 注意：私有属性和私有方法只能在类里面访问和修改。

## 8.2 获取和修改私有属性值

在Python中，一般定义函数名`get_xx`用来获取私有属性，定义`set_xx`用来修改私有属性值。

``` python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class School(object):
    def __init__(self):
        self.kongfu = '[黑马煎饼果子配方]'

    def make_cake(self):
        print(f'运用{self.kongfu}制作煎饼果子')


class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果子配方]'
        self.__money = 2000000

    # 获取私有属性
    def get_money(self):
        return self.__money

    # 修改私有属性
    def set_money(self):
        self.__money = 500

    def __info_print(self):
        print(self.kongfu)
        print(self.__money)

    def make_cake(self):
        self.__init__()
        print(f'运用{self.kongfu}制作煎饼果子')

    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)

    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)


# 徒孙类
class Tusun(Prentice):
    pass


daqiu = Prentice()

xiaoqiu = Tusun()
# 调用get_money函数获取私有属性money的值
print(xiaoqiu.get_money())
# 调用set_money函数修改私有属性money的值
xiaoqiu.set_money()
print(xiaoqiu.get_money())
```



# 九. 总结

- 继承的特点

  - 子类默认拥有父类的所有属性和方法
  - 子类重写父类同名方法和属性
  - 子类调用父类同名方法和属性

- super()方法快速调用父类方法

- 私有权限

  - 不能继承给子类的属性和方法需要添加私有权限
  - 语法

  ``` python
  class 类名():
    # 私有属性
    __属性名 = 值
  
    # 私有方法
    def __函数名(self):
      代码
  ```

  # 课程：面向对象-其他

  # 目标

  - 面向对象三大特性
  - 类属性和实例属性
  - 类方法和静态方法

  # 一. 面向对象三大特性

  - 封装
    - 将属性和方法书写到类的里面的操作即为封装
    - 封装可以为属性和方法添加私有权限
  - 继承
    - 子类默认继承父类的所有属性和方法
    - 子类可以重写父类属性和方法
  - 多态
    - 传入不同的对象，产生不同的结果

  

  # 二. 多态

  ## 2.1 了解多态

  多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。

  - 定义：多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果
  - 好处：调用灵活，有了多态，更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化！
  - 实现步骤：
    - 定义父类，并提供公共方法
    - 定义子类，并重写父类方法
    - 传递子类对象给调用者，可以看到不同子类执行效果不同

  ## 2.2 体验多态

  ``` python
  class Dog(object):
      def work(self):  # 父类提供统一的方法，哪怕是空方法
          print('指哪打哪...')
  
  
  class ArmyDog(Dog):  # 继承Dog类
      def work(self):  # 子类重写父类同名方法
          print('追击敌人...')
  
  
  class DrugDog(Dog):
      def work(self):
          print('追查毒品...')
  
  
  class Person(object):
      def work_with_dog(self, dog):  # 传入不同的对象，执行不同的代码，即不同的work函数
          dog.work()
  
  
  ad = ArmyDog()
  dd = DrugDog()
  
  daqiu = Person()
  daqiu.work_with_dog(ad)
  daqiu.work_with_dog(dd)
  ```

  

  # 三. 类属性和实例属性

  ## 3.1 类属性

  ### 3.1.1 设置和访问类属性

  - 类属性就是 **类对象** 所拥有的属性，它被 **该类的所有实例对象 所共有**。
  - 类属性可以使用 **类对象** 或 **实例对象** 访问。

  ``` python
  class Dog(object):
      tooth = 10
  
  
  wangcai = Dog()
  xiaohei = Dog()
  
  print(Dog.tooth)  # 10
  print(wangcai.tooth)  # 10
  print(xiaohei.tooth)  # 10
  ```

  > 类属性的优点
  >
  > - **记录的某项数据 始终保持一致时**，则定义类属性。
  > - **实例属性** 要求 **每个对象** 为其 **单独开辟一份内存空间** 来记录数据，而 **类属性** 为全类所共有 ，**仅占用一份内存**，**更加节省内存空间**。

  

  ### 3.1.2 修改类属性

  类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性。

  ``` python
  class Dog(object):
      tooth = 10
  
  
  wangcai = Dog()
  xiaohei = Dog()
  
  # 修改类属性
  Dog.tooth = 12
  print(Dog.tooth)  # 12
  print(wangcai.tooth)  # 12
  print(xiaohei.tooth)  # 12
  
  # 不能通过对象修改属性，如果这样操作，实则是创建了一个实例属性
  wangcai.tooth = 20
  print(Dog.tooth)  # 12
  print(wangcai.tooth)  # 20
  print(xiaohei.tooth)  # 12
  ```

  

  ## 3.2 实例属性

  ``` python
  class Dog(object):
      def __init__(self):
          self.age = 5
  
      def info_print(self):
          print(self.age)
  
  
  wangcai = Dog()
  print(wangcai.age)  # 5
  # print(Dog.age)  # 报错：实例属性不能通过类访问
  wangcai.info_print()  # 5
  ```

  

  # 四. 类方法和静态方法

  ## 4.1 类方法

  ### 4.1.1 类方法特点

  - 需要用装饰器`@classmethod`来标识其为类方法，对于类方法，**第一个参数必须是类对象**，一般以`cls`作为第一个参数。

  

  ### 4.1.2 类方法使用场景

  - 当方法中 **需要使用类对象** (如访问私有类属性等)时，定义类方法
  - 类方法一般和类属性配合使用

  ``` python
  class Dog(object):
      __tooth = 10
  
      @classmethod
      def get_tooth(cls):
          return cls.__tooth
  
  
  wangcai = Dog()
  result = wangcai.get_tooth()
  print(result)  # 10
  ```

  

  ## 4.2 静态方法

  ### 4.2.1 静态方法特点

  - 需要通过装饰器`@staticmethod`来进行修饰，**静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）**。
  - 静态方法 也能够通过 **实例对象** 和 **类对象** 去访问。

  ## 4.2.2 静态方法使用场景

  - 当方法中 **既不需要使用实例对象**(如实例对象，实例属性)，**也不需要使用类对象** (如类属性、类方法、创建实例等)时，定义静态方法
  - **取消不需要的参数传递**，有利于 **减少不必要的内存占用和性能消耗**

  ``` python
  class Dog(object):
      @staticmethod
      def info_print():
          print('这是一个狗类，用于创建狗实例....')
  
  
  wangcai = Dog()
  # 静态方法既可以使用对象访问又可以使用类访问
  wangcai.info_print()
  Dog.info_print()
  ```

  

  # 五. 总结

  - 面向对象三大特性
    - 封装
    - 继承
    - 多态
  - 类属性
    - 归属于类对象的属性，所有对象共有的属性
  - 实例属性
  - 类方法

  ``` python
  @classmethod
  def xx():
    代码
  ```

  - 静态方法

  ``` python
  @staticmethod
  def xx():
    代码
  ```

  # 课程：异常

  # 目标

  - 了解异常
  - 捕获异常
  - 异常的else
  - 异常finally
  - 异常的传递
  - 自定义异常

  # 一. 了解异常

  当检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的"异常"。

  例如：以`r`方式打开一个不存在的文件。

  ``` python
  open('test.txt', 'r')
  ```

  ![image-20190305154200725](%E5%88%B7%E9%A2%98.assets/image-20190305154200725.png)

  

  # 二. 异常的写法

  ## 2.1 语法

  ``` python
  try:
      可能发生错误的代码
  except:
      如果出现异常执行的代码
  ```

  ## 2.2 快速体验

  需求：尝试以`r`模式打开文件，如果文件不存在，则以`w`方式打开。

  ``` python
  try:
      f = open('test.txt', 'r')
  except:
      f = open('test.txt', 'w')
  ```

  ## 2.3 捕获指定异常

  ### 2.3.1 语法

  ``` python
  try:
      可能发生错误的代码
  except 异常类型:
      如果捕获到该异常类型执行的代码
  ```

  ### 2.3.2 体验

  ``` python
  try:
      print(num)
  except NameError:
      print('有错误')
  ```

  > 注意：
  >
  > 1. 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。
  > 2. 一般try下方只放一行尝试执行的代码。

  ### 2.3.3 捕获多个指定异常

  当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。

  ``` python
  try:
      print(1/0)
  
  except (NameError, ZeroDivisionError):
      print('有错误')
  ```

  ### 2.3.4 捕获异常描述信息

  ``` python
  try:
      print(num)
  except (NameError, ZeroDivisionError) as result:
      print(result)
  ```

  ### 2.3.5 捕获所有异常

  Exception是所有程序异常类的父类。

  ``` python
  try:
      print(num)
  except Exception as result:
      print(result)
  ```

  

  ## 2.4 异常的else

  else表示的是如果没有异常要执行的代码。

  ``` python
  try:
      print(1)
  except Exception as result:
      print(result)
  else:
      print('我是else，是没有异常的时候执行的代码')
  ```

  ## 2.5 异常的finally

  finally表示的是无论是否异常都要执行的代码，例如关闭文件。

  ``` python
  try:
      f = open('test.txt', 'r')
  except Exception as result:
      f = open('test.txt', 'w')
  else:
      print('没有异常，真开心')
  finally:
      f.close()
  ```

  # 三. 异常的传递

  体验异常传递

  需求：

  ​	1. 尝试只读方式打开test.txt文件，如果文件存在则读取文件内容，文件不存在则提示用户即可。

  ​	2. 读取内容要求：尝试循环读取内容，读取过程中如果检测到用户意外终止程序，则`except`捕获异常并提示用户。

  ``` python
  import time
  try:
      f = open('test.txt')
      try:
          while True:
              content = f.readline()
              if len(content) == 0:
                  break
              time.sleep(2)
              print(content)
      except:
          # 如果在读取文件的过程中，产生了异常，那么就会捕获到
          # 比如 按下了 ctrl+c
          print('意外终止了读取数据')
      finally:
          f.close()
          print('关闭文件')
  except:
      print("没有这个文件")
  ```

  # 四. 自定义异常

  在Python中，抛出自定义异常的语法为` raise 异常类对象`。

  需求：密码长度不足，则报异常（用户输入密码，如果输入的长度不足3位，则报错，即抛出自定义异常，并捕获该异常）。

  ``` python
  # 自定义异常类，继承Exception
  class ShortInputError(Exception):
      def __init__(self, length, min_len):
          self.length = length
          self.min_len = min_len
  
      # 设置抛出异常的描述信息
      def __str__(self):
          return f'你输入的长度是{self.length}, 不能少于{self.min_len}个字符'
  
  
  def main():
      try:
          con = input('请输入密码：')
          if len(con) < 3:
              raise ShortInputError(len(con), 3)
      except Exception as result:
          print(result)
      else:
          print('密码已经输入完成')
  
  
  main()
  ```

  

  # 五. 总结

  - 异常语法

  ``` python
  try:
    	可能发生异常的代码
  except:
    	如果出现异常执行的代码
  else:
    	没有异常执行的代码
  finally:
    	无论是否异常都要执行的代码
  ```

  - 捕获异常

  ``` python
  except 异常类型:
    	代码
  
  except 异常类型 as xx:
  		代码
  ```

  - 自定义异常

  ``` python
  # 1. 自定义异常类
  class 异常类类名(Exception):
    	代码
      
      # 设置抛出异常的描述信息
      def __str__(self):
        return ...
  
  
  # 2. 抛出异常
  raise 异常类名()
  
  # 捕获异常
  except Exception...
  ```

  # 课程：模块和包

  # 目标

  - 了解模块
  - 导入模块
  - 制作模块
  - `__all__`
  - 包的使用方法

  

  # 一. 模块

  Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。

  模块能定义函数，类和变量，模块里也能包含可执行的代码。

  ## 1.1. 导入模块

  ### 1.1.1 导入模块的方式

  - import 模块名
  - from 模块名 import 功能名
  - from 模块名 import *
  - import 模块名 as 别名
  - from 模块名 import 功能名 as 别名

  ### 1.1.2 导入方式详解

  #### 1.1.2.1 import

  - 语法

  ``` python
  # 1. 导入模块
  import 模块名
  import 模块名1, 模块名2...
  
  # 2. 调用功能
  模块名.功能名()
  ```

  - 体验

  ``` python
  import math
  print(math.sqrt(9))  # 3.0
  ```

  #### 1.1.2.2 from..import..

  - 语法

  ``` python
  from 模块名 import 功能1, 功能2, 功能3...
  ```

  - 体验

  ``` python
  from math import sqrt
  print(sqrt(9))
  ```

  

  #### 1.1.2.3 from .. import *

  - 语法

  ``` python
  from 模块名 import *
  ```

  - 体验

  ``` python
  from math import *
  print(sqrt(9))
  ```

  #### 1.1.2.4 as定义别名

  - 语法

  ``` python
  # 模块定义别名
  import 模块名 as 别名
  
  # 功能定义别名
  from 模块名 import 功能 as 别名
  ```

  - 体验

  ``` python
  # 模块别名
  import time as tt
  
  tt.sleep(2)
  print('hello')
  
  # 功能别名
  from time import sleep as sl
  sl(2)
  print('hello')
  ```

  

  ## 1.2. 制作模块

  在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。**也就是说自定义模块名必须要符合标识符命名规则。**

  ### 1.2.1 定义模块

  新建一个Python文件，命名为`my_module1.py`，并定义`testA`函数。

  ``` python
  def testA(a, b):
      print(a + b)
  ```

  

  ### 1.2.2 测试模块

  在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息.，例如，在`my_module1.py`文件中添加测试代码。

  ``` python
  def testA(a, b):
      print(a + b)
  
  
  testA(1, 1)
  ```

  此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行`testA`函数的调用。

  解决办法如下：

  ``` python
  def testA(a, b):
      print(a + b)
  
  # 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用
  if __name__ == '__main__':
      testA(1, 1)
  ```

  

  ### 1.2.3 调用模块

  ```python
  import my_module1
  my_module1.testA(1, 1)
  ```

  

  ### 1.2.4 注意事项

  如果使用`from .. import ..`或`from .. import *`导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。

  - 体验

  ``` python
  # 模块1代码
  def my_test(a, b):
      print(a + b)
  
  # 模块2代码
  def my_test(a, b):
      print(a - b)
     
  # 导入模块和调用功能代码
  from my_module1 import my_test
  from my_module2 import my_test
  
  # my_test函数是模块2中的函数
  my_test(1, 1)
  ```

  

  ## 1.3. 模块定位顺序

  当导入一个模块，Python解析器对模块位置的搜索顺序是：

  1. 当前目录
  2. 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。
  3. 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/

  模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。

  - 注意
    - 自己的文件名不要和已有模块名重复，否则导致模块功能无法使用
    - `使用from 模块名 import 功能`的时候，如果功能名字重复，调用到的是最后定义或导入的功能。

  

  ## 1.4. `__all__`

  如果一个模块文件中有`__all__`变量，当使用`from xxx import *`导入时，只能导入这个列表中的元素。

  - my_module1模块代码

  ``` python
  __all__ = ['testA']
  
  
  def testA():
      print('testA')
  
  
  def testB():
      print('testB')
  ```

  - 导入模块的文件代码

  ``` python
  from my_module1 import *
  testA()
  testB()
  ```

  ![image-20190305175727272](%E5%88%B7%E9%A2%98.assets/image-20190305175727272.png)

  

  # 二. 包

  包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为`__init__.py` 文件，那么这个文件夹就称之为包。

  ## 2.1 制作包

  [New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。

  注意：新建包后，包内部会自动创建`__init__.py`文件，这个文件控制着包的导入行为。

  ### 2.1.1 快速体验

  1. 新建包`mypackage`
  2. 新建包内模块：`my_module1` 和 `my_module2`
  3. 模块内代码如下

  ``` python
  # my_module1
  print(1)
  
  
  def info_print1():
      print('my_module1')
  ```

  ``` python
  # my_module2
  print(2)
  
  
  def info_print2():
      print('my_module2')
  ```

  

  ## 2.2 导入包

  ### 2.2.1 方法一

  ``` python
  import 包名.模块名
  
  包名.模块名.目标
  ```

  #### 2.2.1.1 体验

  ``` python
  import my_package.my_module1
  
  my_package.my_module1.info_print1()
  ```

  ### 2.2.2 方法二

  注意：必须在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表。

  ``` python
  from 包名 import *
  模块名.目标
  ```

  #### 2.2.2.1 体验

  ``` python
  from my_package import *
  
  my_module1.info_print1()
  ```

  

  # 三. 总结

  - 导入模块方法

  ``` python
  import 模块名
  
  from 模块名 import 目标
  
  from 模块名 import *
  ```

  - 导入包

  ``` python
  import 包名.模块名
  
  from 包名 import *
  ```

  - `__all__ = []` ：允许导入的模块或功能列表

  

  ### 多任务

  - 使用多任务就能充分利用CPU资源，提高程序的执行效率，让你的程序具备处理多个任务的能力。
  - 多任务执行方式有两种方式：**并发**和**并行**，这里并行才是多个任务真正意义一起执行。

  - 进程是操作系统进行资源分配的基本单位。
  - 进程是Python程序中实现多任务的一种方式

**一个程序运行后至少有一个进程，一个进程默认有一个线程**，进程里面可以创建多个线程，**线程是依附在进程里面的，没有进程就没有线程**。

**学习目标**

- 能够使用多进程完成多任务

------

### 1 导入进程包

```py
#导入进程包
import multiprocessing
```

### 2. Process进程类的说明

**Process([group [, target [, name [, args [, kwargs]]]]])**

- group：指定进程组，目前只能使用None
- target：执行的目标任务名
- name：进程名字
- args：以元组方式给执行任务传参
- kwargs：以字典方式给执行任务传参

**Process创建的实例对象的常用方法:**

- start()：启动子进程实例（创建子进程）
- join()：等待子进程执行结束
- terminate()：不管任务是否完成，立即终止子进程

**Process创建的实例对象的常用属性:**

name：当前进程的别名，默认为Process-N，N为从1开始递增的整数

### 3. 多进程完成多任务的代码

```python
import multiprocessing
import time


# 跳舞任务
def dance():
    for i in range(5):
        print("跳舞中...")
        time.sleep(0.2)


# 唱歌任务
def sing():
    for i in range(5):
        print("唱歌中...")
        time.sleep(0.2)

if __name__ == '__main__':
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name="myprocess1")
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
```

**执行结果:**

```python
唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...
唱歌中...
跳舞中...
```

### 4. 小结

1. 导入进程包
   - import multiprocessing
2. 创建子进程并指定执行的任务
   - sub_process = multiprocessing.Process (target=任务名)
3. 启动进程执行任务
   - sub_process.start()

# 获取进程编号

**学习目标**

- 能够知道如果获取进程编号

------

### 1. 获取进程编号的目的

**获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。**

获取进程编号的两种操作

- 获取当前进程编号
- 获取当前父进程编号

### 2. 获取当前进程编号

**os.getpid()** 表示获取当前进程编号

**示例代码:**

```py
import multiprocessing
import time
import os


# 跳舞任务
def dance():
    # 获取当前进程的编号
    print("dance:", os.getpid())
    # 获取当前进程
    print("dance:", multiprocessing.current_process())
    for i in range(5):
        print("跳舞中...")
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)


# 唱歌任务
def sing():
    # 获取当前进程的编号
    print("sing:", os.getpid())
    # 获取当前进程
    print("sing:", multiprocessing.current_process())
    for i in range(5):
        print("唱歌中...")
        time.sleep(0.2)


if __name__ == '__main__':

    # 获取当前进程的编号
    print("main:", os.getpid())
    # 获取当前进程
    print("main:", multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name="myprocess1")
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
```

**执行结果:**

```py
main: 70763
main: <_MainProcess(MainProcess, started)>
dance: 70768
dance: <Process(myprocess1, started)>
跳舞中...
sing: 70769
sing: <Process(Process-2, started)>
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...
```

### 3. 获取当前父进程编号

**os.getppid()** 表示获取当前父进程编号

**示例代码:**

```py
import multiprocessing
import time
import os


# 跳舞任务
def dance():
    # 获取当前进程的编号
    print("dance:", os.getpid())
    # 获取当前进程
    print("dance:", multiprocessing.current_process())
    # 获取父进程的编号
    print("dance的父进程编号:", os.getppid())
    for i in range(5):
        print("跳舞中...")
        time.sleep(0.2)
        # 扩展:根据进程编号杀死指定进程
        os.kill(os.getpid(), 9)


# 唱歌任务
def sing():
    # 获取当前进程的编号
    print("sing:", os.getpid())
    # 获取当前进程
    print("sing:", multiprocessing.current_process())
    # 获取父进程的编号
    print("sing的父进程编号:", os.getppid())
    for i in range(5):
        print("唱歌中...")
        time.sleep(0.2)


if __name__ == '__main__':

    # 获取当前进程的编号
    print("main:", os.getpid())
    # 获取当前进程
    print("main:", multiprocessing.current_process())
    # 创建跳舞的子进程
    # group: 表示进程组，目前只能使用None
    # target: 表示执行的目标任务名(函数名、方法名)
    # name: 进程名称, 默认是Process-1, .....
    dance_process = multiprocessing.Process(target=dance, name="myprocess1")
    sing_process = multiprocessing.Process(target=sing)

    # 启动子进程执行对应的任务
    dance_process.start()
    sing_process.start()
main: 70860
main: <_MainProcess(MainProcess, started)>
dance: 70861
dance: <Process(myprocess1, started)>
dance的父进程编号: 70860
跳舞中...
sing: 70862
sing: <Process(Process-2, started)>
sing的父进程编号: 70860
唱歌中...
唱歌中...
唱歌中...
唱歌中...
唱歌中...
```

### 4. 小结

- 获取当前进程编号
  - os.getpid()
- 获取当前父进程编号
  - os.getppid()
- 获取进程编号可以查看父子进程的关系

# 进程执行带有参数的任务

**学习目标**

- 能够写出进程执行带有参数的任务

------

### 1. 进程执行带有参数的任务的介绍

前面我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?

Process类执行任务并给任务传参数有两种方式:

- args 表示以元组的方式给执行任务传参
- kwargs 表示以字典方式给执行任务传参

### 2. args参数的使用

**示例代码:**

```py
import multiprocessing
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print("任务执行中..")
        time.sleep(0.2)
    else:
        print("任务执行完成")


if __name__ == '__main__':
    # 创建子进程
    # args: 以元组的方式给任务传入参数
    sub_process = multiprocessing.Process(target=task, args=(5,))
    sub_process.start()
```

**执行结果:**

```py
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行完成
```

### 3. kwargs参数的使用

**示例代码:**

```py
import multiprocessing
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print("任务执行中..")
        time.sleep(0.2)
    else:
        print("任务执行完成")


if __name__ == '__main__':
    # 创建子进程

    # kwargs: 表示以字典方式传入参数
    sub_process = multiprocessing.Process(target=task, kwargs={"count": 3})
    sub_process.start()
```

**执行结果:**

```py
任务执行中..
任务执行中..
任务执行中..
任务执行完成
```

### 4. 小结

- 进程执行任务并传参有两种方式:
  - **元组方式传参(args)**: 元组方式传参一定要和参数的顺序保持一致。
  - **字典方式传参(kwargs)**: 字典方式传参字典中的key一定要和参数名保持一致。

# 进程的注意点

**学习目标**

- 能够说出进程的注意点

------

### 1. 进程的注意点介绍

1. 进程之间不共享全局变量
2. 主进程会等待所有的子进程执行结束再结束

### 2. 进程之间不共享全局变量

```py
import multiprocessing
import time

# 定义全局变量
g_list = list()


# 添加数据的任务
def add_data():
    for i in range(5):
        g_list.append(i)
        print("add:", i)
        time.sleep(0.2)

    # 代码执行到此，说明数据添加完成
    print("add_data:", g_list)


def read_data():
    print("read_data", g_list)


if __name__ == '__main__':
    # 创建添加数据的子进程
    add_data_process = multiprocessing.Process(target=add_data)
    # 创建读取数据的子进程
    read_data_process = multiprocessing.Process(target=read_data)

    # 启动子进程执行对应的任务
    add_data_process.start()
    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据
    add_data_process.join()
    read_data_process.start()

    print("main:", g_list)

    # 总结: 多进程之间不共享全局变量
```

**执行结果:**

```py
add: 0
add: 1
add: 2
add: 3
add: 4
add_data: [0, 1, 2, 3, 4]
main: []
read_data []
```

**进程之间不共享全局变量的解释效果图:**

![进程关系](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E8%25BF%259B%25E7%25A8%258B%25E5%2585%25B3%25E7%25B3%25BB.png)

### 3. 进程之间不共享全局变量的小结

- 创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。

### 4. 主进程会等待所有的子进程执行结束再结束

假如我们现在创建一个子进程，这个子进程执行完大概需要2秒钟，现在让主进程执行0.5秒钟就退出程序，查看一下执行结果，示例代码如下:

```py
import multiprocessing
import time


# 定义进程所需要执行的任务
def task():
    for i in range(10):
        print("任务执行中...")
        time.sleep(0.2)

if __name__ == '__main__':
    # 创建子进程
    sub_process = multiprocessing.Process(target=task)
    sub_process.start()

    # 主进程延时0.5秒钟
    time.sleep(0.5)
    print("over")
    exit()

    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出
```

**执行结果:**

```py
任务执行中...
任务执行中...
任务执行中...
over
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...
任务执行中...
```

**说明:**

通过上面代码的执行结果，我们可以得知: **主进程会等待所有的子进程执行结束再结束**

假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行，那怎么办呢?

- 我们可以设置**守护主进程** 或者 在主进程退出之前 **让子进程销毁**

**守护主进程:**

- 守护主进程就是主进程退出子进程销毁不再执行

**子进程销毁:**

- 子进程执行结束

**保证主进程正常退出的示例代码:**

```py
import multiprocessing
import time


# 定义进程所需要执行的任务
def task():
    for i in range(10):
        print("任务执行中...")
        time.sleep(0.2)

if __name__ == '__main__':
    # 创建子进程
    sub_process = multiprocessing.Process(target=task)
    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程
    # sub_process.daemon = True
    sub_process.start()

    time.sleep(0.5)
    print("over")
    # 让子进程销毁
    sub_process.terminate()
    exit()

    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出
    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁
```

**执行结果:**

```py
任务执行中...
任务执行中...
任务执行中...
over
```

### 5. 主进程会等待所有的子进程执行结束再结束的小结

- 为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是**主进程退出子进程销毁，不让主进程再等待子进程去执行**。
- 设置守护主进程方式： **子进程对象.daemon = True**
- 销毁子进程方式： **子进程对象.terminate()**

# 线程

**学习目标**

能够知道线程的作用

------

### 1. 线程的介绍

在Python中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。

### 2. 线程的概念

线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。

### 3. 线程的作用

多线程可以完成多任务

**多线程效果图:**

![线程](%E5%88%B7%E9%A2%98.assets/%E7%BA%BF%E7%A8%8B-16624724540194.png)

![线程](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E7%25BA%25BF%25E7%25A8%258B.png)

### 4. 小结

- 线程是Python程序中实现多任务的另外一种方式，线程的执行需要cpu调度来完成。

# 多线程的使用

**学习目标**

- 能够使用多线程完成多任务

------

### 1. 导入线程模块

```py
#导入线程模块
import threading
```

### 2. 线程类Thread参数说明

Thread([group [, target [, name [, args [, kwargs]]]]])

- group: 线程组，目前只能使用None
- target: 执行的目标任务名
- args: 以元组的方式给执行任务传参
- kwargs: 以字典方式给执行任务传参
- name: 线程名，一般不用设置

### 3. 启动线程

启动线程使用start方法

### 4. 多线程完成多任务的代码

```py
import threading
import time

# 唱歌任务
def sing():
    # 扩展： 获取当前线程
    # print("sing当前执行的线程为：", threading.current_thread())
    for i in range(3):
        print("正在唱歌...%d" % i)
        time.sleep(1)

# 跳舞任务
def dance():
    # 扩展： 获取当前线程
    # print("dance当前执行的线程为：", threading.current_thread())
    for i in range(3):
        print("正在跳舞...%d" % i)
        time.sleep(1)


if __name__ == '__main__':
    # 扩展： 获取当前线程
    # print("当前执行的线程为：", threading.current_thread())
    # 创建唱歌的线程
    # target： 线程执行的函数名
    sing_thread = threading.Thread(target=sing)

    # 创建跳舞的线程
    dance_thread = threading.Thread(target=dance)

    # 开启线程
    sing_thread.start()
    dance_thread.start()
```

**执行结果:**

```py
正在唱歌...0
正在跳舞...0
正在唱歌...1
正在跳舞...1
正在唱歌...2
正在跳舞...2
```

### 5. 小结

1. 导入线程模块
   - import threading
2. 创建子线程并指定执行的任务
   - sub_thread = threading.Thread(target=任务名)
3. 启动线程执行任务
   - sub_thread.start()

# 线程执行带有参数的任务

**学习目标**

- 能够写出线程执行带有参数的任务

------

### 1. 线程执行带有参数的任务的介绍

前面我们使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?

Thread类执行任务并给任务传参数有两种方式:

- args 表示以元组的方式给执行任务传参
- kwargs 表示以字典方式给执行任务传参

### 2. args参数的使用

**示例代码:**

```py
import threading
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print("任务执行中..")
        time.sleep(0.2)
    else:
        print("任务执行完成")


if __name__ == '__main__':
    # 创建子线程
    # args: 以元组的方式给任务传入参数
    sub_thread = threading.Thread(target=task, args=(5,))
    sub_thread.start()
```

**执行结果:**

```py
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行中..
任务执行完成
```

### 3. kwargs参数的使用

**示例代码:**

```py
import threading
import time


# 带有参数的任务
def task(count):
    for i in range(count):
        print("任务执行中..")
        time.sleep(0.2)
    else:
        print("任务执行完成")


if __name__ == '__main__':
    # 创建子线程
    # kwargs: 表示以字典方式传入参数
    sub_thread = threading.Thread(target=task, kwargs={"count": 3})
    sub_thread.start()
```

**执行结果:**

```py
任务执行中..
任务执行中..
任务执行中..
任务执行完成
```

### 4. 小结

- 线程执行任务并传参有两种方式:
  - **元组方式传参(args)** ：元组方式传参一定要和参数的顺序保持一致。
  - **字典方式传参(kwargs)**：字典方式传参字典中的key一定要和参数名保持一致。

# 线程的注意点

**学习目标**

- 能够说出线程的注意点

------

### 1. 线程的注意点介绍

1. 线程之间执行是无序的
2. 主线程会等待所有的子线程执行结束再结束
3. 线程之间共享全局变量
4. 线程之间共享全局变量数据出现错误问题

### 2. 线程之间执行是无序的

```py
import threading
import time


def task():
    time.sleep(1)
    print("当前线程:", threading.current_thread().name)


if __name__ == '__main__':

   for _ in range(5):
       sub_thread = threading.Thread(target=task)
       sub_thread.start()
```

**执行结果:**

```py
当前线程: Thread-1
当前线程: Thread-2
当前线程: Thread-4
当前线程: Thread-5
当前线程: Thread-3
```

**说明:**

- 线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。
- 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。

### 3. 主线程会等待所有的子线程执行结束再结束

假如我们现在创建一个子线程，这个子线程执行完大概需要2.5秒钟，现在让主线程执行1秒钟就退出程序，查看一下执行结果，示例代码如下:

```py
import threading
import time


# 测试主线程是否会等待子线程执行完成以后程序再退出
def show_info():
    for i in range(5):
        print("test:", i)
        time.sleep(0.5)


if __name__ == '__main__':
    sub_thread = threading.Thread(target=show_info)
    sub_thread.start()

    # 主线程延时1秒
    time.sleep(1)
    print("over")
```

**执行结果:**

```py
test: 0
test: 1
over
test: 2
test: 3
test: 4
```

**说明:**

通过上面代码的执行结果，我们可以得知: **主线程会等待所有的子线程执行结束再结束**

假如我们就让主线程执行1秒钟，子线程就销毁不再执行，那怎么办呢?

- 我们可以设置**守护主线程**

**守护主线程:**

- 守护主线程就是主线程退出子线程销毁不再执行

**设置守护主线程有两种方式：**

1. threading.Thread(target=show_info, daemon=True)
2. 线程对象.setDaemon(True)

**设置守护主线程的示例代码:**

```py
import threading
import time


# 测试主线程是否会等待子线程执行完成以后程序再退出
def show_info():
    for i in range(5):
        print("test:", i)
        time.sleep(0.5)


if __name__ == '__main__':
    # 创建子线程守护主线程 
    # daemon=True 守护主线程
    # 守护主线程方式1
    sub_thread = threading.Thread(target=show_info, daemon=True)
    # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码
    # 守护主线程方式2
    # sub_thread.setDaemon(True)
    sub_thread.start()

    # 主线程延时1秒
    time.sleep(1)
    print("over")
```

**执行结果:**

```py
test: 0
test: 1
over
```

### 3. 线程之间共享全局变量

**需求:**

1. 定义一个列表类型的全局变量
2. 创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务
3. 查看线程之间是否共享全局变量数据

```py
import threading
import time


# 定义全局变量
my_list = list()

# 写入数据任务
def write_data():
    for i in range(5):
        my_list.append(i)
        time.sleep(0.1)
    print("write_data:", my_list)


# 读取数据任务
def read_data():
    print("read_data:", my_list)


if __name__ == '__main__':
    # 创建写入数据的线程
    write_thread = threading.Thread(target=write_data)
    # 创建读取数据的线程
    read_thread = threading.Thread(target=read_data)

    write_thread.start()
    # 延时
    # time.sleep(1)
    # 主线程等待写入线程执行完成以后代码在继续往下执行
    write_thread.join()
    print("开始读取数据啦")
    read_thread.start()
```

**执行结果:**

```py
write_data: [0, 1, 2, 3, 4]
开始读取数据啦
read_data: [0, 1, 2, 3, 4]
```

### 4. 线程之间共享全局变量数据出现错误问题

**需求:**

1. 定义两个函数，实现循环100万次，每循环一次给全局变量加1
2. 创建两个子线程执行对应的两个函数，查看计算后的结果

```py
import threading

# 定义全局变量
g_num = 0


# 循环一次给全局变量加1
def sum_num1():
    for i in range(1000000):
        global g_num
        g_num += 1

    print("sum1:", g_num)


# 循环一次给全局变量加1
def sum_num2():
    for i in range(1000000):
        global g_num
        g_num += 1
    print("sum2:", g_num)


if __name__ == '__main__':
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动线程
    first_thread.start()
    # 启动线程
    second_thread.start()
```

**执行结果:**

```py
sum1: 1210949
sum2: 1496035
```

**注意点:**

**多线程同时对全局变量操作数据发生了错误**

**错误分析:**

两个线程first_thread和second_thread都要对全局变量g_num(默认是0)进行加1运算，但是由于是多线程同时操作，有可能出现下面情况：

1. 在g_num=0时，first_thread取得g_num=0。此时系统把first_thread调度为”sleeping”状态，把second_thread转换为”running”状态，t2也获得g_num=0
2. 然后second_thread对得到的值进行加1并赋给g_num，使得g_num=1
3. 然后系统又把second_thread调度为”sleeping”，把first_thread转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。
4. 这样导致虽然first_thread和first_thread都对g_num加1，但结果仍然是g_num=1

**全局变量数据错误的解决办法:**

线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机

线程同步的方式:

1. **线程等待(join)**
2. **互斥锁**

**线程等待的示例代码:**

```py
import threading

# 定义全局变量
g_num = 0


# 循环1000000次每次给全局变量加1
def sum_num1():
    for i in range(1000000):
        global g_num
        g_num += 1

    print("sum1:", g_num)


# 循环1000000次每次给全局变量加1
def sum_num2():
    for i in range(1000000):
        global g_num
        g_num += 1
    print("sum2:", g_num)


if __name__ == '__main__':
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)

    # 启动线程
    first_thread.start()
    # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程
    # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行
    first_thread.join()
    # 启动线程
    second_thread.start()
```

**执行结果:**

```py
sum1: 1000000
sum2: 2000000
```

### 5. 小结

- 线程执行执行是无序的
- 主线程默认会等待所有子线程执行结束再结束，设置守护主线程的目的是主线程退出子线程销毁。
- 线程之间共享全局变量，好处是可以对全局变量的数据进行共享。
- 线程之间共享全局变量可能会导致数据出现错误问题，可以使用线程同步方式来解决这个问题。
  - 线程等待(join)

# 互斥锁

**学习目标**

- 能够知道互斥锁的作用

------

### 1.互斥锁的概念

互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。

注意:

- 互斥锁是**多个线程一起去抢**，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。

**为了更好的理解互斥锁，请看下面的图:**

![互斥锁](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E4%25BA%2592%25E6%2596%25A5%25E9%2594%2581.png)

### 3. 互斥锁的使用

threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。

**互斥锁使用步骤:**

```py
# 创建锁
mutex = threading.Lock()

# 上锁
mutex.acquire()

...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...

# 释放锁
mutex.release()
```

**注意点:**

- **acquire和release方法之间的代码同一时刻只能有一个线程去操作**
- **如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。**

### 4. 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作

```py
import threading


# 定义全局变量
g_num = 0

# 创建全局互斥锁
lock = threading.Lock()


# 循环一次给全局变量加1
def sum_num1():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1

    print("sum1:", g_num)
    # 释放锁
    lock.release()


# 循环一次给全局变量加1
def sum_num2():
    # 上锁
    lock.acquire()
    for i in range(1000000):
        global g_num
        g_num += 1
    print("sum2:", g_num)
    # 释放锁
    lock.release()


if __name__ == '__main__':
    # 创建两个线程
    first_thread = threading.Thread(target=sum_num1)
    second_thread = threading.Thread(target=sum_num2)
    # 启动线程
    first_thread.start()
    second_thread.start()

    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待
    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行
```

**执行结果:**

```py
sum1: 1000000
sum2: 2000000
```

**说明:**

通过执行结果可以地址**互斥锁能够保证多个线程访问共享数据不会出现数据错误问题**

### 5. 小结

- 互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题
- 使用互斥锁的好处确保某段关键代码只能由一个线程从头到尾完整地去执行
- 使用互斥锁会影响代码的执行效率，多任务改成了单任务执行
- 互斥锁如果没有使用好容易出现死锁的情况

# 死锁

**学习目标**

- 能够知道产生死锁的原因

------

### 1. 死锁的概念

死锁: 一直等待对方释放锁的情景就是死锁

为了更好的理解死锁，来看一个现实生活的效果图:

![死锁](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%25AD%25BB%25E9%2594%2581.png)

**说明:**

现实社会中，男女双方一直等待对方先道歉的这种行为就好比是死锁。

**死锁的结果**

- 会造成应用程序的停止响应，不能再处理其它任务了。

### 2. 死锁示例

**需求:**

根据下标在列表中取值, 保证同一时刻只能有一个线程去取值

```py
import threading
import time

# 创建互斥锁
lock = threading.Lock()


# 根据下标去取值， 保证同一时刻只能有一个线程去取值
def get_value(index):

    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    # 判断下标释放越界
    if index >= len(my_list):
        print("下标越界:", index)
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()


if __name__ == '__main__':
    # 模拟大量线程去执行取值操作
    for i in range(30):
        sub_thread = threading.Thread(target=get_value, args=(i,))
        sub_thread.start()
```

### 3. 避免死锁

- 在合适的地方释放锁

```py
import threading
import time

# 创建互斥锁
lock = threading.Lock()


# 根据下标去取值， 保证同一时刻只能有一个线程去取值
def get_value(index):

    # 上锁
    lock.acquire()
    print(threading.current_thread())
    my_list = [3,6,8,1]
    if index >= len(my_list):
        print("下标越界:", index)
        # 当下标越界需要释放锁，让后面的线程还可以取值
        lock.release()
        return
    value = my_list[index]
    print(value)
    time.sleep(0.2)
    # 释放锁
    lock.release()


if __name__ == '__main__':
    # 模拟大量线程去执行取值操作
    for i in range(30):
        sub_thread = threading.Thread(target=get_value, args=(i,))
        sub_thread.start()
```

### 4. 小结

- 使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。
- 死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。

# 进程和线程的对比

**学习目标**

- 能够知道进程和线程的关系

------

### 1. 进程和线程的对比的三个方向

1. 关系对比
2. 区别对比
3. 优缺点对比

### 2. 关系对比

1. 线程是依附在进程里面的，没有进程就没有线程。
2. 一个进程默认提供一条线程，进程可以创建多个线程。

![对比](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E5%2585%25B3%25E7%25B3%25BB.png)

### 2. 区别对比

1. 进程之间不共享全局变量
2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步
3. 创建进程的资源开销要比创建线程的资源开销要大
4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位
5. 线程不能够独立执行，必须依存在进程中
6. 多进程开发比单进程多线程开发稳定性要强

### 3. 优缺点对比

- 进程优缺点:
  - 优点：可以用多核
  - 缺点：资源开销大
- 线程优缺点:
  - 优点：资源开销小
  - 缺点：不能使用多核

### 4. 小结

- 进程和线程都是完成多任务的一种方式
- 多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。
- 多进程可以使用cpu的多核运行，多线程可以共享全局变量。
- 线程不能单独执行必须依附在进程里面

# IP 地址的介绍

**学习目标**

- 能够说出IP 地址的作用

------

### 1. IP 地址的概念

IP 地址就是**标识网络中设备的一个地址**，好比现实生活中的家庭地址。

**网络中的设备效果图:**

![网络设备](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/ip%25E5%259C%25B0%25E5%259D%2580-1.png)

### 2. IP 地址的表现形式

![网络设备](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/ip%25E5%259C%25B0%25E5%259D%2580-2.png)

**说明:**

- IP 地址分为两类： **IPv4** 和 **IPv6**
- IPv4 是目前使用的ip地址
- IPv6 是未来使用的ip地址
- IPv4 是由点分十进制组成
- IPv6 是由冒号十六进制组成

#### 2. IP 地址的作用

IP 地址的作用是**标识网络中唯一的一台设备的**，也就是说通过IP地址能够找到网络中某台设备。

**IP地址作用效果图:**

![网络设备](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/ip%25E5%259C%25B0%25E5%259D%2580-3.png)

### 3. 查看 IP 地址

- Linux 和 mac OS 使用 **ifconfig** 这个命令
- Windows 使用 **ipconfig** 这个命令

**说明:**

**ifconfig** 和 **ipconfig** 都是查看网卡信息的，网卡信息中包括这个设备对应的IP地址

![查看网卡信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%259F%25A5%25E7%259C%258B%25E7%25BD%2591%25E5%258D%25A1%25E4%25BF%25A1%25E6%2581%25AF.png)

说明:

- 192.168.1.107是设备在网络中的IP地址
- 127.0.0.1表示本机地址，提示：如果和自己的电脑通信就可以使用该地址。
- 127.0.0.1该地址对应的域名是**localhost**，**域名是 ip 地址的别名**，通过域名能解析出一个对应的ip地址。

### 4. 检查网络是否正常

- 检查网络是否正常使用 ping 命令

**检查网络是否正常效果图**

![查看网卡信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%25A3%2580%25E6%259F%25A5%25E7%25BD%2591%25E7%25BB%259C%25E6%2598%25AF%25E5%2590%25A6%25E6%25AD%25A3%25E5%25B8%25B8.png)

**说明:**

- ping www.baidu.com 检查是否能上公网
- ping 当前局域网的ip地址 检查是否在同一个局域网内
- ping 127.0.0.1 检查本地网卡是否正常

### 3. 小结

- IP 地址的作用是标识网络中唯一的一台设备的
- IP 地址的表现形式分为: IPv4 和 IPv6
- 查看网卡信息：ifconfig
- 检查网络： ping

# 端口和端口号的介绍

**学习目标**

- 能够说出端口和端口号的作用

------

### 1. 问题思考

不同电脑上的飞秋之间进行数据通信，它是如何保证把数据给飞秋而不是给其它软件呢?

**其实，每运行一个网络程序都会有一个端口，想要给对应的程序发送数据，找到对应的端口即可。**

**端口效果图:**

![端口](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E7%25AB%25AF%25E5%258F%25A3-1.png)

### 2. 什么是端口

**端口是传输数据的通道**，好比教室的门，**是数据传输必经之路**。

那么如何准确的找到对应的端口呢?

**其实，每一个端口都会有一个对应的端口号，好比每个教室的门都有一个门牌号，想要找到端口通过端口号即可。**

**端口号效果图:**

![端口](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E7%25AB%25AF%25E5%258F%25A3%25E5%258F%25B7.png)

### 3. 什么端口号

操作系统为了统一管理这么多端口，**就对端口进行了编号**，这就是端口号，**端口号其实就是一个数字**，好比我们现实生活中的门牌号,

端口号有65536个。

那么最终飞秋之间进行数据通信的流程是这样的，**通过ip地址找到对应的设备，通过端口号找到对应的端口，然后通过端口把数据传输给应用程序**。

**最终通信流程效果图:**

![通信流程](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E6%25B5%2581%25E7%25A8%258B.png)

### 4. 端口和端口号的关系

端口号可以标识唯一的一个端口。

### 5. 端口号的分类

- 知名端口号
- 动态端口号

**知名端口号:**

知名端口号是指**众所周知的端口号，范围从0到1023。**

- 这些端口号一般固定分配给一些服务，比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。

**动态端口号:**

一般程序员**开发应用程序使用端口号称为动态端口号, 范围是从1024到65535。**

- 如果程序员开发的程序没有设置端口号，操作系统会在动态端口号这个范围内随机生成一个给开发的应用程序使用。
- 当运行一个程序默认会有一个端口号，当这个程序退出时，所占用的这个端口号就会被释放。

### 5. 小结

- 端口的作用就是**给运行的应用程序提供传输数据的通道**。

- 端口号的作用是**用来区分和管理不同端口的，通过端口号能找到唯一个的一个端口**。

- 端口号可以分为两类：

   

  知名端口号

   

  和

   

  动态端口号

  - 知名端口号的范围是0到1023
  - 动态端口号的范围是1024到65535

# TCP 的介绍

**学习目标**

- 能够说出TCP 的特点

------

### 1. 网络应用程序之间的通信流程

之前我们学习了 IP 地址和端口号，通过 IP 地址能够找到对应的设备，然后再通过端口号找到对应的端口，再通过端口把数据传输给应用程序，**这里要注意，数据不能随便发送，在发送之前还需要选择一个对应的传输协议，保证程序之间按照指定的传输规则进行数据的通信，** 而这个传输协议就是我们今天学习的 TCP。

### 2. TCP 的概念

TCP 的英文全拼(Transmission Control Protocol)简称**传输控制协议**，它是一种**面向连接的、可靠的、基于字节流的传输层通信协议**。

**面向连接的效果图:**

![面向连接](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%259D%25A2%25E5%2590%2591%25E8%25BF%259E%25E6%258E%25A5.png)

**TCP 通信步骤:**

1. 创建连接
2. 传输数据
3. 关闭连接

**说明:**

TCP 通信模型相当于生活中的’打电话‘，在通信开始之前，一定要先建立好连接，才能发送数据，通信结束要关闭连接。

![面向连接](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%259D%25A2%25E5%2590%2591%25E8%25BF%259E%25E6%258E%25A52.png)

### 3. TCP 的特点

1. 面向连接
   - 通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。
2. 可靠传输
   - TCP 采用发送应答机制
   - 超时重传
   - 错误校验
   - 流量控制和阻塞管理

### 4. 总结

TCP 是一个**稳定、可靠的传输协议，常用于对数据进行准确无误的传输，比如: 文件下载，浏览器**

# socket 的介绍

**学习目标**

- 能够说出 socket 的作用

------

### 1. 问题思考

到目前为止我们学习了 ip 地址和端口号还有 tcp 传输协议，为了保证数据的完整性和可靠性我们使用 tcp 传输协议进行数据的传输，为了能够找到对应设备我们需要使用 ip 地址，为了区别某个端口的应用程序接收数据我们需要使用端口号，那么通信数据是如何完成传输的呢？

使用 **socket** 来完成

### 2. socket 的概念

socket (简称 套接字) 是**进程之间通信一个工具**，好比现实生活中的**插座**，所有的家用电器要想工作都是基于插座进行，**进程之间想要进行网络通信需要基于这个 socket**。

**插座效果图:**

![插座](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/socket1.png)

**socket 效果图:**

![socket](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/socket2.png)

### 3. socket 的作用

负责**进程之间的网络数据传输**，好比数据的搬运工。

### 4. socket 使用场景

不夸张的说，只要跟**网络相关的应用程序或者软件都使用到了 socket** 。

![socket使用场景](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/soft.png)

### 5. 小结

进程之间**网络数据的传输**可以通过 **socket** 来完成， **socket 就是进程间网络数据通信的工具。**

# TCP 网络应用程序开发流程

**学习目标**

- 能够知道TCP客户端程序的开发流程

------

### 1. TCP 网络应用程序开发流程的介绍

TCP 网络应用程序开发分为:

- TCP 客户端程序开发
- TCP 服务端程序开发

**说明:**

客户端程序是指运行在**用户设备上的程序** 服务端程序是指运行在**服务器设备上的程序**，专门为客户端提供数据服务。

### 2. TCP 客户端程序开发流程的介绍

![TCP客户端程序开发流程](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/tcp%25E7%25BD%2591%25E7%25BB%259C%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E7%259A%2584%25E5%25BC%2580%25E5%258F%2591%25E6%25B5%2581%25E7%25A8%258B.png)

**步骤说明:**

1. 创建客户端套接字对象
2. 和服务端套接字建立连接
3. 发送数据
4. 接收数据
5. 关闭客户端套接字

### 3. TCP 服务端程序开发流程的介绍

![TCP客户端程序开发流程](%E5%88%B7%E9%A2%98.assets/tcp%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-16624725725825.png)

![TCP客户端程序开发流程](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/tcp%25E7%25BD%2591%25E7%25BB%259C%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E7%259A%2584%25E5%25BC%2580%25E5%258F%2591%25E6%25B5%2581%25E7%25A8%258B.png)

**步骤说明:**

1. 创建服务端端套接字对象
2. 绑定端口号
3. 设置监听
4. 等待接受客户端的连接请求
5. 接收数据
6. 发送数据
7. 关闭套接字

### 4. 小结

1. TCP 网络应用程序开发分为**客户端程序开发**和**服务端程序开发**。
2. **主动发起建立连接请求的**是客户端程序
3. **等待接受连接请求的**是服务端程序

# TCP 客户端程序开发

**学习目标**

- 能够写出 TCP 客户端应用程序发送和接收消息

------

### 1. 开发 TCP 客户端程序开发步骤回顾

1. 创建客户端套接字对象
2. 和服务端套接字建立连接
3. 发送数据
4. 接收数据
5. 关闭客户端套接字

### 2. socket 类的介绍

导入 socket 模块 **import socket**

创建客户端 socket 对象 **socket.socket(AddressFamily, Type)**

**参数说明:**

- AddressFamily 表示IP地址类型, 分为TPv4和IPv6
- Type 表示传输协议类型

**方法说明:**

- connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号
- send(data) 表示发送数据，data是二进制数据
- recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度

### 3. TCP 客户端程序开发示例代码

```py
import socket


if __name__ == '__main__':
    # 创建tcp客户端套接字
    # 1. AF_INET：表示ipv4
    # 2. SOCK_STREAM: tcp传输协议
    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 和服务端应用程序建立连接
    tcp_client_socket.connect(("192.168.131.62", 8080))
    # 代码执行到此，说明连接建立成功
    # 准备发送的数据
    send_data = "你好服务端，我是客户端小黑!".encode("gbk")
    # 发送数据
    tcp_client_socket.send(send_data)
    # 接收数据, 这次接收的数据最大字节数是1024
    recv_data = tcp_client_socket.recv(1024)
    # 返回的直接是服务端程序发送的二进制数据
    print(recv_data)
    # 对数据进行解码
    recv_content = recv_data.decode("gbk")
    print("接收服务端的数据为:", recv_content)
    # 关闭套接字
    tcp_client_socket.close()
```

**执行结果:**

```py
b'hello'
接收服务端的数据为: hello
```

**说明**

1. str.encode(编码格式) 表示把字符串编码成为二进制
2. data.decode(编码格式) 表示把二进制解码成为字符串

**网络调试助手充当服务端程序:**

![网络调试助手](%E5%88%B7%E9%A2%98.assets/%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B-16624725945266.png)

![网络调试助手](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E7%25BD%2591%25E7%25BB%259C%25E8%25B0%2583%25E8%25AF%2595%25E5%258A%25A9%25E6%2589%258B.png)

### 4. 小结

1. 导入socket模块
2. 创建TCP套接字‘socket’
   - 参数1: ‘AF_INET’, 表示IPv4地址类型
   - 参数2: ‘SOCK_STREAM’, 表示TCP传输协议类型
3. 发送数据‘send’
   - 参数1: 要发送的二进制数据， 注意: 字符串需要使用encode()方法进行编码
4. 接收数据‘recv’
   - 参数1: 表示每次接收数据的大小，单位是字节
5. 关闭套接字‘socket’表示通信完成

# TCP服务端程序开发

**学习目标**

- 能够写出TCP服务端应用程序接收和发送消息

------

### 1. 开发 TCP 服务端程序开发步骤回顾

1. 创建服务端端套接字对象
2. 绑定端口号
3. 设置监听
4. 等待接受客户端的连接请求
5. 接收数据
6. 发送数据
7. 关闭套接字

### 2. socket 类的介绍

导入 socket 模块
**import socket**

创建服务端 socket 对象
**socket.socket(AddressFamily, Type)**

**参数说明:**

- AddressFamily 表示IP地址类型, 分为TPv4和IPv6
- Type 表示传输协议类型

**方法说明:**

- bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。
- listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。
- accept() 表示等待接受客户端的连接请求
- send(data) 表示发送数据，data 是二进制数据
- recv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度

### 3. TCP 服务端程序开发示例代码

```py
import socket

if __name__ == '__main__':
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用，让程序退出端口号立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) 
    # 给程序绑定端口号
    tcp_server_socket.bind(("", 8989))
    # 设置监听
    # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端，
    # 不需要让客户端进行等待建立连接
    # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成
    tcp_server_socket.listen(128)
    # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行
    # 1. 专门和客户端通信的套接字： service_client_socket
    # 2. 客户端的ip地址和端口号： ip_port
    service_client_socket, ip_port = tcp_server_socket.accept()
    # 代码执行到此说明连接建立成功
    print("客户端的ip地址和端口号:", ip_port)
    # 接收客户端发送的数据, 这次接收数据的最大字节数是1024
    recv_data = service_client_socket.recv(1024)
    # 获取数据的长度
    recv_data_length = len(recv_data)
    print("接收数据的长度为:", recv_data_length)
    # 对二进制数据进行解码
    recv_content = recv_data.decode("gbk")
    print("接收客户端的数据为:", recv_content)
    # 准备发送的数据
    send_data = "ok, 问题正在处理中...".encode("gbk")
    # 发送数据给客户端
    service_client_socket.send(send_data)
    # 关闭服务与客户端的套接字， 终止和客户端通信的服务
    service_client_socket.close()
    # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务
    tcp_server_socket.close()
```

**执行结果:**

```py
客户端的ip地址和端口号: ('172.16.47.209', 52472)
接收数据的长度为: 5
接收客户端的数据为: hello
```

**说明:**

当客户端和服务端建立连接后，**服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。**

解决办法有两种:

1. 更换服务端端口号
2. 设置端口号复用(推荐大家使用)，也就是说让服务端程序退出后端口号立即释放。

设置端口号复用的代码如下:

```py
# 参数1: 表示当前套接字
# 参数2: 设置端口号复用选项
# 参数3: 设置端口号复用选项对应的值
tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
```

**网络调试助手充当客户端程序:**

![网络调试助手](%E5%88%B7%E9%A2%98.assets/%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B-1-16624726164817.png)![网络调试助手](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E7%25BD%2591%25E7%25BB%259C%25E8%25B0%2583%25E8%25AF%2595%25E5%258A%25A9%25E6%2589%258B-1.png)

### 4. 小结

1. 导入socket模块
2. 创建TCP套接字‘socket’
   - 参数1: ‘AF_INET’, 表示IPv4地址类型
   - 参数2: ‘SOCK_STREAM’, 表示TCP传输协议类型
3. 绑定端口号‘bind’
   - 参数: 元组, 比如:(ip地址, 端口号)
4. 设置监听‘listen’
   - 参数: 最大等待建立连接的个数
5. 等待接受客户端的连接请求‘accept’
6. 发送数据‘send’
   - 参数: 要发送的二进制数据， 注意: 字符串需要使用encode()方法进行编码
7. 接收数据‘recv’
   - 参数: 表示每次接收数据的大小，单位是字节，注意: 解码成字符串使用decode()方法
8. 关闭套接字‘socket’表示通信完成

# TCP网络应用程序的注意点

**学习目标**

- 能够说出开发TCP网络应用程序的注意点

------

### 1. TCP网络应用程序的注意点介绍

1. 当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先**建立连接**
2. TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。
3. **TCP 服务端程序必须绑定端口号**，否则客户端找不到这个 TCP 服务端程序。
4. listen 后的套接字是被动套接字，**只负责接收新的客户端的连接请求，不能收发消息。**
5. 当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个**新的套接字**，收发客户端消息使用该套接字。
6. **关闭 accept 返回的套接字意味着和这个客户端已经通信完毕**。
7. **关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。**
8. **当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0**，服务端可以通过返回数据的长度来判断客户端是否已经下线，反之**服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0**。

# 案例-多任务版TCP服务端程序开发

**学习目标**

- 能够说出多任务版TCP服务端程序的实现过程

------

### 1. 需求

目前我们开发的TCP服务端程序只能服务于一个客户端，如何开发一个多任务版的TCP服务端程序能够服务于多个客户端呢?

完成多任务，可以使用**线程**，比进程更加节省内存资源。

### 2. 具体实现步骤

1. 编写一个TCP服务端程序，循环等待接受客户端的连接请求
2. 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞
3. 把创建的子线程设置成为守护主线程，防止主线程无法退出。

### 3. 多任务版TCP服务端程序的示例代码:

```python
import socket
import threading


# 处理客户端的请求操作
def handle_client_request(service_client_socket, ip_port):
    # 循环接收客户端发送的数据
    while True:
        # 接收客户端发送的数据
        recv_data = service_client_socket.recv(1024)
        # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败
        # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据
        if recv_data:
            print(recv_data.decode("gbk"), ip_port)
            # 回复
            service_client_socket.send("ok，问题正在处理中...".encode("gbk"))

        else:
            print("客户端下线了:", ip_port)
            break
    # 终止和客户端进行通信
    service_client_socket.close()


if __name__ == '__main__':
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用，让程序退出端口号立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind(("", 9090))
    # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求
    tcp_server_socket.listen(128)
    # 循环等待接收客户端的连接请求
    while True:
        # 等待接收客户端的连接请求
        service_client_socket, ip_port = tcp_server_socket.accept()
        print("客户端连接成功:", ip_port)
        # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息
        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))
        # 设置守护主线程
        sub_thread.setDaemon(True)
        # 启动子线程
        sub_thread.start()


    # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行
    # tcp_server_socket.close()
```

**执行结果:**

```python
客户端连接成功: ('172.16.47.209', 51528)
客户端连接成功: ('172.16.47.209', 51714)
hello1 ('172.16.47.209', 51528)
hello2 ('172.16.47.209', 51714)
```

### 4. 小结

1. 编写一个TCP服务端程序，循环等待接受客户端的连接请求

   ```python
    while True:
        service_client_socket, ip_port = tcp_server_socket.accept()
   ```

2. 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞

   ```python
    while True:
        service_client_socket, ip_port = tcp_server_socket.accept() 
        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))
        sub_thread.start()
   ```

3. 把创建的子线程设置成为守护主线程，防止主线程无法退出。

   ```python
    while True:
        service_client_socket, ip_port = tcp_server_socket.accept() 
        sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port))
        sub_thread.setDaemon(True) 
        sub_thread.start()
   ```

# socket之send和recv原理剖析

**学习目标**

- 能够知道send和recv的底层工作原理

------

### 1. 认识TCP socket的发送和接收缓冲区

当创建一个TCP socket对象的时候会有一个**发送缓冲区**和一个**接收缓冲区**，**这个发送和接收缓冲区指的就是内存中的一片空间。**

### 2. send原理剖析

send是不是直接把数据发给服务端?

不是，要想发数据，必须得**通过网卡发送数据**，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到**发送缓冲区**(内存中的一片空间)，再**由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡** 。

### 3. recv原理剖析

recv是不是直接从客户端接收数据?

不是，**应用软件是无法直接通过网卡接收数据的**，它需要调用操作系统接口，**由操作系统通过网卡接收数据**，把接收的数据**写入到接收缓冲区**(内存中的一片空间），应用程序**再从接收缓存区获取客户端发送的数据**。

### 4. send和recv原理剖析图

![send和recv原理剖析图](%E5%88%B7%E9%A2%98.assets/send%E5%92%8Crecv%E5%8E%9F%E7%90%86-16624726926618.png)![send和recv原理剖析图](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/send%25E5%2592%258Crecv%25E5%258E%259F%25E7%2590%2586.png)

**说明:**

- 发送数据是发送到发送缓冲区
- 接收数据是从接收缓冲区 获取

### 5. 小结

不管是recv还是send都不是直接接收到对方的数据和发送数据到对方，**发送数据会写入到发送缓冲区，接收数据是从接收缓冲区来读取，发送数据和接收数据最终是由操作系统控制网卡来完成。**

# TTP 协议

**学习目标**

- 能够知道 HTTP 协议的作用

------

### 1. HTTP 协议的介绍

HTTP 协议的全称是(HyperText Transfer Protocol)，翻译过来就是**超文本传输协议**。

超文本是超级文本的缩写，是指超越文本限制或者超链接，比如:图片、音乐、视频、超链接等等都属于超文本。

HTTP 协议的制作者是**蒂姆·伯纳斯-李**，1991年设计出来的，**HTTP 协议设计之前目的是传输网页数据的，现在允许传输任意类型的数据**。

**传输 HTTP 协议格式的数据是基于 TCP 传输协议的，发送数据之前需要先建立连接。**

### 2. HTTP 协议的作用

它**规定了浏览器和 Web 服务器通信数据的格式，也就是说浏览器和web服务器通信需要使用http协议**。

### 3. 浏览器访问web服务器的通信过程

**通信效果图:**

![通信效果图](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E8%25AE%25BF%25E9%2597%25AEweb%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E7%259A%2584%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B.png)![通信效果图](%E5%88%B7%E9%A2%98.assets/%E8%AE%BF%E9%97%AEweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B-16624727485449.png)

### 4. 小结

- HTTP协议是一个超文本传输协议
- HTTP协议是一个基于TCP传输协议传输数据的
- HTTP协议规定了浏览器和 Web 服务器通信数据的格式

# URL

**学习目标**

- 能够知道URL的组成部分

------

### 1. URL的概念

URL的英文全拼是(Uniform Resoure Locator),表达的意思是统一资源定位符，通俗理解就是网络资源地址，也就是我们常说的网址。

### 2. URL的组成

**URL的样子:**

https://news.163.com/18/1122/10/E178J2O4000189FH.html

**URL的组成部分:**

1. **协议部分**: https://、http://、ftp://
2. **域名部分**: news.163.com
3. **资源路径部分**: /18/1122/10/E178J2O4000189FH.html

**域名:**

域名就是**IP地址的别名**，它是用点进行分割使用英文字母和数字组成的名字，**使用域名目的就是方便的记住某台主机IP地址**。

**URL的扩展:**

https://news.163.com/hello.html?page=1&count=10

- **查询参数部分**: ?page=1&count=10

**参数说明:**

- ? 后面的 page 表示第一个参数，后面的参数都使用 & 进行连接

### 3. 小结

- URL就是网络资源的地址，简称网址，通过URL能够找到网络中对应的资源数据。
- URL组成部分
  1. 协议部分
  2. 域名部分
  3. 资源路径部分
  4. 查询参数部分 [可选]

# 查看HTTP协议的通信过程

**学习目标**

- 能够使用谷歌浏览器的开发者工具查看HTTP协议的通信过程

------

### 1. 谷歌浏览器开发者工具的使用

首先需要安装Google Chrome浏览器，然后Windows和Linux平台按**F12**调出开发者工具, mac OS选择 视图 -> 开发者 -> 开发者工具或者直接使用 **alt+command+i** 这个快捷键，还有一个多平台通用的操作就是在**网页右击选择检查**。

**开发者工具的效果图:**

![标签说明](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-1.png)

**开发者工具的标签选项说明:**

- 元素（Elements）：用于查看或修改HTML标签
- 控制台（Console）：执行js代码
- 源代码（Sources）：查看静态资源文件，断点调试JS代码
- 网络（Network）：查看http协议的通信过程

**开发者工具使用效果图:**

![使用说明](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-2.png)

**开发者工具的使用说明:**

1. 点击Network标签选项
2. 在浏览器的地址栏输入百度的网址，就能看到请求百度首页的http的通信过程
3. **这里的每项记录都是请求+响应的一次过程**

### 2. 查看HTTP协议的通信过程

**查看http请求信息效果图:**

![查看http请求信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-3.png) ![查看http请求信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-4.png)

**查看http响应信息效果图:**

![查看http请求信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-5.png) ![查看http请求信息](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B-6.png)

### 3. 小结

- 谷歌浏览器的开发者工具是查看http协议的通信过程利器，通过Network标签选项可以查看每一次的请求和响应的通信过程，调出开发者工具的通用方法是在网页右击选择检查。
- 开发者工具的Headers选项总共有三部分组成:
  1. General: 主要信息
  2. Response Headers: 响应头
  3. Request Headers: 请求头
- Response选项是查看响应体信息的

# HTTP 请求报文

**学习目标**

- 能够知道HTTP请求报文的结构

------

### 1. HTTP 请求报文介绍

**HTTP最常见的请求报文有两种:**

1. GET 方式的请求报文
2. POST 方式的请求报文

**说明:**

- GET: 获取web服务器数据
- POST: 向web服务器提交数据

### 2. HTTP GET 请求报文分析

**HTTP GET 请求报文效果图:**

![GET请求报文分析](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/get%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587%25E5%2588%2586%25E6%259E%2590.png)

**GET 请求报文说明:**

```http
---- 请求行 ----
GET / HTTP/1.1  # GET请求方式 请求资源路径 HTTP协议版本
---- 请求头 -----
Host: www.itcast.cn  # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Upgrade-Insecure-Requests: 1 # 让浏览器升级不安全请求，使用https请求
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36  # 用户代理，也就是客户端的名称
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 # 可接受的数据类型
Accept-Encoding: gzip, deflate # 可接受的压缩格式
Accept-Language: zh-CN,zh;q=0.9 #可接受的语言
Cookie: pgv_pvi=1246921728; # 登录用户的身份标识

---- 空行 ----
```

**GET 请求原始报文说明:**

```http
GET / HTTP/1.1\r\n
Host: www.itcast.cn\r\n  
Connection: keep-alive\r\n
Upgrade-Insecure-Requests: 1\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: zh-CN,zh;q=0.9\r\n
Cookie: pgv_pvi=1246921728; \r\n
\r\n  (请求头信息后面还有一个单独的’\r\n’不能省略)
```

**说明：**

- 每项数据之间使用:**\r\n**

### 3. HTTP POST 请求报文分析

**HTTP POST 请求报文效果图:**

![GET请求报文分析](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/post%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587%25E5%2588%2586%25E6%259E%2590.png)

**请求体效果图:**

![GET请求报文分析](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/post%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587%25E5%2588%2586%25E6%259E%2590-1.png)

**POST 请求报文说明:**

```http
---- 请求行 ----
POST /xmweb?host=mail.itcast.cn&_t=1542884567319 HTTP/1.1 # POST请求方式 请求资源路径 HTTP协议版本
---- 请求头 ----
Host: mail.itcast.cn # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Content-Type: application/x-www-form-urlencoded  # 告诉服务端请求的数据类型
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 # 客户端的名称
---- 空行 ----
---- 请求体 ----
username=hello&pass=hello # 请求参数
```

**POST 请求原始报文说明:**

```http
POST /xmweb?host=mail.itcast.cn&_t=1542884567319 HTTP/1.1\r\n
Host: mail.itcast.cn\r\n
Connection: keep-alive\r\n
Content-Type: application/x-www-form-urlencoded\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\n
\r\n(请求头信息后面还有一个单独的’\r\n’不能省略)
username=hello&pass=hello
```

**说明：**

- 每项数据之间使用:**\r\n**

### 4. 小结

- 一个HTTP请求报文可以由**请求行、请求头、空行和请求体**4个部分组成。
- 请求行是由三部分组成:
  1. **请求方式**
  2. **请求资源路径**
  3. **HTTP协议版本**
- **GET方式的请求报文没有请求体，只有请求行、请求头、空行组成**。
- **POST方式的请求报文可以有请求行、请求头、空行、请求体四部分组成，注意:POST方式可以允许没有请求体，但是这种格式很少见**。

**GET和POST请求对比效果图:**

![GGET和POST请求报文对比](%E5%88%B7%E9%A2%98.assets/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-166247280727110.png)![GGET和POST请求报文对比](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/get%25E5%2592%258Cpost%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587.png)

# HTTP响应报文

**学习目标**

- 能够知道HTTP响应报文的结构

------

### 1. HTTP响应报文分析

**HTTP 响应报文效果图:**

![HTTP 响应报文](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E5%2593%258D%25E5%25BA%2594%25E6%258A%25A5%25E6%2596%2587-1.png)
![HTTP 响应报文](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E5%2593%258D%25E5%25BA%2594%25E6%258A%25A5%25E6%2596%2587-2.png)

**响应报文说明:**

```http
--- 响应行/状态行 ---
HTTP/1.1 200 OK # HTTP协议版本 状态码 状态描述
--- 响应头 ---
Server: Tengine # 服务器名称
Content-Type: text/html; charset=UTF-8 # 内容类型
Transfer-Encoding: chunked # 发送给客户端内容不确定内容长度，发送结束的标记是0\r\n, Content-Length表示服务端确定发送给客户端的内容大小，但是二者只能用其一。
Connection: keep-alive # 和客户端保持长连接
Date: Fri, 23 Nov 2018 02:01:05 GMT # 服务端的响应时间
--- 空行 ---
--- 响应体 ---
<!DOCTYPE html><html lang=“en”> …</html> # 响应给客户端的数据
```

**原始响应报文说明:**

```http
HTTP/1.1 200 OK\r\n
Server: Tengine\r\n
Content-Type: text/html; charset=UTF-8\r\n
Transfer-Encoding: chunked\r\n
Connection: keep-alive\r\n
Date: Fri, 23 Nov 2018 02:01:05 GMT\r\n
\r\n(响应头信息后面还有一个单独的’\r\n’不能省略)
<!DOCTYPE html><html lang=“en”> …</html>
```

**说明:**

每项数据之间使用:**\r\n**

### 2. HTTP 状态码介绍

HTTP 状态码是**用于表示web服务器响应状态的3位数字代码**。

| 状态码 | 说明                             |
| :----- | :------------------------------- |
| 200    | 请求成功                         |
| 307    | 重定向                           |
| 400    | 错误的请求，请求地址或者参数有误 |
| 404    | 请求资源在服务器不存在           |
| 500    | 服务器内部源代码出现错误         |

### 3. 小结

- 一个HTTP响应报文是由**响应行、响应头、空行和响应体**4个部分组成。 ![HTTP 响应报文](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E5%2593%258D%25E5%25BA%2594%25E6%258A%25A5%25E6%2596%2587.png)
- 响应行是由三部分组成：**HTTP协议版本 状态码 状态描述**，最常见的状态码是200

# 搭建Python自带静态Web服务器

**学习目标**

- 能够知道搭建Python自带Web服务器

------

### 1. 静态Web服务器是什么？

可以**为发出请求的浏览器提供静态文档的程序**。

平时我们浏览百度新闻数据的时候，**每天的新闻数据都会发生变化，那访问的这个页面就是动态的**，而我们开发的是**静态的，页面的数据不会发生变化**。

### 2. 如何搭建Python自带的静态Web服务器

搭建Python自带的静态Web服务器使用 **python3 -m http.server 端口号**, 效果图如下:![搭建web服务器](%E5%88%B7%E9%A2%98.assets/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8-166247287063812.png)

![搭建web服务器](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%2590%25AD%25E5%25BB%25BAweb%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8.png)

**-m选项说明:![搭建web服务器](%E5%88%B7%E9%A2%98.assets/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8-166247287063812.png)**

-m表示**运行包里面的模块**，执行这个命令的时候，需要进入你**自己指定静态文件的目录**，然后通过浏览器就能访问对应的 html文件了，这样一个静态的web服务器就搭建好了。

### 3. 访问搭建的静态Web服务器

通过浏览器访问搭建的静态Web服务器，效果图如下:

![搭建web服务器](%E5%88%B7%E9%A2%98.assets/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8-166247284954311.png)![搭建web服务器](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%2590%25AD%25E5%25BB%25BAweb%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8.png)

### 4. 查看浏览器和搭建的静态Web服务器的通信过程

查看http的通信过程,效果图如下:

![搭建web服务器](%E5%88%B7%E9%A2%98.assets/%E9%9D%99%E6%80%81web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B-166247289325714.png)![搭建web服务器](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%259D%2599%25E6%2580%2581web%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E7%259A%2584%25E9%2580%259A%25E4%25BF%25A1%25E8%25BF%2587%25E7%25A8%258B.png)

### 5. 小结

- 静态Web服务器是为发出请求的浏览器提供静态文档的程序，
- 搭建Python自带的Web服务器使用python3 –m http.server 端口号 这个命令即可，端口号不指定默认是8000

# 静态Web服务器-返回固定页面数据

**学习目标**

- 能够写出组装固定页面数据的响应报文

------

### 1. 开发自己的静态Web服务器

**实现步骤:**

1. 编写一个TCP服务端程序
2. 获取浏览器发送的http请求报文数据
3. 读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。
4. HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。

### 2. 静态Web服务器-返回固定页面数据的示例代码

```py
import socket


if __name__ == '__main__':
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind(("", 9000))
    # 设置监听
    tcp_server_socket.listen(128)
    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode("utf-8")
        print(recv_client_content)

        with open("static/index.html", "rb") as file:
            # 读取文件数据
            file_data = file.read()


        # 响应行
        response_line = "HTTP/1.1 200 OK\r\n"
        # 响应头
        response_header = "Server: PWS1.0\r\n"

        # 响应体
        response_body = file_data

        # 拼接响应报文
        response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
        # 发送数据
        new_socket.send(response_data)

        # 关闭服务与客户端的套接字
        new_socket.close()
```

### 3. 小结

1. 编写一个TCP服务端程序

   ```py
   tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   # 循环接受客户端的连接请求
   while True:
       conn_socket, ip_port = tcp_server_socket.accept()
   ```

2. 获取浏览器发送的http请求报文数据

   ```py
   client_request_data = conn_socket.recv(4096)
   ```

3. 读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。

   ```py
   response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
   conn_socket.send(response_data)
   ```

4. HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。

   ```py
   conn_socket.close()
   ```

# 静态Web服务器-返回指定页面数据

**学习目标**

- 能够写出组装指定页面数据的响应报文

------

### 1. 静态Web服务器的问题

![问题](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E9%259D%2599%25E6%2580%2581web%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E9%2597%25AE%25E9%25A2%2598.png)

目前的Web服务器，不管用户访问什么页面，返回的都是固定页面的数据，接下来需要根据用户的请求返回指定页面的数据

**返回指定页面数据的实现步骤:**

1. 获取用户请求资源的路径
2. 根据请求资源的路径，读取指定文件的数据
3. 组装指定文件数据的响应报文，发送给浏览器
4. 判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器

### 2. 静态Web服务器-返回指定页面数据的示例代码

```py
import socket


def main():
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind(("", 9000))
    # 设置监听
    tcp_server_socket.listen(128)
    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print("关闭浏览器了")
            new_socket.close()
            return

        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode("utf-8")
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(" ", maxsplit=2)

        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)

        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == "/":
            request_path = "/index.html"

        try:
            # 动态打开指定文件
            with open("static" + request_path, "rb") as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = "HTTP/1.1 404 Not Found\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"
            with open("static/error.html", "rb") as file:
                file_data = file.read()
            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = "HTTP/1.1 200 OK\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"

            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

if __name__ == '__main__':
    main()
```

### 3. 小结

1. 获取用户请求资源的路径

   ```py
    request_list = client_request_conent.split(” ”,  maxsplit=2)
    request_path = request_list[1]
   ```

2. 根据请求资源的路径，读取请求指定文件的数据

   ```py
    with open("static" + request_path, "rb") as file:
    file_data = file.read()
   ```

3. 组装指定文件数据的响应报文，发送给浏览器

   ```py
    response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
    conn_socket.send(response_data)
   ```

4. 判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器

   ```py
    try:
        # 打开指定文件,代码省略...
    except Exception as e:
        conn_socket.send(404响应报文数据)
   ```

# 静态Web服务器-多任务版

**学习目标**

- 能够写出多线程版的多任务web服务器程序

------

### 1. 静态Web服务器的问题

目前的Web服务器，不能支持多用户同时访问，只能一个一个的处理客户端的请求，那么如何开发多任务版的web服务器同时处理 多个客户端的请求?

可以使用**多线程**，比进程更加节省内存资源。

**多任务版web服务器程序的实现步骤:**

1. 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。
2. 把创建的子线程设置成为守护主线程，防止主线程无法退出。

### 2. 静态Web服务器-多任务版的示例代码

```py
import socket
import threading


# 处理客户端的请求
def handle_client_request(new_socket):
    # 代码执行到此，说明连接建立成功
    recv_client_data = new_socket.recv(4096)
    if len(recv_client_data) == 0:
        print("关闭浏览器了")
        new_socket.close()
        return

    # 对二进制数据进行解码
    recv_client_content = recv_client_data.decode("utf-8")
    print(recv_client_content)
    # 根据指定字符串进行分割， 最大分割次数指定2
    request_list = recv_client_content.split(" ", maxsplit=2)

    # 获取请求资源路径
    request_path = request_list[1]
    print(request_path)

    # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
    if request_path == "/":
        request_path = "/index.html"

    try:
        # 动态打开指定文件
        with open("static" + request_path, "rb") as file:
            # 读取文件数据
            file_data = file.read()
    except Exception as e:
        # 请求资源不存在，返回404数据
        # 响应行
        response_line = "HTTP/1.1 404 Not Found\r\n"
        # 响应头
        response_header = "Server: PWS1.0\r\n"
        with open("static/error.html", "rb") as file:
            file_data = file.read()
        # 响应体
        response_body = file_data

        # 拼接响应报文
        response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
        # 发送数据
        new_socket.send(response_data)
    else:
        # 响应行
        response_line = "HTTP/1.1 200 OK\r\n"
        # 响应头
        response_header = "Server: PWS1.0\r\n"

        # 响应体
        response_body = file_data

        # 拼接响应报文
        response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
        # 发送数据
        new_socket.send(response_data)
    finally:
        # 关闭服务与客户端的套接字
        new_socket.close()


# 程序入口函数
def main():
    # 创建tcp服务端套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # 设置端口号复用, 程序退出端口立即释放
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    # 绑定端口号
    tcp_server_socket.bind(("", 9000))
    # 设置监听
    tcp_server_socket.listen(128)

    while True:
        # 等待接受客户端的连接请求
        new_socket, ip_port = tcp_server_socket.accept()
        print(ip_port)
        # 当客户端和服务器建立连接程，创建子线程
        sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,))
        # 设置守护主线程
        sub_thread.setDaemon(True)
        # 启动子线程执行对应的任务
        sub_thread.start()


if __name__ == '__main__':
    main()
```

### 3. 小结

1. 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。

   ```py
    while True:
        conn_socket, ip_port = tcp_server_socket.accept()
        # 开辟子线程并执行对应的任务
        sub_thread = threading.Thread(target=handle_client_request, args=(conn_socket,))
   ```

2. 把创建的子线程设置成为守护主线程，防止主线程无法退出。

   ```py
    # 开辟子线程并执行对应的任务
    sub_thread = threading.Thread(target=handle_client_request, args=(conn_socket,))
    sub_thread.setDaemon(True) # 设置守护主线程
    sub_thread.start()
   ```

# 静态Web服务器-面向对象开发

**学习目标**

- 能够写出面向对象方式的多任务web服务器程序

------

### 1. 以面向对象的方式开发静态Web服务器

**实现步骤:**

1. 把提供服务的Web服务器抽象成一个类(HTTPWebServer)
2. 提供Web服务器的初始化方法，在初始化方法里面创建socket对象
3. 提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。

### 2. 静态Web服务器-面向对象开发的示例代码

```py
import socket
import threading


# 定义web服务器类
class HttpWebServer(object):
    def __init__(self):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind(("", 9000))
        # 设置监听
        tcp_server_socket.listen(128)
        # 保存创建成功的服务器套接字
        self.tcp_server_socket = tcp_server_socket

    # 处理客户端的请求
    @staticmethod
    def handle_client_request(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print("关闭浏览器了")
            new_socket.close()
            return

        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode("utf-8")
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(" ", maxsplit=2)

        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)

        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == "/":
            request_path = "/index.html"

        try:
            # 动态打开指定文件
            with open("static" + request_path, "rb") as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = "HTTP/1.1 404 Not Found\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"
            with open("static/error.html", "rb") as file:
                file_data = file.read()
            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = "HTTP/1.1 200 OK\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"

            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

    # 启动web服务器进行工作
    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            # 当客户端和服务器建立连接程，创建子线程
            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))
            # 设置守护主线程
            sub_thread.setDaemon(True)
            # 启动子线程执行对应的任务
            sub_thread.start()


# 程序入口函数
def main():
    # 创建web服务器对象
    web_server = HttpWebServer()
    # 启动web服务器进行工作
    web_server.start()


if __name__ == '__main__':
    main()
```

### 3. 小结

1. 把提供服务的Web服务器抽象成一个类(HTTPWebServer)

   ```py
    class HttpWebServer(object):
   ```

2. 提供Web服务器的初始化方法，在初始化方法里面创建socket对象

   ```py
    def __init__(self):
    # 初始化服务端套接字，设置监听，代码省略..
   ```

3. 提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。

   ```py
    def start(self):
    while True:
        service_client_socket, ip_port = self.tcp_server_socket.accept()
        # 连接建立成功，开辟子线程处理客户端的请求
        sub_thread = threading.Thread(target=self.handle_client_request, args=(service_client_socket,))
        sub_thread.start()
   ```

# 静态Web服务器-命令行启动动态绑定端口号

**学习目标**

- 能够写出获取终端命令行参数动态绑定端口号的web服务器程序

### 1. 开发命令行启动动态绑定端口号的静态web服务器

**实现步骤:**

1. 获取执行python程序的终端命令行参数
2. 判断参数的类型，设置端口号必须是整型
3. 给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号

### 2. 静态Web服务器-命令行启动动态绑定端口号的示例代码

```py
import socket
import threading
import sys


# 定义web服务器类
class HttpWebServer(object):
    def __init__(self, port):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind(("", port))
        # 设置监听
        tcp_server_socket.listen(128)
        # 保存创建成功的服务器套接字
        self.tcp_server_socket = tcp_server_socket

    # 处理客户端的请求
    @staticmethod
    def handle_client_request(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print("关闭浏览器了")
            new_socket.close()
            return

        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode("utf-8")
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(" ", maxsplit=2)

        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)

        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == "/":
            request_path = "/index.html"

        try:
            # 动态打开指定文件
            with open("static" + request_path, "rb") as file:
                # 读取文件数据
                file_data = file.read()
        except Exception as e:
            # 请求资源不存在，返回404数据
            # 响应行
            response_line = "HTTP/1.1 404 Not Found\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"
            with open("static/error.html", "rb") as file:
                file_data = file.read()
            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        else:
            # 响应行
            response_line = "HTTP/1.1 200 OK\r\n"
            # 响应头
            response_header = "Server: PWS1.0\r\n"

            # 响应体
            response_body = file_data

            # 拼接响应报文
            response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
            # 发送数据
            new_socket.send(response_data)
        finally:
            # 关闭服务与客户端的套接字
            new_socket.close()

    # 启动web服务器进行工作
    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            # 当客户端和服务器建立连接程，创建子线程
            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))
            # 设置守护主线程
            sub_thread.setDaemon(True)
            # 启动子线程执行对应的任务
            sub_thread.start()


# 程序入口函数
def main():

    print(sys.argv)
    # 判断命令行参数是否等于2,
    if len(sys.argv) != 2:
        print("执行命令如下: python3 xxx.py 8000")
        return

    # 判断字符串是否都是数字组成
    if not sys.argv[1].isdigit():
        print("执行命令如下: python3 xxx.py 8000")
        return

    # 获取终端命令行参数
    port = int(sys.argv[1])
    # 创建web服务器对象
    web_server = HttpWebServer(port)
    # 启动web服务器进行工作
    web_server.start()


if __name__ == '__main__':
    main()
```

### 3. 小结

1. 获取执行python程序的终端命令行参数

   ```py
    sys.argv
   ```

2. 判断参数的类型，设置端口号必须是整型

   ```py
    if not sys.argv[1].isdigit():
        print("启动命令如下: python3 xxx.py 9090")
        return
    port = int(sys.argv[1])
   ```

3. 给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号

   ```py
    def __init__(self, port):
        self.tcp_server_socket.bind((“”, port))
   ```

# 闭包

**学习目标**

- 能够知道闭包的构成条件
- 能够知道定义闭包的语法格式

------

### 1. 闭包的介绍

我们前面已经学过了函数，我们知道当函数调用完，函数内定义的变量都销毁了，但是我们有时候需要保存函数内的这个变量，每次在这个变量的基础上完成一些列的操作，比如: 每次在这个变量的基础上和其它数字进行求和计算，那怎么办呢?

我们就可以通过咱们今天学习的**闭包**来解决这个需求。

**闭包的定义:**

在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个**使用外部函数变量的内部函数称为闭包**。

### 2. 闭包的构成条件

通过闭包的定义，我们可以得知闭包的形成条件:

1. 在函数嵌套(函数里面再定义函数)的前提下
2. 内部函数使用了外部函数的变量(还包括外部函数的参数)
3. 外部函数返回了内部函数

### 3. 简单闭包的示例代码

```py
# 定义一个外部函数
def func_out(num1):
    # 定义一个内部函数
    def func_inner(num2):
        # 内部函数使用了外部函数的变量(num1)
        result = num1 + num2
        print("结果是:", result)
    # 外部函数返回了内部函数，这里返回的内部函数就是闭包
    return func_inner

# 创建闭包实例    
f = func_out(1)
# 执行闭包
f(2)
f(3)
```

**运行结果:**

```py
结果是: 3
结果是: 4
```

**闭包执行结果的说明:**

通过上面的输出结果可以看出闭包保存了外部函数内的变量num1，每次执行闭包都是在num1 = 1 基础上进行计算。

### 4. 闭包的作用

- 闭包可以保存外部函数内的变量，不会随着外部函数调用完而销毁。

**注意点:**

- 由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。

### 5. 小结

1. 当返回的内部函数使用了外部函数的变量就形成了闭包

2. 闭包可以对外部函数的变量进行保存

3. 实现闭包的标准格式:

   ```py
    # 外部函数
    def test1(a):
        b = 10
        # 内部函数
        def test2():
            # 内部函数使用了外部函数的变量或者参数
            print(a, b)
        # 返回内部函数, 这里返回的内部函数就是闭包实例
        return test2
   ```

# 闭包的使用

**学习目标**

- 能够知道闭包的作用

------

### 1. 案例

需求: 根据配置信息使用闭包实现不同人的对话信息，例如对话:

张三: 到北京了吗? 李四: 已经到了，放心吧。

### 2. 实现步骤说明

1. 定义外部函数接收不同的配置信息参数，参数是人名
2. 定义内部函数接收对话信息参数
3. 在内部函数里面把配置信息和对话信息进行拼接输出

### 3. 功能代码的实现

```py
# 外部函数
def config_name(name):
    # 内部函数
    def say_info(info):
        print(name + ": " + info)

    return say_info

tom = config_name("Tom")

tom("你好!")
tom("你好, 在吗?")

jerry = config_name("jerry")

jerry("不在, 不和玩!")
```

**运行结果:**

```py
Tom: 你好!
Tom: 你好, 在吗?
jerry: 不在, 不和玩!
```

**闭包案例说明:**

- 闭包还可以提高代码的可重用性，不需要再手动定义额外的功能函数。

### 5. 小结

- 闭包不仅可以保存外部函数的变量还可以提高代码的可重用行。

# 修改闭包内使用的外部变量

**学习目标**

- 能够知道修改闭包内使用的外部变量所需要的关键字

------

### 1. 修改闭包内使用的外部变量

**修改闭包内使用的外部变量的错误示例:**

```py
# 定义一个外部函数
def func_out(num1):

    # 定义一个内部函数
    def func_inner(num2):
        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1
        num1 = 10
        # 内部函数使用了外部函数的变量(num1)
        result = num1 + num2
        print("结果是:", result)

    print(num1)
    func_inner(1)
    print(num1)

    # 外部函数返回了内部函数，这里返回的内部函数就是闭包
    return func_inner

# 创建闭包实例
f = func_out(1)
# 执行闭包
f(2)
```

**修改闭包内使用的外部变量的错误示例:**

```py
# 定义一个外部函数
def func_out(num1):

    # 定义一个内部函数
    def func_inner(num2):
        # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1
        nonlocal num1  # 告诉解释器，此处使用的是 外部变量a
        # 修改外部变量num1
        num1 = 10
        # 内部函数使用了外部函数的变量(num1)
        result = num1 + num2
        print("结果是:", result)

    print(num1)
    func_inner(1)
    print(num1)

    # 外部函数返回了内部函数，这里返回的内部函数就是闭包
    return func_inner

# 创建闭包实例
f = func_out(1)
# 执行闭包
f(2)
```

### 2. 小结

- 修改闭包内使用的外部函数变量使用 nonlocal 关键字来完成。

# 装饰器

**学习目标**

- 能够知道定义装饰器的语法格式

------

### 1. 装饰器的定义

就是**给已有函数增加额外功能的函数，它本质上就是一个闭包函数**。

**装饰器的功能特点:**

1. 不修改已有函数的源代码
2. 不修改已有函数的调用方式
3. 给已有函数增加额外的功能

### 2. 装饰器的示例代码

```py
# 添加一个登录验证的功能
def check(fn):
    def inner():
        print("请先登录....")
        fn()
    return inner


def comment():
    print("发表评论")

# 使用装饰器来装饰函数
comment = check(comment)
comment()

# 装饰器的基本雏形
# def decorator(fn): # fn:目标函数.
#     def inner():
#         '''执行函数之前'''
#         fn() # 执行被装饰的函数
#         '''执行函数之后'''
#     return inner
```

**代码说明:**

- 闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。
- 写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。

**执行结果:**

```py
请先登录....
发表评论
```

### 3. 装饰器的语法糖写法

如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。

Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰

```py
# 添加一个登录验证的功能
def check(fn):
    print("装饰器函数执行了")
    def inner():
        print("请先登录....")
        fn()
    return inner

# 使用语法糖方式来装饰函数
@check
def comment():
    print("发表评论")


comment()
```

**说明:**

- @check 等价于 comment = check(comment)
- 装饰器的执行时间是加载模块时立即执行。

**执行结果:**

```py
请先登录....
发表评论
```

### 4. 小结

- 装饰器本质上就是一个闭包函数，它可以对已有函数进行额外的功能扩展。

- 装饰器的语法格式:

  ```py
  # 装饰器
  # def decorator(fn): # fn:被装饰的目标函数.
  #     def inner():
  #         '''执行函数之前'''
  #         fn() # 执行被装饰的目标函数
  #         '''执行函数之后'''
  #     return inner
  ```

- 装饰器的语法糖用法: @装饰器名称，同样可以完成对已有函数的装饰操作。

# 装饰器的使用

**学习目标**

- 能够说出装饰器的作用

------

### 1. 装饰器的使用场景

1. 函数执行时间的统计
2. 输出日志信息

### 2. 装饰器实现已有函数执行时间的统计

```py
import time

# 装饰器函数
def get_time(func):
    def inner():
        begin = time.time()
        func()
        end = time.time()
        print("函数执行花费%f" % (end-begin))
    return inner


@get_time
def func1():
    for i in range(100000):
        print(i)


func1()
```

**执行结果:**

```py
...
99995
99996
99997
99998
99999
函数执行花费0.329066
```

### 2. 小结

通过上面的示例代码可以得知装饰器的作用:

- 在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展。

# 通用装饰器的使用

**学习目标**

- 能够写出通用的装饰器

------

### 1. 装饰带有参数的函数

```py
# 添加输出日志的功能
def logging(fn):
    def inner(num1, num2):
        print("--正在努力计算--")
        fn(num1, num2)

    return inner


# 使用装饰器装饰函数
@logging
def sum_num(a, b):
    result = a + b
    print(result)


sum_num(1, 2)
```

**运行结果:**

```py
--正在努力计算--
3
```

### 2. 装饰带有返回值的函数

```py
# 添加输出日志的功能
def logging(fn):
    def inner(num1, num2):
        print("--正在努力计算--")
        result = fn(num1, num2)
        return result
    return inner


# 使用装饰器装饰函数
@logging
def sum_num(a, b):
    result = a + b
    return result


result = sum_num(1, 2)
print(result)
```

**运行结果:**

```py
--正在努力计算--
3
```

### 3. 装饰带有不定长参数的函数

```py
# 添加输出日志的功能
def logging(fn):
    def inner(*args, **kwargs):
        print("--正在努力计算--")
        fn(*args, **kwargs)

    return inner


# 使用语法糖装饰函数
@logging
def sum_num(*args, **kwargs):
    result = 0
    for value in args:
        result += value

    for value in kwargs.values():
        result += value

    print(result)

sum_num(1, 2, a=10)
```

**运行结果:**

```py
--正在努力计算--
13
```

### 4. 通用装饰器

```py
# 添加输出日志的功能
def logging(fn):
    def inner(*args, **kwargs):
        print("--正在努力计算--")
        result = fn(*args, **kwargs)
        return result

    return inner


# 使用语法糖装饰函数
@logging
def sum_num(*args, **kwargs):
    result = 0
    for value in args:
        result += value

    for value in kwargs.values():
        result += value

    return result


@logging
def subtraction(a, b):
    result = a - b
    print(result)

result = sum_num(1, 2, a=10)
print(result)

subtraction(4, 2)
```

**运行结果:**

```py
--正在努力计算--
13
--正在努力计算--
2
```

### 5. 小结

- 通用装饰器的语法格式:

  ```py
  # 通用装饰器
  def logging(fn):
    def inner(*args, **kwargs):
        print("--正在努力计算--")
        result = fn(*args, **kwargs)
        return result
  
    return inner
  ```

# 多个装饰器的使用

**学习目标**

- 能够使用多个装饰器装饰一个函数

------

### 1. 多个装饰器的使用示例代码

```py
def make_div(func):
    """对被装饰的函数的返回值 div标签"""
    def inner(*args, **kwargs):
        return "<div>" + func() + "</div>"
    return inner


def make_p(func):
    """对被装饰的函数的返回值 p标签"""
    def inner(*args, **kwargs):
        return "<p>" + func() + "</p>"
    return inner


# 装饰过程: 1 content = make_p(content) 2 content = make_div(content)
# content = make_div(make_p(content))
@make_div
@make_p
def content():
    return "人生苦短"

result = content()

print(result)
```

**代码说明:**

- 多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程

### 2. 小结

- 多个装饰器可以对函数进行多个功能的装饰，装饰顺序是由内到外的进行装饰

# 带有参数的装饰器

**学习目标**

- 能够写出带有参数的装饰器

------

### 1. 带有参数的装饰器介绍

带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，**语法格式: @装饰器(参数,...)**

**错误写法:**

```py
def decorator(fn, flag):
    def inner(num1, num2):
        if flag == "+":
            print("--正在努力加法计算--")
        elif flag == "-":
            print("--正在努力减法计算--")
        result = fn(num1, num2)
        return result
    return inner


@decorator('+')
def add(a, b):
    result = a + b
    return result

result = add(1, 3)
print(result)
```

**执行结果:**

```py
Traceback (most recent call last):
  File "/home/python/Desktop/test/hho.py", line 12, in <module>
    @decorator('+')
TypeError: decorator() missing 1 required positional argument: 'flag'
```

**代码说明:**

- 装饰器只能接收一个参数，并且还是函数类型。

**正确写法:**

在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。

```py
# 添加输出日志的功能
def logging(flag):

    def decorator(fn):
        def inner(num1, num2):
            if flag == "+":
                print("--正在努力加法计算--")
            elif flag == "-":
                print("--正在努力减法计算--")
            result = fn(num1, num2)
            return result
        return inner

    # 返回装饰器
    return decorator


# 使用装饰器装饰函数
@logging("+")
def add(a, b):
    result = a + b
    return result


@logging("-")
def sub(a, b):
    result = a - b
    return result

result = add(1, 2)
print(result)

result = sub(1, 2)
print(result)
```

### 2. 小结

- 使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器，因为 @ 符号需要配合装饰器实例使用



# 类装饰器的使用

**学习目标**

- 能够知道类装饰器的使用

------

### 1. 类装饰器的介绍

装饰器还有一种特殊的用法就是类装饰器，就是通过定义一个类来装饰函数。

**类装饰器示例代码:**

```py
class Check(object):
    def __init__(self, fn):
        # 初始化操作在此完成
        self.__fn = fn

    # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。
    def __call__(self, *args, **kwargs):
        # 添加装饰功能
        print("请先登陆...")
        self.__fn()


@Check
def comment():
    print("发表评论")


comment()
```

**代码说明:**

# 说明：

- @Check 等价于 comment = Check(comment), 所以需要提供一个**init**方法，并多增加一个fn参数。
- 要想类的实例对象能够像函数一样调用，需要在类里面使用**call**方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。
- 在**call**方法里进行对fn函数的装饰，可以添加额外的功能。

**执行结果:**

```py
请先登陆...
发表评论
```

### 2. 小结

- 想要让类的实例对象能够像函数一样进行调用，需要在类里面使用**call**方法，把类的实例变成可调用对象(callable)
- 类装饰器装饰函数功能在**call**方法里面进行添加

# web框架概述

**学习目标**

- 能够知道web框架和web服务器的关系

------

### 1. web框架和web服务器的关系介绍

前面已经学习过web服务器, 我们知道web服务器主要是接收用户的http请求,根据用户的请求返回不同的资源数据，但是之前我们开发的是静态web服务器，返回的都是静态资源数据，假如我们想要web服务器返回动态资源那么该如何进行处理呢？

这里我们给大家介绍一个web框架，**使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序**，简称web框架。

![web框架和web服务器的关系](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/web%25E6%25A1%2586%25E6%259E%25B6%25E5%2592%258Cweb%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E7%259A%2584%25E5%2585%25B3%25E7%25B3%25BB.png)

**关系说明:**

- web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理
- web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器
- web服务器再把响应结果发生给浏览器

### 2. 静态资源

不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。

### 3. 动态资源

和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。

### 4. WSGI协议

它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。

### 5. 小结

- web框架是专门为web服务器处理动态资源请求的一个应用程序
- web框架和web服务器的关系是web框架专门服务于web服务器，给web服务器提供处理动态资源请求的服务。

# 框架程序开发

**学习目标**

- 能够知道使用web框架程序处理客户端的动态资源请求操作

------

### 1. 框架职责介绍

- 接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。

### 2. 动态资源判断

- 根据请求资源路径的后缀名进行判断
  - 如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。
  - 否则是静态资源请求，让web服务器程序进行处理。

**web服务器程序(web.py)代码:**

```py
import socket
import threading
import sys
import framework


# 定义web服务器类
class HttpWebServer(object):
    def __init__(self, port):
        # 创建tcp服务端套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置端口号复用, 程序退出端口立即释放
        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        # 绑定端口号
        tcp_server_socket.bind(("", port))
        # 设置监听
        tcp_server_socket.listen(128)
        self.tcp_server_socket = tcp_server_socket

    # 处理客户的请求
    @staticmethod
    def handle_client_quest(new_socket):
        # 代码执行到此，说明连接建立成功
        recv_client_data = new_socket.recv(4096)
        if len(recv_client_data) == 0:
            print("关闭浏览器了")
            # 关闭服务与客户端的套接字
            new_socket.close()
            return

        # 对二进制数据进行解码
        recv_client_content = recv_client_data.decode("utf-8")
        print(recv_client_content)
        # 根据指定字符串进行分割， 最大分割次数指定2
        request_list = recv_client_content.split(" ", maxsplit=2)

        # 获取请求资源路径
        request_path = request_list[1]
        print(request_path)

        # 判断请求的是否是根目录，如果条件成立，指定首页数据返回
        if request_path == "/":
            request_path = "/index.html"

        # 判断是否是动态资源请求
        if request_path.endswith(".html"):
            """这里是动态资源请求，把请求信息交给框架处理"""
            # 字典存储用户的请求信息
            env = {
                "request_path": request_path
            }

            # 获取处理结果
            status, headers, response_body = framework.handle_request(env)

            # 使用框架处理的数据拼接响应报文
            # 响应行
            response_line = "HTTP/1.1 %s\r\n" % status
            # 响应头
            response_header = ""
            # 遍历头部信息
            for header in headers:
                # 拼接多个响应头
                response_header += "%s: %s\r\n" % header
            response_data = (response_line +
                             response_header +
                             "\r\n" +
                             response_body).encode("utf-8")
            # 发送数据
            new_socket.send(response_data)
            # 关闭socket
            new_socket.close()

        else:
            """这里是静态资源请求"""
            try:
                # 动态打开指定文件
                with open("static" + request_path, "rb") as file:
                    # 读取文件数据
                    file_data = file.read()
            except Exception as e:
                # 请求资源不存在，返回404数据
                # 响应行
                response_line = "HTTP/1.1 404 Not Found\r\n"
                # 响应头
                response_header = "Server: PWS1.0\r\n"
                with open("static/error.html", "rb") as file:
                    file_data = file.read()
                # 响应体
                response_body = file_data

                # 拼接响应报文
                response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
                # 发送数据
                new_socket.send(response_data)
            else:
                # 响应行
                response_line = "HTTP/1.1 200 OK\r\n"
                # 响应头
                response_header = "Server: PWS1.0\r\n"

                # 响应体
                response_body = file_data

                # 拼接响应报文
                response_data = (response_line + response_header + "\r\n").encode("utf-8") + response_body
                # 发送数据
                new_socket.send(response_data)
            finally:
                # 关闭服务与客户端的套接字
                new_socket.close()

    def start(self):
        while True:
            # 等待接受客户端的连接请求
            new_socket, ip_port = self.tcp_server_socket.accept()
            sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,))
            # 设置守护线程
            sub_thread.setDaemon(True)
            sub_thread.start()


# 程序入口函数
def main():

    # 获取命令行参数判断长度
    if len(sys.argv) != 2:
        print("执行命令如下: python3 xxx.py 9000")
        return

    # 判断端口号是否是数字
    if not sys.argv[1].isdigit():
        print("执行命令如下: python3 xxx.py 9000")
        return

    # 需要转成int类型
    port = int(sys.argv[1])

    # 创建web服务器
    web_server = HttpWebServer(port)
    # 启动web服务器
    web_server.start()


if __name__ == '__main__':
    main()
```

### 3. 处理客户端的动态资源请求

1. 创建web框架程序
2. 接收web服务器的动态资源请求
3. 处理web服务器的动态资源请求并把处理结果返回给web服务器
4. web服务器把处理结果组装成响应报文发送给浏览器

**web框架程序(framework.py)代码:**

```py
"""miniweb框架，负责处理动态资源请求"""
import time


# 获取首页数据
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]
    # 处理后的数据
    data = time.ctime()

    return status, response_header, data


# 没有找到动态资源
def not_found():
    # 响应状态
    status = "404 Not Found";
    # 响应头
    response_header = [("Server", "PWS2.0")]
    # 处理后的数据
    data = "not found"

    return status, response_header, data


# 处理动态资源请求
def handle_request(env):
    # 获取动态请求资源路径
    request_path = env["request_path"]
    print("接收到的动态资源请求:", request_path)

    if request_path == "/index.html":
        # 获取首页数据
        result = index()
        return result
    else:
        # 没有找到动态资源
        result = not_found()
        return result
```

### 4. 小结

- 动态资源的判断通过请求资源路径的后缀是.html来完成，否则是静态资源
- 处理客户端的动态资源请求
  1. 接收web服务器的动态资源请求
  2. 处理动态资源请求并把处理结果返回给web服务器
  3. web服务器把处理结果组装成响应报文发送给浏览器

# 模板替换功能开发

**学习目标**

- 能够实现模板替换功能

------

### 1. 读取股票信息模板文件

**framework.py示例代码:**

```py
# 获取首页数据
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/index.html", "r") as file:
        file_data = file.read()
```

### 2. 使用模拟数据替换模板变量

**framework.py示例代码:**

```py
# 获取首页数据
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 1. 打开模板文件，读取数据
    with open("template/index.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    data = time.ctime()
    # 2. 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", data)

    return status, response_header, result
```

### 3. 小结

- 模板替换功能
  1. 打开template目录下的index.html模板文件，读取模板文件数据
  2. 把模板文件中的模板变量进行替换

# 路由列表功能开发

**学习目标**

- 能够知道路由列表的实现

------

### 1. 路由的介绍

接着上面程序的判断场景，假如咱们再处理一个个人中心的动态资源请求非常简单，再添加一个函数和更加一个分支判断就可以实现了。

**framework.py 示例代码:**

```py
# 获取个人中心数据
def center():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/center.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    data = time.ctime()
    # 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", data)

    return status, response_header, result


# 处理动态资源请求
def handle_request(env):
    # 获取动态请求资源路径
    request_path = env["request_path"]
    print("接收到的动态资源请求:", request_path)

    if request_path == "/index.html":
        # 获取首页数据
        result = index()
        return result
    elif request_path == "/center.html":
        # 获取个人中心数据
        result = center()
        return result
    else:
        # 没有找到动态资源
        result = not_found()
        return result
```

那如果咱们的框架处理的页面请求路径再多一些，比如:5个路径判断，大家可能感觉条件分支完全可以胜任，如果是40个甚至更多呢? 如果这是还是用普通的条件分支简直无法忍受。

解决办法: **可以使用路由**

**什么是路由？**

路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。

**路由列表**

这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。

| 请求路径     | 处理函数   |
| :----------- | :--------- |
| /login.html  | login函数  |
| /index.html  | index函数  |
| /center.html | center函数 |

### 2. 在路由列表添加路由

**framework.py 示例代码:**

```py
# 定义路由列表
route_list = [
    ("/index.html", index),
    ("/center.html", center)
]
```

### 3. 根据用户请求遍历路由列表处理用户请求

**framework.py 示例代码:**

```py
# 处理动态资源请求
def handle_request(env):
    # 获取动态请求资源路径
    request_path = env["request_path"]
    print("接收到的动态资源请求:", request_path)
    # 遍历路由列表，选择执行的函数
    for path, func in route_list:
        if request_path == path:
            result = func()
            return result
    else:
        # 没有找到动态资源
        result = not_found()
        return result

    # if request_path == "/index.html":
    #     # 获取首页数据
    #     result = index()
    #     return result
    # elif request_path == "/center.html":
    #     # 获取个人中心数据
    #     result = center()
    #     return result
    # else:
    #     # 没有找到动态资源
    #     result = not_found()
    #     return result
```

### 小结

- 路由是请求的URL到处理函数的映射
- 路由列表是用来保存每一个设置好的路由
- 用户的动态资源请求通过遍历路由列表找到对应的处理函数来完成。

# 装饰器方式的添加路由

**学习目标**

- 能够知道装饰器方式的添加路由

------

### 1. 使用带有参数的装饰器添加路由

前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。

**示例代码:**

```py
"""miniweb框架，负责处理动态资源请求"""
import time

# 定义路由列表
route_list = []


# 定义带有参数的装饰器
def route(path):
    # 装饰器
    def decorator(func):
        # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表
        route_list.append((path, func))

        def inner():
            # 执行指定函数
            return func()

        return inner
    # 返回装饰器
    return decorator


# 获取首页数据
@route("/index.html")
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/index.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    data = time.ctime()
    # 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", data)

    return status, response_header, result


# 获取个人中心数据
@route("/center.html")
def center():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/center.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    data = time.ctime()
    # 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", data)

    return status, response_header, result


# 没有找到动态资源
def not_found():
    # 响应状态
    status = "404 Not Found";
    # 响应头
    response_header = [("Server", "PWS2.0")]
    # 处理后的数据
    data = "not found"

    return status, response_header, data


# 处理动态资源请求
def handle_request(env):
    # 获取动态请求资源路径
    request_path = env["request_path"]
    print("接收到的动态资源请求:", request_path)
    # 遍历路由列表，选择执行的函数
    for path, func in route_list:
        if request_path == path:
            result = func()
            return result
    else:
        # 没有找到动态资源
        result = not_found()
        return result
```

### 2. 小结

- 使用带有参数的装饰器对处理函数进行装饰，并完成路由的添加功能。

# 显示股票信息页面的开发

**学习目标**

- 能够实现股票信息数据的查询

------

### 1. 数据准备

```sql
-- 创建数据库
create database stock_db charset=utf8;
-- 切换数据库
use stock_db;
-- 执行sql文件
source stock_db.sql;
```

### 2. 根据sql语句查询股票信息

**示例代码:**

```py
# 获取首页数据
@route("/index.html")
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/index.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    conn = pymysql.connect(host="localhost",
                           port=3306,
                           user="root",
                           password="mysql",
                           database="stock_db",
                           charset="utf8")

    # 获取游标
    cursor = conn.cursor()
    # 查询sql语句
    sql = "select * from info;"
    # 执行sql
    cursor.execute(sql)
    # 获取结果集
    result = cursor.fetchall()
    print(result)
```

### 3. 使用查询数据替换模板变量

**示例代码:**

```py
# 获取首页数据
@route("/index.html")
def index():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/index.html", "r") as file:
        file_data = file.read()

    # 处理后的数据, 从数据库查询
    conn = pymysql.connect(host="localhost",
                           port=3306,
                           user="root",
                           password="mysql",
                           database="stock_db",
                           charset="utf8")

    # 获取游标
    cursor = conn.cursor()
    # 查询sql语句
    sql = "select * from info;"
    # 执行sql
    cursor.execute(sql)
    # 获取结果集
    result = cursor.fetchall()
    print(result)

    data = ""
    for row in result:
        data += '''<tr>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td>%s</td>
                    <td><input type="button" value="添加" id="toAdd" name="toAdd" systemidvaule="000007"></td>
                   </tr>''' % row

    # 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", data)

    return status, response_header, result
```

### 4. 小结

- 根据sql语句查询股票信息
- 使用查询数据替换模板变量

# 个人中心数据接口的开发

**学习目标**

- 能够知道个人中心数据接口的开发步骤

------

### 1. 根据sql语句查询个人中心数据

```py
# 个人中心数据接口开发
@route("/center_data.html")
def center_data():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0"), ("Content-Type", "text/html;charset=utf-8")]
    conn = pymysql.connect(host="localhost",
                           port=3306,
                           user="root",
                           password="mysql",
                           database="stock_db",
                           charset="utf8")

    # 获取游标
    cursor = conn.cursor()
    # 查询sql语句
    sql = '''select i.code, i.short, i.chg, 
             i.turnover, i.price, i.highs, f.note_info 
             from info as i inner join focus as f on i.id = f.info_id;'''
    # 执行sql
    cursor.execute(sql)
    # 获取结果集
    result = cursor.fetchall()
    # 关闭游标
    cursor.close()
    # 关闭数据库连接
    conn.close()
    print(result)
```

### 2. 将个人中心数据转成json字符串并返回

```py
# 个人中心数据接口开发
@route("/center_data.html")
def center_data():
    # 响应状态
    status = "200 OK";
    # 响应头
    response_header = [("Server", "PWS2.0"), ("Content-Type", "text/html;charset=utf-8")]
    conn = pymysql.connect(host="localhost",
                           port=3306,
                           user="root",
                           password="mysql",
                           database="stock_db",
                           charset="utf8")

    # 获取游标
    cursor = conn.cursor()
    # 查询sql语句
    sql = '''select i.code, i.short, i.chg, 
             i.turnover, i.price, i.highs, f.note_info 
             from info as i inner join focus as f on i.id = f.info_id;'''
    # 执行sql
    cursor.execute(sql)
    # 获取结果集
    result = cursor.fetchall()
    # 关闭游标
    cursor.close()
    # 关闭数据库连接
    conn.close()
    # 个人中心数据列表
    center_data_list = list()
    # 遍历每一行数据转成字典
    for row in result:
        # 创建空的字典
        center_dict = dict()
        center_dict["code"] = row[0]
        center_dict["short"] = row[1]
        center_dict["chg"] = row[2]
        center_dict["turnover"] = row[3]
        center_dict["price"] = str(row[4])
        center_dict["highs"] = str(row[5])
        center_dict["note_info"] = row[6]
        # 添加每个字典信息
        center_data_list.append(center_dict)

    # 把列表字典转成json字符串, 并在控制台显示
    json_str = json.dumps(center_data_list,ensure_ascii=False)
    print(json_str)
    return status, response_header, json_str
```

**代码说明:**

- json.dumps函数把字典转成json字符串
  1. 函数的第一个参数表示要把指定对象转成json字符串
  2. 参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。
- 响应头添加Content-Type表示指定数据的编码格式

### 3. 小结

- web框架程序还可以开发数据接口，为客户端程序提供数据服务。
  - 1. 根据sql语句查询数据库
  - 1. 把数据转成json字符串返回
  - 1. 浏览器通过指定接口地址获取web框架提供的数据。

# ajax请求数据渲染个人中心页面

**学习目标**

- 能够知道使用ajax发送请求获取个人中心的数据

------

### 1. 根据用户请求返回个人中心空模板文件数据

```py
# 获取个人中心数据
@route("/center.html")
def center():
    # 响应状态
    status = "200 OK"
    # 响应头
    response_header = [("Server", "PWS2.0")]

    # 打开模板文件，读取数据
    with open("template/center.html", "r") as file:
        file_data = file.read()

    # 替换模板文件中的模板遍历
    result = file_data.replace("{%content%}", "")

    return status, response_header, result
```

### 2. 在个人中心模板文件添加ajax请求获取个人中心数据

```js
// 发送ajax请求获取个人中心页面数据
// 路径写成 center_data.html，发送ajax的时候路径其实是http://ip地址:端口号/center.data.html
$.get("center_data.html", function (data) {
        alert(data);
    }
}, "json");
```

### 3. 将个人中心数据在页面完成展示

```js
// 发送ajax请求获取个人中心页面数据
$.get("center_data.html", function (data) {

    var data_array = data;

    // 获取table标签对象
    var $table = $(".table")
    for(var i = 0; i < data_array.length; i++){
        // 获取每一条对象
        var center_obj = data_array[i];
        var row_html = '<tr>' +
            '<td>'+ center_obj.code +'</td>' +
            '<td>'+ center_obj.short +'</td>' +
            '<td>'+ center_obj.chg +'</td>' +
            '<td>'+ center_obj.turnover +'</td>' +
            '<td>'+ center_obj.price +'</td>' +
            '<td>'+ center_obj.highs +'</td>' +
            '<td>'+ center_obj.note_info +'</td>' +
            '<td><a type="button" class="btn btn-default btn-xs" href="/update/000007.html"> <span class="glyphicon glyphicon-star" aria-hidden="true"></span> 修改 </a></td><td><input type="button" value="删除" id="toDel" name="toDel" systemidvaule="000007"></td></tr>';
        // 为table标签添加每一行组装的html数据
        $table.append(row_html);
    }

}, "json");
```

### 4. 小结

- 根据用户请求返回个人中心空模板文件数据
- 在个人中心模板文件添加ajax请求获取个人中心数据
- 将个人中心数据在页面完成展示

# logging日志

**学习目标**

- 能够知道logging日志的使用

------

### 1. logging日志的介绍

在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?

可以使用 **logging** 这个包来完成

**记录程序日志信息的目的是:**

1. 可以很方便的了解程序的运行情况
2. 可以分析用户的操作行为、喜好等信息
3. 方便开发人员检查bug

### 2. logging日志级别介绍

日志等级可以分为5个，从低到高分别是:

1. DEBUG
2. INFO
3. WARNING
4. ERROR
5. CRITICAL

**日志等级说明:**

- DEBUG：程序调试bug时使用
- INFO：程序正常运行时使用
- WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误
- ERROR：程序出错误时使用，如:IO操作失败
- CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用
- 默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。
- 日志等级从低到高的顺序是: DEBUG < INFO < WARNING < ERROR < CRITICAL

### 3. logging日志的使用

在 logging 包中记录日志的方式有两种:

1. 输出到控制台
2. 保存到日志文件

**日志信息输出到控制台的示例代码:**

```py
import logging

logging.debug('这是一个debug级别的日志信息')
logging.info('这是一个info级别的日志信息')
logging.warning('这是一个warning级别的日志信息')
logging.error('这是一个error级别的日志信息')
logging.critical('这是一个critical级别的日志信息')
```

**运行结果:**

```py
WARNING:root:这是一个warning级别的日志信息
ERROR:root:这是一个error级别的日志信息
CRITICAL:root:这是一个critical级别的日志信息
```

**说明:**

- 日志信息只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING

**logging日志等级和输出格式的设置:**

```py
import logging

# 设置日志等级和输出日志格式
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')

logging.debug('这是一个debug级别的日志信息')
logging.info('这是一个info级别的日志信息')
logging.warning('这是一个warning级别的日志信息')
logging.error('这是一个error级别的日志信息')
logging.critical('这是一个critical级别的日志信息')
```

**运行结果:**

```py
2019-02-13 20:41:33,080 - hello.py[line:6] - DEBUG: 这是一个debug级别的日志信息
2019-02-13 20:41:33,080 - hello.py[line:7] - INFO: 这是一个info级别的日志信息
2019-02-13 20:41:33,080 - hello.py[line:8] - WARNING: 这是一个warning级别的日志信息
2019-02-13 20:41:33,080 - hello.py[line:9] - ERROR: 这是一个error级别的日志信息
2019-02-13 20:41:33,080 - hello.py[line:10] - CRITICAL: 这是一个critical级别的日志信息
```

**代码说明:**

- level 表示设置的日志等级
- format 表示日志的输出格式, 参数说明:
  - %(levelname)s: 打印日志级别名称
  - %(filename)s: 打印当前执行程序名
  - %(lineno)d: 打印日志的当前行号
  - %(asctime)s: 打印日志的时间
  - %(message)s: 打印日志信息

**日志信息保存到日志文件的示例代码:**

```py
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s',
                    filename="log.txt",
                    filemode="w")

logging.debug('这是一个debug级别的日志信息')
logging.info('这是一个info级别的日志信息')
logging.warning('这是一个warning级别的日志信息')
logging.error('这是一个error级别的日志信息')
logging.critical('这是一个critical级别的日志信息')
```

**运行结果:**

![日志文件](../../../hgx%25E7%25AC%2594%25E8%25AE%25B0/Typora/imgs/%25E6%2597%25A5%25E5%25BF%2597%25E6%2596%2587%25E4%25BB%25B6.png)

### 4. logging日志在mini-web项目中应用

**web.py 程序使用logging日志示例:**

1. 程序入口模块设置logging日志的设置

   ```py
    import socket
    import threading
    import sys
    import framework
    import logging
   
    # logging日志的配置
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s',
                        filename="log.txt",
                        filemode="w")
   ```

2. INFO级别的日志输出，示例代码:

   ```py
    # 判断是否是动态资源请求
    if request_path.endswith(".html"):
        """这里是动态资源请求，把请求信息交给框架处理"""
        logging.info("动态资源请求:" + request_path)
        ...
    else:
        """这里是静态资源请求"""
        logging.info("静态资源请求:" + request_path)
        ...
   ```

3. WARNING级别的日志输出，示例代码:

   ```py
    # 获取命令行参数判断长度
    if len(sys.argv) != 2:
        print("执行命令如下: python3 xxx.py 9000")
        logging.warning("用户在命令行启动程序参数个数不正确!")
        return
   
    # 判断端口号是否是数字
    if not sys.argv[1].isdigit():
        print("执行命令如下: python3 xxx.py 9000")
        logging.warning("用户在命令行启动程序参数不是数字字符串!")
        return
   ```

**framework.py 程序使用logging日志示例:**

1. ERROR级别的日志输出，示例代码:

   ```py
    # 处理动态资源请求
    def handle_request(env):
        # 获取动态请求资源路径
        request_path = env["request_path"]
        print("接收到的动态资源请求:", request_path)
        # 遍历路由列表，选择执行的函数
        for path, func in route_list:
            if request_path == path:
                result = func()
                return result
        else:
            logging.error("没有设置相应的路由:" + request_path)
            # 没有找到动态资源
            result = not_found()
            return result
   ```

**说明:**

- logging日志配置信息在程序入口模块设置一次，整个程序都可以生效。
  - logging.basicConfig 表示 logging 日志配置操作

### 5. 小结

- 记录python程序中日志信息使用 logging 包来完成
- logging日志等级有5个:
  1. DEBUG
  2. INFO
  3. WARNING
  4. ERROR
  5. CRITICAL
- 打印(记录)日志的函数有5个:
  1. logging.debug函数, 表示: 打印(记录)DEBUG级别的日志信息
  2. logging.info函数, 表示: 打印(记录)INFO级别的日志信息
  3. logging.warning函数, 表示: 打印(记录)WARNING级别的日志信息
  4. logging.error函数, 表示: 打印(记录)ERROR级别的日志信息
  5. logging.critical函数, 表示: 打印(记录)CRITICAL级别的日志信息

# property属性

**学习目标**

- 能够知道装饰器方式的property属性的定义方式

------

### 1. property属性的介绍

property属性就是负责把一个方法当做属性进行使用，这样做可以简化代码使用。

**定义property属性有两种方式**

1. 装饰器方式
2. 类属性方式

### 2. 装饰器方式

```py
class Person(object):

    def __init__(self):
        self.__age = 0

    # 装饰器方式的property, 把age方法当做属性使用, 表示当获取属性时会执行下面修饰的方法
    @property
    def age(self):
        return self.__age

    # 把age方法当做属性使用, 表示当设置属性时会执行下面修饰的方法
    @age.setter
    def age(self, new_age):
        if new_age >= 150:
            print("成精了")
        else:
            self.__age = new_age

# 创建person
p = Person()
print(p.age)
p.age = 100
print(p.age)
p.age = 1000
```

**运行结果:**

```py
0
100
成精了
```

**代码说明:**

- @property 表示把方法当做属性使用, 表示当获取属性时会执行下面修饰的方法
- @方法名.setter 表示把方法当做属性使用,表示当设置属性时会执行下面修饰的方法
- 装饰器方式的property属性修饰的方法名一定要一样。

### 3. 类属性方式

```py
class Person(object):

    def __init__(self):
        self.__age = 0

    def get_age(self):
        """当获取age属性的时候会执行该方法"""
        return self.__age

    def set_age(self, new_age):
        """当设置age属性的时候会执行该方法"""
        if new_age >= 150:
            print("成精了")
        else:
            self.__age = new_age

    # 类属性方式的property属性
    age = property(get_age, set_age)

# 创建person
p = Person()
print(p.age)
p.age = 100
print(p.age)
p.age = 1000
```

**运行结果:**

```py
0
100
成精了
```

**代码说明:**

- property的参数说明:
  - 第一个参数是获取属性时要执行的方法
  - 第二个参数是设置属性时要执行的方法

### 4. 小结

- 定义property属性有两种方式:
  1. 装饰器方式
  2. 类属性方式
- 装饰器方式:
  1. @property 修饰获取值的方法
  2. @方法名.setter 修饰设置值的方法
- 类属性方式:
  1. 类属性 = property(获取值方法, 设置值方法)

# with语句和上下文管理器

**学习目标**

- 能够知道自定义上下文管理器的两种方式

------

### 1. with语句的使用

**基础班向文件中写入数据的示例代码:**

```py
 # 1、以写的方式打开文件
 f = open("1.txt", "w")
 # 2、写入文件内容
 f.write("hello world")
 # 3、关闭文件
 f.close()
```

**代码说明:**

- 文件使用完后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的

**这种写法可能出现一定的安全隐患，错误代码如下:**

```py
 # 1、以读的方式打开文件
 f = open("1.txt", "r")
 # 2、读取文件内容
 f.write("hello world")
 # 3、关闭文件
 f.close()
```

**运行结果:**

```py
Traceback (most recent call last):
  File "/home/python/Desktop/test/xxf.py", line 4, in <module>
    f.write("hello world")
io.UnsupportedOperation: not writable
```

**代码说明:**

- 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。
- 为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来解决

**安全写法, 代码如下:**

```py
try:
    # 1、以读的方式打开文件
    f = open("1.txt", "r")
    # 2、读取文件内容
    f.write("xxxxx")

except IOError as e:
    print("文件操作出错", e)

finally:
    # 3、关闭文件
    f.close()
```

**运行结果:**

```py
文件操作出错 not writable
```

这种方法虽然代码运行良好,但是缺点就是代码过于冗长,并且需要添加try-except-finally语句,不是很方便,也容易忘记.

在这种情况下,**Python提供了 with 语句的这种写法，既简单又安全，并且 with 语句执行完成以后自动调用关闭文件操作，即使出现异常也会自动调用关闭文件操作**。

**with 语句的示例代码:**

```py
# 1、以写的方式打开文件
with open("1.txt", "w") as f:
    # 2、读取文件内容
    f.write("hello world")
```

### 2. 上下文管理器

一个类只要实现了`__enter__()和__exit__()`这个两个方法，通过该类创建的对象我们就称之为上下文管理器。

上下文管理器可以使用 with 语句，**with语句之所以这么强大，背后是由上下文管理器做支撑的**，也就是说刚才使用 open 函数创建的文件对象就是就是一个上下文管理器对象。

**自定义上下文管理器类,模拟文件操作:**

定义一个File类，实现 `__enter__() 和 __exit__()`方法，然后使用 with 语句来完成操作文件， 示例代码:

```py
class File(object):

    # 初始化方法
    def __init__(self, file_name, file_model):
        # 定义变量保存文件名和打开模式
        self.file_name = file_name
        self.file_model = file_model

    # 上文方法
    def __enter__(self):
        print("进入上文方法")
        # 返回文件资源
        self.file = open(self.file_name,self.file_model)
        return self.file

    # 下文方法
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("进入下文方法")
        self.file.close()


if __name__ == '__main__':

    # 使用with管理文件
    with File("1.txt", "r") as file:
        file_data = file.read()
        print(file_data)
```

**运行结果:**

```py
进入上文方法
hello world
进入下文方法
```

**代码说明:**

- `__enter__`表示上文方法，需要返回一个操作文件对象
- `__exit__`表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法。

### 3. 上下文管理器的另外一种实现方式

假如想要让一个函数成为上下文管理器，Python 还提供了一个 @contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 上面的语句在 `__enter__` 方法中执行，yield 下面的语句在 `__exit__` 方法中执行，紧跟在 yield 后面的参数是函数的返回值。

```py
# 导入装饰器
from contextlib import contextmanager


# 装饰器装饰函数，让其称为一个上下文管理器对象
@contextmanager
def my_open(path, mode):
    try:
        # 打开文件
        file = open(file_name, file_mode)
        # yield之前的代码好比是上文方法
        yield file
    except Exception as e:
        print(e)
    finally:
        print("over")
        # yield下面的代码好比是下文方法
        file.close()

# 使用with语句
with my_open('out.txt', 'w') as f:
    f.write("hello , the simplest context manager")
```

### 4. 小结

- Python 提供了 with 语句用于简化资源释放的操作，使用 with 语句操作建立在上下文管理器(实现`__enter__和__exit__`)的基础上
- Python 还提供了一个 @contextmanager 装饰器，更进一步简化上下管理器的实现，让一个函数可以成为上下文管理器，结合 with 语句来使用

# 生成器的创建方式

**学习目标**

- 能够知道生成器的两种创建方式

------

### 1. 生成器的介绍

根据程序员制定的规则循环生成数据，当条件不成立时则生成数据结束。数据不是一次性全部生成处理，而是使用一个，再生成一个，可以**节约大量的内存**。

### 2. 创建生成器的方式

1. 生成器推导式
2. yield 关键字

**生成器推导式:**

- 与列表推导式类似，只不过生成器推导式使用小括号

```py
# 创建生成器
my_generator = (i * 2 for i in range(5))
print(my_generator)

# next获取生成器下一个值
# value = next(my_generator)
# print(value)

# 遍历生成器
for value in my_generator:
    print(value)
```

**代码说明:**

- next 函数获取生成器中的下一个值
- for 循环遍历生成器中的每一个值

**运行结果:**

```py
<generator object <genexpr> at 0x101367048>
0
2
4
6
8
```

**yield 关键字:**

- 只要在def函数里面看到有 yield 关键字那么就是生成器

```py
def mygenerater(n):
    for i in range(n):
        print('开始生成...')
        yield i
        print('完成一次...')


if __name__ == '__main__':

    g = mygenerater(2)
    # 获取生成器中下一个值
    # result = next(g)
    # print(result)

    # while True:
    #     try:
    #         result = next(g)
    #         print(result)
    #     except StopIteration as e:
    #         break

    # # for遍历生成器, for 循环内部自动处理了停止迭代异常，使用起来更加方便
    for i in g:
        print(i)
```

**代码说明:**

- 代码执行到 yield 会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行
- 生成器如果把数据生成完成，再次获取生成器中的下一个数据会抛出一个StopIteration 异常，表示停止迭代异常
- while 循环内部没有处理异常操作，需要手动添加处理异常操作
- for 循环内部自动处理了停止迭代异常，使用起来更加方便，推荐大家使用。

**运行结果:**

```py
开始生成...
0
完成一次...
开始生成...
1
完成一次...
```

### 3. 生成器的使用场景

数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

现在我们使用生成器来实现这个斐波那契数列，每次取值都通过算法来生成下一个数据, **生成器每次调用只生成一个数据，可以节省大量的内存。**

```py
def fibonacci(num):
    a = 0
    b = 1

    # 记录生成fibonacci数字的下标
    current_index = 0

    while current_index < num:
        result = a
        a, b = b, a + b
        current_index += 1
        # 代码执行到yield会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行
        yield result


fib = fibonacci(5)
# 遍历生成的数据
for value in fib:
    print(value)
```

**运行结果:**

```py
0
1
1
2
3
```

### 4. 小结

- 生成器是根据算法生成数据的一种机制，每次调用生成器只生成一个值，可以节省大量内存。
- 生成器的创建有两种方式:
  - 1. 生成器推导式
  - 1. yield 关键字

# 深拷贝和浅拷贝

**学习目标**

- 能够知道深拷贝和浅拷贝的区别

------

### 1. 浅拷贝

copy函数是浅拷贝，只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。

**不可变类型的浅拷贝示例代码:**

```py
import copy  # 使用浅拷贝需要导入copy模块

# 不可变类型有: 数字、字符串、元组

a1 = 123123
b1 = copy.copy(a1)  # 使用copy模块里的copy()函数就是浅拷贝了
# 查看内存地址
print(id(a1))
print(id(b1))

print("-" * 10)
a2 = "abc"
b2 = copy.copy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))

print("-" * 10)
a3 = (1, 2, ["hello", "world"])
b3 = copy.copy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))
```

**运行结果:**

```py
140459558944048
140459558944048
----------
140459558648776
140459558648776
----------
140459558073328
140459558073328
```

**不可变类型的浅拷贝说明:**

- **通过上面的执行结果可以得知，不可变类型进行浅拷贝不会给拷贝的对象开辟新的内存空间，而只是拷贝了这个对象的引用。**

**可变类型的浅拷贝示例代码:**

```py
import copy # 使用浅拷贝需要导入copy模块

# 可变类型有: 列表、字典、集合

a1 = [1, 2]
b1 = copy.copy(a1) # 使用copy模块里的copy()函数就是浅拷贝了
# 查看内存地址
print(id(a1))
print(id(b1))
print("-" * 10)
a2 = {"name": "张三", "age": 20}
b2 = copy.copy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
print("-" * 10)
a3 = {1, 2, "王五"}
b3 = copy.copy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))

print("-" * 10)
a4 = [1, 2, [4, 5]]
# 注意：浅拷贝只会拷贝父对象，不会对子对象进行拷贝
b4 = copy.copy(a4) # 使用copy模块里的copy()函数就是浅拷贝了
# 查看内存地址
print(id(a4))
print(id(b4))
print("-" * 10)
# 查看内存地址
print(id(a4[2]))
print(id(b4[2]))

# 修改数据
a4[2][0] = 6

# 子对象的数据会受影响
print(a4)
print(b4)
```

**运行结果:**

```py
139882899585608
139882899585800
----------
139882919626432
139882919626504
----------
139882919321672
139882899616264
----------
139882899587016
139882899586952
----------
139882899693640
139882899693640
[1, 2, [6, 5]]
[1, 2, [6, 5]]
```

**可变类型的浅拷贝说明:**

- **通过上面的执行结果可以得知，可变类型进行浅拷贝只对可变类型的第一层对象进行拷贝，对拷贝的对象会开辟新的内存空间进行存储，子对象不进行拷贝。**

### 2. 深拷贝

deepcopy函数是深拷贝, 只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。

**不可变类型的深拷贝示例代码:**

```py
import copy  # 使用深拷贝需要导入copy模块

# 不可变类型有: 数字、字符串、元组

a1 = 1
b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了
# 查看内存地址
print(id(a1))
print(id(b1))
print("-" * 10)
a2 = "张三"
b2 = copy.deepcopy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
print("-" * 10)
a3 = (1, 2)
b3 = copy.deepcopy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))
print("-" * 10)

# 注意: 元组里面要是有可变类型对象，发现对象有可变类型就会该对象到最后一个可变类型的每一层对象进行拷贝
a4 = (1, ["李四"])
b4 = copy.deepcopy(a4)
# 查看内存地址
print(id(a4))
print(id(b4))
# 元组里面的可变类型子对象也会进行拷贝
print(id(a4[1]))
print(id(b4[1]))
```

**运行结果:**

```py
9289120
9289120
----------
140115621848320
140115621848320
----------
140115621859592
140115621859592
----------
140115602480584
140115621834568
140115602328136
140115602436168
```

**不可变类型的深拷贝说明:**

- 通过上面的执行结果可以得知：
  - **不可变类型进行深拷贝如果子对象没有可变类型则不会进行拷贝，而只是拷贝了这个对象的引用，否则会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储**

**可变类型的深拷贝示例代码:**

```py
import copy  # 使用深拷贝需要导入copy模块

# 可变类型有: 列表、字典、集合

a1 = [1, 2]
b1 = copy.deepcopy(a1)  # 使用copy模块里的deepcopy()函数就是深拷贝了
# 查看内存地址
print(id(a1))
print(id(b1))
print("-" * 10)
a2 = {"name": "张三"}
b2 = copy.deepcopy(a2)
# 查看内存地址
print(id(a2))
print(id(b2))
print("-" * 10)
a3 = {1, 2}
b3 = copy.deepcopy(a3)
# 查看内存地址
print(id(a3))
print(id(b3))
print("-" * 10)

a4 = [1, 2, ["李四", "王五"]]
b4 = copy.deepcopy(a4)  # 使用copy模块里的deepcopy()函数就是深拷贝了
# 查看内存地址
print(id(a4))
print(id(b4))

# 查看内存地址
print(id(a4[2]))
print(id(b4[2]))
a4[2][0] = "王五"
# 因为列表的内存地址不同，所以数据不会收到影响
print(a4)
print(b4)
```

**运行结果:**

```py
140348291721736
140348291721928
----------
140348311762624
140348311221592
----------
140348311457864
140348291752456
----------
140348291723080
140348291723144
140348291723208
140348291723016
[1, 2, ['王五', '王五']]
[1, 2, ['李四', '王五']]
```

**可变类型的深拷贝说明:**

- 通过上面的执行结果可以得知, 可变类型进行深拷贝会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。

### 3. 浅拷贝和深拷贝的区别

- 浅拷贝最多拷贝对象的一层
- 深拷贝可能拷贝对象的多层

### 4. 总结

- 浅拷贝使用copy.copy函数
- 深拷贝使用copy.deepcopy函数
- 不管是给对象进行深拷贝还是浅拷贝，只要拷贝成功就会开辟新的内存空间存储拷贝的对象。
- 浅拷贝和深拷贝的区别是:
  - 浅拷贝最多拷贝对象的一层，深拷贝可能拷贝对象的多层。

# 正则表达式的概述

**学习目标**

- 能够知道正则表达式的作用

------

### 1. 正则表达式的介绍

在实际开发过程中经常会有查找符合某些复杂规则的字符串的需要，比如:邮箱、图片地址、手机号码等，这时候想匹配或者查找符合某些规则的字符串就可以使用正则表达式了。

### 2. 正则表达式概念

**正则表达式就是记录文本规则的代码**

### 3. 正则表达式的样子

0\d{2}-\d{8} 这个就是一个正则表达式，表达的意思是匹配的是座机号码

### 4. 正则表达式的特点

- 正则表达式的语法很令人头疼，可读性差
- 正则表达式通用行很强，能够适用于很多编程语言

### 5. 小结

- 正则表达式是匹配符合某些规则的字符串数据

# re模块介绍

**学习目标**

- 能够知道在python中使用正则表达式需要导入的模块

------

### 1. re模块的介绍

在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个 re 模块

```py
# 导入re模块
import re

# 使用match方法进行匹配操作
result = re.match(正则表达式,要匹配的字符串)

# 如果上一步匹配到数据的话，可以使用group方法来提取数据
result.group()
```

### 2. re模块的使用

```py
import re


# 使用match方法进行匹配操作
result = re.match("itcast","itcast.cn")
# 获取匹配结果
info = result.group()
print(info)
```

**运行结果:**

```py
itcast
```

### 3. 小结

- re.match() 根据正则表达式从头开始匹配字符串数据

# 匹配单个字符

**学习目标**

- 能够使用re模块匹配单个字符

------

### 1. 匹配单个字符

在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串

本小节，将要讲解正则表达式的单字符匹配

| 代码 | 功能                                     |
| :--: | :--------------------------------------- |
|  .   | 匹配任意1个字符（除了\n）                |
| [ ]  | 匹配[ ]中列举的字符                      |
|  \d  | 匹配数字，即0-9                          |
|  \D  | 匹配非数字，即不是数字                   |
|  \s  | 匹配空白，即 空格，tab键                 |
|  \S  | 匹配非空白                               |
|  \w  | 匹配非特殊字符，即a-z、A-Z、0-9、_、汉字 |
|  \W  | 匹配特殊字符，即非字母、非数字、非汉字   |

### 示例1： .

```python
import re

ret = re.match(".","M")
print(ret.group())

ret = re.match("t.o","too")
print(ret.group())

ret = re.match("t.o","two")
print(ret.group())
```

运行结果：

```python
M
too
two
```

### 示例2：[]

```python
import re

# 如果hello的首字符小写，那么正则表达式需要小写的h
ret = re.match("h","hello Python") 
print(ret.group())


# 如果hello的首字符大写，那么正则表达式需要大写的H
ret = re.match("H","Hello Python") 
print(ret.group())

# 大小写h都可以的情况
ret = re.match("[hH]","hello Python")
print(ret.group())
ret = re.match("[hH]","Hello Python")
print(ret.group())
ret = re.match("[hH]ello Python","Hello Python")
print(ret.group())

# 匹配0到9第一种写法
ret = re.match("[0123456789]Hello Python","7Hello Python")
print(ret.group())

# 匹配0到9第二种写法
ret = re.match("[0-9]Hello Python","7Hello Python")
print(ret.group())

ret = re.match("[0-35-9]Hello Python","7Hello Python")
print(ret.group())

# 下面这个正则不能够匹配到数字4，因此ret为None
ret = re.match("[0-35-9]Hello Python","4Hello Python")
# print(ret.group())
```

运行结果：

```python
h
H
h
H
Hello Python
7Hello Python
7Hello Python
7Hello Python
```

### 示例3：\d

```python
import re

# 普通的匹配方式
ret = re.match("嫦娥1号","嫦娥1号发射成功") 
print(ret.group())

ret = re.match("嫦娥2号","嫦娥2号发射成功") 
print(ret.group())

ret = re.match("嫦娥3号","嫦娥3号发射成功") 
print(ret.group())

# 使用\d进行匹配
ret = re.match("嫦娥\d号","嫦娥1号发射成功") 
print(ret.group())

ret = re.match("嫦娥\d号","嫦娥2号发射成功") 
print(ret.group())

ret = re.match("嫦娥\d号","嫦娥3号发射成功") 
print(ret.group())
```

运行结果：

```python
嫦娥1号
嫦娥2号
嫦娥3号
嫦娥1号
嫦娥2号
嫦娥3号
```

### 示例4：\D

```python
import re

match_obj = re.match("\D", "f")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果:

```python
f
```

### 示例5：\s

```python
import re

# 空格属于空白字符
match_obj = re.match("hello\sworld", "hello world")
if match_obj:
    result = match_obj.group()
    print(result)
else:
    print("匹配失败")



# \t 属于空白字符
match_obj = re.match("hello\sworld", "hello\tworld")
if match_obj:
    result = match_obj.group()
    print(result)
else:
    print("匹配失败")
```

运行结果:

```python
hello world
hello world
```

### 示例6：\S

```python
import re

match_obj = re.match("hello\Sworld", "hello&world")
if match_obj:
result = match_obj.group()
print(result)
else:
print("匹配失败")



match_obj = re.match("hello\Sworld", "hello$world")
if match_obj:
result = match_obj.group()
print(result)
else:
print("匹配失败")
```

运行结果:

```python
hello&world  
hello$world
```

### 示例7：\w

```python
import re

# 匹配非特殊字符中的一位
match_obj = re.match("\w", "A")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

执行结果:

```
A
```

### 示例8：\W

```python
# 匹配特殊字符中的一位
match_obj = re.match("\W", "&")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

执行结果:

```
&
```

### 小结

- . 表示匹配任意1个字符（除了\n）
- [ ] 表示匹配[ ]中列举的1个字符
- \d 表示匹配一个数字，即0-9
- \D 表示匹配一个非数字，即不是数字
- \s 表示匹配一个空白字符，即 空格，tab键
- \S | 匹配一个非空白字符
- \w | 匹配一个非特殊字符，即a-z、A-Z、0-9、_、汉字
- \W | 匹配一个特殊字符，即非字母、非数字、非汉字

# 匹配多个字符

**学习目标**

- 能够使用re模块匹配多个字符

------

### 1. 匹配多个字符

| 代码  | 功能                                                |
| :---: | :-------------------------------------------------- |
|   *   | 匹配前一个字符出现0次或者无限次，即可有可无         |
|   +   | 匹配前一个字符出现1次或者无限次，即至少有1次        |
|   ?   | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 |
|  {m}  | 匹配前一个字符出现m次                               |
| {m,n} | 匹配前一个字符出现从m到n次                          |

### 示例1：*

需求：匹配出一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可 有可无

```python
import re

ret = re.match("[A-Z][a-z]*","M")
print(ret.group())

ret = re.match("[A-Z][a-z]*","MnnM")
print(ret.group())

ret = re.match("[A-Z][a-z]*","Aabcdef")
print(ret.group())
```

运行结果：

```python
M
Mnn
Aabcdef
```

### 示例2：+

需求：匹配一个字符串，第一个字符是t,最后一个字符串是o,中间至少有一个字符

```python
import re


match_obj = re.match("t.+o", "two")
if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```python
two
```

### 示例3：?

需求：匹配出这样的数据，但是https 这个s可能有，也可能是http 这个s没有

```python
import re

match_obj = re.match("https?", "http")
if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```python
https
```

### 示例4：{m}、{m,n}

需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线

```python
import re


ret = re.match("[a-zA-Z0-9_]{6}","12a3g45678")
print(ret.group())

ret = re.match("[a-zA-Z0-9_]{8,20}","1ad12f23s34455ff66")
print(ret.group())
```

运行结果：

```python
12a3g4
1ad12f23s34455ff66
```

### 2. 小结

- *表示匹配前一个字符出现0次或者无限次，即可有可无
- +表示匹配前一个字符出现1次或者无限次，即至少有1次
- ?表示匹配前一个字符出现1次或者0次，即要么有1次，要么没有
- {m}表示匹配前一个字符出现m次
- {m,n}表示匹配前一个字符出现从m到n次

# 匹配开头和结尾

**学习目标**

- 能够使用re模块匹配指定字符串开头或者结尾

------

### 1. 匹配开头和结尾

| 代码 | 功能           |
| :--: | :------------- |
|  ^   | 匹配字符串开头 |
|  $   | 匹配字符串结尾 |

### 示例1：^

需求：匹配以数字开头的数据

```python
import re

# 匹配以数字开头的数据
match_obj = re.match("^\d.*", "3hello")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果:

```python
3hello
```

### 示例2：$

需求: 匹配以数字结尾的数据

```python
import re
# 匹配以数字结尾的数据
match_obj = re.match(".*\d$", "hello5")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```python
hello5
```

### 示例3：^ 和 $

需求: 匹配以数字开头中间内容不管以数字结尾

```python
match_obj = re.match("^\d.*\d$", "4hello4")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果:

```python
4hello4
```

### 2.除了指定字符以外都匹配

[^指定字符]: 表示除了指定字符都匹配

需求: 第一个字符除了aeiou的字符都匹配

```python
import re


match_obj = re.match("[^aeiou]", "h")
if match_obj:
    # 获取匹配结果
    print(match_obj.group())
else:
    print("匹配失败")
```

执行结果

```
h
```

### 3. 小结

- ^ 表示匹配字符串开头
- $ 表示匹配字符串结尾

### 4. 课下练习

- 1.匹配出163的邮箱地址，且@符号之前有4到20位，例如hello@163.com
- 2.匹配出11位手机号码
- 3.匹配出微博中的话题, 比如: #幸福是奋斗出来的#

# 匹配分组

**学习目标**

- 能够使用re模块提取分组数据

------

### 1. 匹配分组相关正则表达式

|     代码     | 功能                             |
| :----------: | :------------------------------- |
|      \|      | 匹配左右任意一个表达式           |
|     (ab)     | 将括号中字符作为一个分组         |
|    `\num`    | 引用分组num匹配到的字符串        |
| `(?P<name>)` | 分组起别名                       |
|  (?P=name)   | 引用别名为name分组匹配到的字符串 |

### 示例1：|

需求：在列表中["apple", "banana", "orange", "pear"]，匹配apple和pear

```python
import re

# 水果列表
fruit_list = ["apple", "banana", "orange", "pear"]

# 遍历数据
for value in fruit_list:
    # |    匹配左右任意一个表达式
    match_obj = re.match("apple|pear", value)
    if match_obj:
        print("%s是我想要的" % match_obj.group())
    else:
        print("%s不是我要的" % value)
```

执行结果:

```python
apple是我想要的
banana不是我要的
orange不是我要的
pear是我想要的
```

### 示例2：( )

需求：匹配出163、126、qq等邮箱

```python
import re

match_obj = re.match("[a-zA-Z0-9_]{4,20}@(163|126|qq|sina|yahoo)\.com", "hello@163.com")
if match_obj:
    print(match_obj.group())
    # 获取分组数据
    print(match_obj.group(1))
else:
    print("匹配失败")
```

执行结果:

```
hello@163.com
163
```

需求: 匹配qq:10567这样的数据，提取出来qq文字和qq号码

```python
import re

match_obj = re.match("(qq):([1-9]\d{4,10})", "qq:10567")

if match_obj:
    print(match_obj.group())
    # 分组:默认是1一个分组，多个分组从左到右依次加1
    print(match_obj.group(1))
    # 提取第二个分组数据
    print(match_obj.group(2))
else:
    print("匹配失败")
```

执行结果:

```
qq
10567
```

### 示例3：\num

需求：匹配出`<html>hh</html>`

```python
match_obj = re.match("<[a-zA-Z1-6]+>.*</[a-zA-Z1-6]+>", "<html>hh</div>")

if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")

match_obj = re.match("<([a-zA-Z1-6]+)>.*</\\1>", "<html>hh</html>")

if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```html
<html>hh</div>
<html>hh</html>
```

需求：匹配出`<html><h1>www.itcast.cn</h1></html>`

```python
match_obj = re.match("<([a-zA-Z1-6]+)><([a-zA-Z1-6]+)>.*</\\2></\\1>", "<html><h1>www.itcast.cn</h1></html>")

if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```html
<html><h1>www.itcast.cn</h1></html>
```

### 示例4：`(?P<name>)` `(?P=name)`

需求：匹配出`<html><h1>www.itcast.cn</h1></html>`

```python
match_obj = re.match("<(?P<name1>[a-zA-Z1-6]+)><(?P<name2>[a-zA-Z1-6]+)>.*</(?P=name2)></(?P=name1)>", "<html><h1>www.itcast.cn</h1></html>")

if match_obj:
    print(match_obj.group())
else:
    print("匹配失败")
```

运行结果：

```html
<html><h1>www.itcast.cn</h1></html>
```

### 2. 小结

- | 表示匹配左右任意一个表达式
- (ab) 表示将括号中字符作为一个分组
- `\num` 表示引用分组num匹配到的字符串
- `(?P<name>)` 表示分组起别名
- (?P=name) 表示引用别名为name分组匹配到的字符串
- (分组数据)：分组数是从左到右的方式进行分配的，最左边的是第一个分组，依次类推



# 常用办公python



## 4 用 os.makedirs()创建新文件夹 

程序可以用 os.makedirs()函数创建新文件夹（目录）。在交互式环境中输入以下

代码：

\

```python
>>> **import os**

\>>> **os.makedirs('C:\\delicious\\walnut\\waffles')**
```

## os.path 模块

os.path 模块包含了许多与文件名和文件路径相关的有用函数。例如，你已经使用了 os.path.join()来构建所有操作系统上都有效的路径。

os.path 模块提供了一些函数，返回一个相对路径的绝对路径，以及检查给定的路径是否为绝对路径。

- • 调用 os.path.abspath(path)将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。
- • 调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。 
- • 调用 os.path.relpath(path, start)将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。



在 Python 中，读写文件有 3 个步骤： 

1．调用 open()函数，返回一个 File 对象。

2．调用 File 对象的 read()或 write()方法。

3．调用 File 对象的 close()方法，关闭该文件。



用 pprint.pformat()函数保存变量

回忆一下 5.2 节“漂亮打印”中，pprint.pprint()函数将列表或字典中的内容“漂

亮打印”到屏幕，而 pprint.pformat()函数将返回同样的文本字符串，但不是打印它。

这个字符串不仅是易于阅读的格式，同时也是语法上正确的 Python 代码。假定你有

一个字典，保存在一个变量中，你希望保存这个变量和它的内容，以便将来使用。

pprint.pformat()函数将提供一个字符串，你可以将它写入.py 文件。该文件将成为你自

己的模块，如果你需要使用存储在其中的变量，就可以导入它。

例如，在交互式环境中输入以下代码：

\

```
>>> **import pprint**

\>>> **cats = [{'name': 'Zophie', 'desc': 'chubby'}, {'name': 'Pooka', 'desc': 'fluffy'}]**

\>>> **pprint.pformat(cats)**

"[{'desc': 'chubby', 'name': 'Zophie'}, {'desc': 'fluffy', 'name': 'Pooka'}]"

\>>> **fileObj = open('myCats.py', 'w')**

\>>> **fileObj.write('cats = ' + pprint.pformat(cats) + '\n')**

83

\>>> **fileObj.close()**
```









．os.getcwd()和 os.chdir()函数做什么事？

．read()和 readlines()方法之间的区别是什么？

9．shelf 值与什么数据结构相似？





shutil 模块

shutil（或称为 shell 工具）模块中包含一些函数，让你在 Python 程序中复制、

移动、改名和删除文件。要使用 shutil 的函数，首先需要 import shutil。

9.1.1 复制文件和文件夹 

shutil 模块提供了一些函数，用于复制文件和整个文件夹。

调用 shutil.copy(source, destination)，将路径 source 处的文件复制到路径 destination

处的文件夹（source 和 destination 都是字符串）。如果 destination 是一个文件名，它将

作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。

在交互式环境中输入以下代码，看看 shutil.copy()的效果：

\>>> **import shutil, os**

\>>> **os.chdir('C:\\')**

 >>> **shutil.copy('C:\\spam.txt', 'C:\\delicious')**

'C:\\delicious\\spam.txt'

 >>> **shutil.copy('eggs.txt', 'C:\\delicious\\eggs2.txt')**

'C:\\delicious\\eggs2.txt'

第一个 shutil.copy()调用将文件 C:\spam.txt 复制到文件夹 C:\delicious。返回值

是刚刚被复制的文件的路径。请注意，因为指定了一个文件夹作为目的地，原来

的文件名 spam.txt 就被用作新复制的文件名。第二个 shutil.copy()调用也将文件

C:\eggs.txt 复制到文件夹 C:\delicious，但为新文件提供了一个名字 eggs2.txt。

shutil.copy()将复制一个文件，shutil.copytree()将复制整个文件夹，以及它包含

的文件夹和文件。调用 shutil.copytree(source, destination)，将路径 source 处的文件

夹，包括它的所有文件和子文件夹，复制到路径 destination 处的文件夹。source 和

destination 参数都是字符串。该函数返回一个字符串，是新复制的文件夹的路径。

在交互式环境中输入以下代码：

\

```
>>> **import shutil, os**

\>>> **os.chdir('C:\\')**

\>>> **shutil.copytree('C:\\bacon', 'C:\\bacon_backup')**

'C:\\bacon_backup'
```

shutil.copytree()调用创建了一个新文件夹，名为 bacon_backup，其中的内容与

原来的 bacon 文件夹一样。现在你已经备份了非常非常宝贵的“bacon”。

9.1.2 文件和文件夹的移动与改名 

调用 shutil.move(source, destination)，将路径 source 处的文件夹移动到路径

destination，并返回新位置的绝对路径的字符串。

如果 destination 指向一个文件夹，source 文件将移动到 destination 中，并保持

原来的文件名。例如，在交互式环境中输入以下代码：>>> **import shutil**

\>>> **shutil.move('C:\\bacon.txt', 'C:\\eggs')**

'C:\\eggs\\bacon.txt'

假定在 C:\目录中已存在一个名为 eggs 的文件夹，这个 shutil.move()调用就是

说，“将 C:\bacon.txt 移动到文件夹 C:\eggs 中。

如果在 C:\eggs 中原来已经存在一个文件 bacon.txt，它就会被覆写。因为用这

种方式很容易不小心覆写文件，所以在使用 move()时应该注意。

destination 路径也可以指定一个文件名。在下面的例子中，source 文件被移动

并改名。

\>>> **shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')**

'C:\\eggs\\new_bacon.txt'

这一行是说，“将 C:\bacon.txt 移动到文件夹 C:\eggs，完成之后，将 bacon.txt

文件改名为 new_bacon.txt。”

前面两个例子都假设在 C:\目录下有一个文件夹 eggs。但是如果没有 eggs 文件

夹，move()就会将 bacon.txt 改名，变成名为 eggs 的文件。

\>>> **shutil.move('C:\\bacon.txt', 'C:\\eggs')**

'C:\\eggs'

这里，move()在 C:\目录下找不到名为 eggs 的文件夹，所以假定 destination 指

的是一个文件，而非文件夹。所以 bacon.txt 文本文件被改名为 eggs（没有.txt 文件

扩展名的文本文件），但这可能不是你所希望的！这可能是程序中很难发现的缺陷，

因为 move()调用会很开心地做一些事情，但和你所期望的完全不同。这也是在使用

move()时要小心的另一个理由。

最后，构成目的地的文件夹必须已经存在，否则 Python 会抛出异常。在交互式

环境中输入以下代码：

\

```
>>> **shutil.move('spam.txt', 'c:\\does_not_exist\\eggs\\ham')**

Traceback (most recent call last):

File "C:\Python34\lib\shutil.py", line 521, in move

os.rename(src, real_dst)

FileNotFoundError: [WinError 3] The system cannot find the path specified:

'spam.txt' -> 'c:\\does_not_exist\\eggs\\ham'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):

File "<pyshell#29>", line 1, in <module>

shutil.move('spam.txt', 'c:\\does_not_exist\\eggs\\ham')

File "C:\Python34\lib\shutil.py", line 533, in move

copy2(src, real_dst)

File "C:\Python34\lib\shutil.py", line 244, in copy2

copyfile(src, dst, follow_symlinks=follow_symlinks)

File "C:\Python34\lib\shutil.py", line 108, in copyfile

with open(dst, 'wb') as fdst:

FileNotFoundError: [Errno 2] No such file or directory: 'c:\\does_not_exist\\

eggs\\ham'
```





第 9 章

shutil 模块提供了一些函数，用于复制文件和整个文件夹。

抛出异常使用 raise 语句。在代码中，raise 语句包含以下部分：

• raise 关键字；

• 对 Exception 函数的调用；

• 传递给 Exception 函数的字符串，包含有用的出错信息。

例如，在交互式环境中输入以下代码：

\

```python
>>> **raise Exception('This is the error message.')**

Traceback (most recent call last):

File "<pyshell#191>", line 1, in <module>

 raise Exception('This is the error message.')

Exception: This is the error message
```

.

要启用 logging 模块，在程序运行时将日志信息显示在屏幕上，请将下面的代

码复制到程序顶部（但在 Python 的#!行之下）：

```python
import logging

logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s

\- %(message)s')
```

你将学习几个模块，让在 Python 中抓取网页变得很容易。

webbrowser：是 Python 自带的，打开浏览器获取指定页面。

requests：从因特网上下载文件和网页。

Beautiful Soup：解析 HTML，即网页编写的格式。

selenium：启动并控制一个 Web 浏览器。selenium 能够填写表单，并模拟鼠标

在这个浏览器中点击。

 

webbrowser 模块的 open()函数可以启动一个新浏览器，打开指定的 URL。在交

requests 模块让你很容易从 Web 下载文件，不必担心一些复杂的问题，诸如网

络错误、连接问题和数据压缩。requests 模块不是 Python 自带的，所以必须先安装。

通过命令行，运行 pip install requests（附录 A 详细介绍了如何安装第三方模块）。

用 requests.get()函数下载一个网页









Python 没有自带 openpyxl，所以必须安装。按照附录 A 中安装第三方模块的指

令，模块的名称是 openpyxl。要测试它是否安装正确，就在交互式环境中输入以下

代码：

\>>> **import openpyxl**

用 openpyxl 模块打开 Excel 文档

在导入 openpyxl 模块后，就可以使用 openpyxl.load_workbook()函数。在交互式

环境中输入以下代码：

\

```python
>>> **import openpyxl**

\>>> **wb = openpyxl.load****_****workbook('example.xlsx')**

\>>> **type(wb)**

<class 'openpyxl.workbook.workbook.Workbook'>
```



从工作簿中取得工作表 

调用 get_sheet_names()方法可以取得工作簿中所有表名的列表。在交互式环境中

输入以下代码：

\>

```
>> **import openpyxl**

\>>> **wb = openpyxl.load****_****workbook('example.xlsx')**

\>>> **wb.get****_****sheet****_****names()**

['Sheet1', 'Sheet2', 'Sheet3']

\>>> **sheet = wb.get****_****sheet****_****by****_****name('Sheet3')**

\>>> **sheet**

<Worksheet "Sheet3">

\>>> **type(sheet)**

<class 'openpyxl.worksheet.worksheet.Worksheet'>

\>>> **sheet.title**

'Sheet3'

\>>> **anotherSheet = wb.get****_****active****_****sheet()**

\>>> **anotherSheet**

<Worksheet "Sheet1">


```

从表中取得单元格 

有了 Worksheet 对象后，就可以按名字访问 Cell 对象。在交互式环境中输入以

下代码：

\

```
>>> **import openpyxl**

\>>> **wb = openpyxl.load****_****workbook('example.xlsx')**

\>>> **sheet = wb.get****_****sheet****_****by****_****name('Sheet1')**

\>>> **sheet['A1']**

<Cell Sheet1.A1>

\>>> **sheet['A1'].value**

datetime.datetime(2015, 4, 5, 13, 34, 2)

\>>> **c = sheet['B1']**

\>>> **c.value**

'Apples'

\>>> **'Row ' + str(c.row) + ', Column ' + c.column + ' is ' + c.value**

'Row 1, Column B is Apples'

\>>> **'Cell ' + c.coordinate + ' is ' + c.value**

'Cell B1 is Apples'

\>>> **sheet['C1'].value**

73
```

 工作簿、工作表、单元格 

作为快速复习，下面是从电子表格文件中读取单元格涉及的所有函数、方法和

数据类型。

1．导入 openpyxl 模块。

2．调用 openpyxl.load_workbook()函数。

3．取得 Workbook 对象。

4．调用 get_active_sheet()或 get_sheet_by_name()工作簿方法。

5．取得 Worksheet 对象。

6．使用索引或工作表的 cell()方法，带上 row 和 column 关键字参数。

7．取得 Cell 对象。

8．读取 Cell 对象的 value 属性。

## 复习 PyAutoGUI 的函数

本章介绍了许多不同函数，下面是快速的汇总参考：

moveTo（

x，y）将鼠标移动到指定的 x、y 坐标。

moveRel（xOffset，yOffset）相对于当前位置移动鼠标。

dragTo（

x，y）按下左键移动鼠标。

dragRel（xOffset，yOffset）按下左键，相对于当前位置移动鼠标。

click（

x，y，button）模拟点击（默认是左键）。

rightClick() 模拟右键点击。

middleClick() 模拟中键点击。

doubleClick() 模拟左键双击。

mouseDown（

x，y，button）模拟在 x、y 处按下指定鼠标按键。

mouseUp（

x，y，button）模拟在 x、y 处释放指定键。

scroll（units）模拟滚动滚轮。正参数表示向上滚动，负参数表示向下滚动。

typewrite（message）键入给定消息字符串中的字符。

typewrite（[key1，key2，key3]）键入给定键字符串。

press（key）按下并释放给定键。

keyDown（key）模拟按下给定键。

keyUp（key）模拟释放给定键。

hotkey（[key1，key2，key3]）模拟按顺序按下给定键字符串，然后以相反的顺

序释放。

screenshot() 返回屏幕快照的 Image 对象（参见第 17 章关于 Image 对象的

信息）。
