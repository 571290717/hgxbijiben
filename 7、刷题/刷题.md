# 刷题



###### 1、链表

```Python
#注：写哈希表 之前，先写个链表
#注：链表的创建
class LinkList: #注：链表类
    class Node: #注：链表里的节点
        def __init__(self, item=None):
            self.item = item
            self.next = None

    class LinkListIterator: #注：这个类是一个迭代器 因为 支持__next__
        def __init__(self, node):
            self.node = node

        def __next__(self):
            if self.node:   #注：如果node不是空
                cur_node = self.node
                self.node = cur_node.next
                return cur_node.item
            else:
                raise StopIteration
        def __iter__(self):
            return self

    def __init__(self, iterable=None):  #注：构造函数。传一个列表
        self.head = None
        self.tail = None
        if iterable:    #注：如果有列表
            self.extend(iterable)

#注：extend()接受一个列表参数  [1,2].extend([1,2,3]) [1,2,1,2,3]
#注：append()接受一个对象参数  [1,2].append([1,2,3]) [1,2,[1,2,3]]
    def append(self, obj):  #注：尾插
        s = LinkList.Node(obj)  #注：创建节点
        if not self.head:   #注：如果head是空
            self.head = s
            self.tail = s
        else:               #注：如果head不是空，插到尾巴上
            self.tail.next = s
            self.tail = s

    def extend(self, iterable): #注：循环调appdend 就有extend了
        for obj in iterable:
            self.append(obj)

    def find(self, obj):    #注：在链表里查找，for循环查
        for n in self:      #注：self是linklist对象，self是迭代的支持这种写法
            if n == obj:
                return True
        else:
            return False

    def __iter__(self): #注：写迭代器的 支持迭代
        return self.LinkListIterator(self.head)

    def __repr__(self):     #注：转换成字符串
        return "<<"+", ".join(map(str, self))+">>"
        #注：map对于可迭代对象的每个元素 转换成字符串str

        
        
        
lk = LinkList([1,2,3,4,5])  #注：可迭代对象
for element in lk:
    print(element)
#结果为
# 1
# 2
# 3
# 4
# 5
print(lk)
#结果 <<1, 2, 3, 4, 5>>
```







###### 2、哈希表



```
#注：在这基础上 写 哈希表

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):   #注：哈希表的构造函数,size哈希表的大小
        self.size = size
        self.T = [LinkList() for i in range(self.size)]   #注：开一个T列表，每个位置都是一个链表（拉链法）
        #注：刚开始T列表 每一个位置都是一个空链表 LinkList()

    def h(self, k): #注：哈希函数
        return k % self.size    #注：对self.size取模

    def insert(self, k):    #注：插入
        #注：计算哈希函数 返回的哈希值
        i = self.h(k)
        #注：k这个元素 要插到i这个位置上去
        #注：判断这个元素在不在里面
        if self.find(k):    #注：如果找到了，我就不插入。达到哈希 去重的目的
            print("Duplicated Insert.") #注：重复插入 提醒
        else:   #注：如果没找到，插入
            self.T[i].append(k) #注：插入

    def find(self, k):  #注：先写 查找函数
        i = self.h(k)   #注：先找到k的哈希值
        return self.T[i].find(k)    #注：T[i] 是个链表

#注：哈希表 删除功能 没写。写删除的话 链表就得支持删除的功能

ht = HashTable()    #注：创建HashTable对象

ht.insert(0)
ht.insert(1)
# ht.insert(0)
# #注：输入第3条语句时 ，提示 Duplicated Insert.
ht.insert(3)
ht.insert(102)
ht.insert(508)

print(",".join(map(str, ht.T)))
#注：打印这个哈希表，1和102在一个链表里，因为 哈希表的长度是101，102对101取余剩1
#注：508对101取余剩3
# <<0>>,<<1, 102>>,<<>>,<<3, 508>>,<<>>,<<>>,<<>>,…………

print(ht.find(3))
#结果为 True
print(ht.find(102)) #注：也能找到，它是个链表， 先去1那个位置上找，发现1 不是，102 是，找到了
#结果为 True
print(ht.find(203))
#结果为 False      #注：因为发现 1 不是，102 不是，没了  返回一个false

#注：集合实现 跟它差不错
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

```
#哈希表 精简代码

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):
        self.size = size
        self.T = [LinkList() for i in range(self.size)]

    def h(self, k):
        return k % self.size

    def insert(self, k):
        i = self.h(k)
        if self.find(k):
            print("Duplicated Insert.")
        else:
            self.T[i].append(k)

    def find(self, k):
        i = self.h(k)
        return self.T[i].find(k)

ht = HashTable()

ht.insert(0)
ht.insert(1)
ht.insert(3)
ht.insert(102)
ht.insert(508)

#print(",".join(map(str, ht.T)))
print(ht.find(203))![点击并拖拽以移动]()
```

# python列表反转的4种方法

```python
# reverse()方法
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a.reverse()
print('列表反转结果：', a)

# 内置reversed()函数
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = reversed(a)
print('列表反转结果（迭代对象）：', a1)
print('列表反转结果转换成列表：', list(a1))

# 切片实现反转
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
print('列表反转结果：', a[::-1])


# 使用for循环
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = [a[len(a)-i-1] for i in range(len(a))]
print('列表反转结果：', a1)



```







3、SQL

```mysql
查看所有数据库
	show databases;

创建数据库
	create database 数据库名 charset=utf8;

使用数据库
	use 数据库名;

查看当前使用的数据库
	select database();

删除数据库-慎重
	drop database 数据库名;

查看当前数据库中所有表
	show tables;

创建表
	create table students(
 id int unsigned primary key auto_increment not null,
 name varchar(20) not null,
 age tinyint unsigned default 0,
 height decimal(5,2),
 gender enum('男','女','人妖','保密')
);

创建表

​	create table 表名(
字段名称 数据类型  可选的约束条件,
column1 datatype contrai,
...
);

修改表-添加字段
	alter table 表名 add 列名 类型 约束;
例：
alter table students add birthday datetime;

修改表-修改字段类型
	alter table 表名 modify 列名 类型 约束;
例：
alter table students modify birthday date not null;
	说明:
modify: 只能修改字段类型或者约束，不能修改字段名

修改表-修改字段名和字段类型
	alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
	说明:
change: 既能对字段重命名又能修改字段类型还能修改约束


修改表-删除字段
	alter table 表名 drop 列名;
例：
alter table students drop birthday;


查看创表SQL语句
	show create table 表名;
例：
show create table students;


查看创库SQL语句
	show create database 数据库名;
例：
show create database mytest;


删除表
	drop table 表名;
例：
drop table students;


查询数据
	-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;


添加数据
	-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
	说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值


修改数据
	update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;

删除数据
	delete from 表名 where 条件
例：
delete from students where id=5;
	问题:
	上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
	-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
	说明:
	逻辑删除，本质就是修改操作



5. 小结
	登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件



使用 as 给字段起别名
select id as 序号, name as 名字, gender as 性别 from students;

distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
as 关键字可以给表中字段 或者 表名起别名
distinct 关键字可以去除重复数据行。



7. 小结
	常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null

4. 模糊查询
	like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
	例1：查询姓黄的学生:
select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:
select * from students where name like '黄_';
3：查询姓黄或叫靖的学生:
select * from students where name like '黄%' or name like '%靖';



1. 排序查询语法
	排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:
先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:
select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:
select * from students  order by age desc,height desc;




2. 分页查询的语法
	select * from 表名 limit start,count
说明:
limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:
select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;

3. 分页查询案例
	已知每页显示m条数据，求第n页显示的数据
提示: 关键是求每页的开始行索引
查询学生表，获取第n页数据的SQL语句:
select * from students limit (n-1)*m,m


6. 求平均值
	-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
	说明
	ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。

8. 小结
	count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值



分组查询
	学习目标
		能够写出分组查询的SQL语句
	1. 分组查询介绍
		分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
	2. group by的使用
		group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
	3. group by + group_concat()的使用
		group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
	4. group by + 聚合函数的使用
		- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
	5. group by + having的使用
		having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
	6. group by + with rollup的使用
		with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
	7. 小结
		group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果



内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;



左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;




右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;



自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:
小结
	自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
	自连接就是一种特殊的连接方式，连接的表还是本身这张表


2. 子查询的使用
	例1. 查询大于平均年龄的学生:
select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:
select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:
select * from students where (age, height) =  (select max(age), max(height) from students);














```





l

```mysql
演练-分组和聚合函数的组合使用
	学习目标
		能够写出分组和聚合函数组合使用的SQL语句
	1. 数据准备
		-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
		表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
	2. SQL语句演练
		查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;
```





```mysql
事务
	学习目标
		能够知道事务的四大特性
	1. 事务的介绍
		事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
	2. 事务的四大特性
		原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
	3. 事务的使用
		在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
		-- 查看MySQL数据库支持的表的存储引擎
show engines;
	查看goods表的创表语句:
		-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
	开启事务:

begin;
或者
start transaction;
	4. 小结
		事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
索引
	学习目标
		能够写出创建索引的SQL语句
	1. 索引的介绍
		索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
		应用场景:
		当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
	2. 索引的使用
		查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
	3. 案例-验证索引查询性能
		创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
	4. 联合索引
		联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
	5. 联合索引的最左原则
		在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
	6. MySQL中索引的优点和缺点和使用原则
		优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
	7. 小结
		索引是加快数据库的查询速度的一种手段
		创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
		删除索引使用: alter table 表名 drop index 索引名;
```



5、装饰器



```python
import time
 
#  装饰器run_time,@run_time加在谁头上，谁就是参数fun
def run_time(fun):
 
    start_time = time.time()
    fun()
    end_time = time.time()
 
    print("程序运行时间为：{} 秒".format(str(round((end_time - start_time), 1))))
    return end_time - start_time
 
#  耗时任务task
@run_time
def task():
    time.sleep(3)
    
    
```



快速排序

`

```python
def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟`


def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]


            
            
            
            
  #二分




def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分


```





## Linux

1、查找文件

 find  /目录 -name filename.txt



2、查看一个程序是否运行   				ps         -ef|grep     进程名字

​				grep 命令的基本格式			 grep [选项] 模式 文件名

3、终止线程							kill  -9  进程号



4、查看文件包含的隐藏文件    		ls  -al 



5、查看当前工作目录					  pwd



6、复制文件包含其子文件到自定义目录			cp 	 -r	sourceFolder   targetFolder



7、创建目录						mkdir	newfolder



8、删除目录					rmdir  【 】 documents    -v显示详细执行过程   -p 删除指定目录及子空目录



9、删除文件包括其子文件		rm 		-rf 		deletefile



10、移动文件 		mv  	/temp/movefile		/targetfolder 	+		mv  oldnamefile	newnamefile



11、切换用户 		su 	-username



12、修改文件权限		chmod	777   	file        -rwxrwxrwx



13、压缩文件		tar		-czf		test.tar.gz  	/test1/test2



14、列出压缩文件列表	tar 	-tzf	test.tar.gz



15、解压文件			tar 	-xvzf		test.tar.gz



16、查看文件头10行		head		-n		10		example.txt



17、查看文件尾10行		tail			-n		10	example.txt

  

18、查看日志文件 			tail			-f		example.log 	

 19 、启动vi编辑器			vi

20、查看系统当前时间		date		

21、 cd

22、ls

23、grep 

24、find

25、mkdir

26、cp -a file1 file2				cp file1 file2 file3 	dir

27.mv

28.rm -fr dir

29.ps  -a     ps  -ef

30. netstat -a      # 列出所有端口

    netstat -at     # 列出所有TCP端口

    netstat -au    # 列出所有UDP端口

    netstat -ax    # 列出所有unix端口

    netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名



一、linux管理和目录命令
pwd 显示当前路径地址
cd 改变当前用户的目录
ls 查看当前文件夹下的文件
mkdir  新建文件夹目录
rmdir  删除文件夹目录
touch  新建文件
cat    查看文本内容
mv     移动
cp	复制
rm	删除
grep	字符串查找

二、线上查找
man 查看当前或者一个命令的使用方法
locate 根据一个关键字或者关键词定位
whatis 查看某个命令的含义
三、文件阅读命令
head	从头开始查看
tail 	从尾开始查看
more	分页查看
四、文件或目录的压缩和解压缩
tar 
gzip
bizip2
gunzip
bunzip
五权限管理
chmod	修改权限
useradd	用户添加
userdel 用户删除
su	切换用户
passwd	修改密码
chgrp	修改文件所在组
chown	用来修改文件的所有者
六、文件的定位和查找
which  定位
whereis	查找
七、磁盘操作
df 查看文件系统使用情况
du 查看文件磁盘占用情况
八、系统命令
reboot重启
shutdown 关机
halt	关机
ps	进程
toop	进程
date	日期
cal	日历
exit	退出
kill	结束进程
九网络
ipconfig 显示网络状态
ping	监测主机
netstat	知道整个linux系统的网络情况或显示网络状态

top 查看cpu、内存密集使用的动态数据
free 查看内存使用情况
du 查看目录或文件的大小
df 查看磁盘分区的大小
cd 切换目录
ls 显示目录中的内容
cat 查看文件中的数据
vi 进入打开、修改、保存文件
rm 删除目录或者文件
mkdir 创建目录
touch 如果一个文件不存在，则创建文件，如果一个文件存在，则修改最后的访问时间
cp拷贝目录或文件



# 网络



## 两种 HTTP 请求方法：GET 和 POST

- **GET** - 从指定的资源请求数据。
- **POST** - 向指定的资源提交要被处理的数据。

**Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：**

-  **1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。**
-  **2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。**
-  **3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。**
-  **4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。**
-  **5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。**
-  **6、Get 是 Form 的默认方法。**

**使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。**







​     **当我们在浏览器地址上输入一个网址时，浏览器会进行(HTTP)HTTPS的的请求时，基本根据以下步骤。**
​    
​        **1.通过DNS解析域名获取服务器IP。**

**首先，浏览器会根据当前网址域名去DNS服务器上进行解析请求，然后DNS服务器会请求到当前域名所对应的服务器IP地址，并将此IP地址返回给浏览器，浏览器再通过该浏览器访问当前服务器。****

​        **2.通过三次握手与服务器建立连接。**

**此时，在应用层是HTTP(HTTPS)协议，当进行到传输层时，服务器会通过TCP协议进行三次握手，首先客户端发送一个连接数据包给服务器(SYN = 1)，接着服务器会响应一个数据包给客户端，代表允许建立连接，然后客户端再发送一个数据包给客户端代表此时连接建立成功，-->-->**

​        **3.如果为HTTPS请求，则需要通过SSL证书加密。**

**如果是HTTPS协议，服务器首先会发送一个SSL证书给浏览器，浏览器检查当前证书是否过期以及证书是否安全，如果安全，则产生一个随机密钥通过SSL证书的公钥进行加密，将密钥发送给服务器端，服务器端根据自己的私钥对发送过来的密钥进行解密，**

​        **4.进行传输内容。**

**得到随机密钥后，通过随机密钥对要传输的内容加密，然后发送给服务器端，**

​        **5.TCP连接是否为长连接？**

TCP连接在这个过程中，还是基于TCP协议进行报文的发送与接收。如果说浏览器的connection = Keep-alive，代表本次TCP连接是一个长连接，不会主动释放连接，当传输内容完毕后，需要主动释放连接，**

​        **6.通过四次挥手释放连接**

**此时需要客户端发送挥手报文(FIN = 1)，服务器接收到后会发送一个确认报文，如果有未发送完的数据，接着发送数据，如果数据发送完毕，此时服务器会再发送一个数据包(FIN = 1,ACK = 1)给浏览器，浏览器再发送一个确认数据包给服务器，四次握手结束，这就是一个完整的访问网页的过程。**



**进程(Process)：进程是计算机中的程序关于某数据集合的一次运行实例，是操作系统进行资源分配的最小单位**
**线程(Thread)：线程被包含在进程之中，是操作系统进行程序调度执行的最小单位**
**协程(Coroutine)：协程是用户态执行的轻量级编程模型，由单一线程内部发出控制信号进行调度**





迭代器与生成器的区别：
（1）生成器：
生成器本质上就是一个函数，它记住了上一次返回时在函数体中的位置。
对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。
而且记录了程序执行的上下文。
生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。

（2）迭代器

迭代器是一种支持next()操作的对象。它包含了一组元素，当执行next()操作时，返回其中一个元素。
当所有元素都被返回后，再执行next()报异常—[StopIteration](https://so.csdn.net/so/search?q=StopIteration&spm=1001.2101.3001.7020)
生成器一定是可迭代的，也一定是迭代器对象

（3）区别：
①生成器是生成元素的，迭代器是访问集合元素的一中方式
②迭代输出生成器的内容
③迭代器是一种支持next()操作的对象
④迭代器（iterator）：其中iterator对象表示的是一个数据流，可以把它看做一个有序序列，但我们不能提前知道序列的长度，只有通过nex()函数实现需要计算的下一个数据。可以看做生成器的一个子集。







 装饰器本质上是一个Python函数(其实就是闭包)，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。





```

# 为函数添加一个统计运行时长的功能
import time
 
def how_much_time(func):
    def inner():
        t_start = time.time()
        func()
        t_end = time.time()
        print("一共花费了{0}秒时间".format(t_end - t_start, ))
    return inner
    # 将增加的新功能代码以及被装饰函数运行代码func()一同打包返回，返回的是一个内部函数，这个被返回的函数就是装饰器
 
def sleep_5s():
    time.sleep(5)
    print("%d秒结束了" % (5,))
 
def sleep_6s():
    time.sleep(6)
    print("%d秒结束了" % (6,))
 
sleep_5s = how_much_time(sleep_5s)
# 因为sleep_5s函数的功能就是睡5秒钟，虽然增加了统计运行时间的功能，但是他本身功能没变(还是睡5秒钟)，所以仍然用原来函数名接收增加功能了的自己
sleep_6s = how_much_time(sleep_6s)
 
t1 = threading.Thread(target=sleep_5s)
t2 = threading.Thread(target=sleep_6s)
t1.start()
t2.start()
# 5秒结束了
# 一共花费了5.014161109924316秒时间
# 6秒结束了
# 一共花费了6.011810302734375秒时间

```





建立连接的方式又称为三次握手：

（1）第一次握手，主机A向主机B发出请求数据包：“我想给你发数据，可以吗？”这是第一次对话。

（2）第二次握手，主机B向主机A发送同意连接，并要求同步的数据包（同步就是两台主机协调工作，一台在发送，一台在接收）：“可以，你什么时候发？”这是第二次对话。

（3）第三次握手，主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接收吧！”这是第三次对话。

这三次对话的目的是使数据包的发送和接收同步，TCP协议是一定要经过这三次对话之后，主机A才可以向主机B正式发送数据。


TCP建立连接需要进行三次握手，但是断开连接却要进行四次挥手：

（1）第一次挥手，在主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求。

（2）第二次挥手，主机B收到FIN位置上的1信息后对其做出响应，确认这一方向上的TCP连 接将关闭，将ACK置1。

（3）第三次挥手，B主机再提出反方向的关闭请求，并将控制位FIN置1，发送给A主机，并关闭连接。

（4）第四次挥手，主机A对主机B的请求进行确认，将ACK置1，并关闭连接，至此双方关闭连接。





一、TCP和UDP是什么？
TCP：传输控制协议(Transmission Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信 协议。由IETF的RFC 793定义。

UDP：用户数据报协议(User Datagram Protocol)，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。由RFC 768描述了UDP。


二、TCP与UDP的区别是什么？
1、连接方面

TCP面向连接(如打电话先拨号建立连接)。

UDP无连接，即发送数据报之前不用建立连接。

2、安全方面

TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达。

UDP尽最大努力交付，即不保证可靠交付。

3、传输效率

TCP传输效率较低，UDP传输效率较高。

4、连接数量的区别

TCP连接只能是一对一、点对点的。

UDP支持一对一、一对多、多对一和多对多的交互通信。

5、首部

TCP报文首部20个字节，UDP首部8个字节。

6、可靠

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

7、面向方式

TCP面向字节流。实际上是TCP把数据看成一串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题。

UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

三、TCP的三次握手与四次挥手
1、TCP三次握手
三次握手是TCP用来确保连接可靠建立的方式：

第一次握手：A给B发短信说：“B，你现在有空吗？”
第二次握手：B此时收到了A的信息，然后对A说：“我有空，你呢？有空吗？”
第三次握手：A此时收到了A的信息，然后说：“我也有空，那我给你说个事。”
在三次握手之后，A和B都能确定这么一件事：双方的通信可以流畅的进行。这样，双方就可以开始进行正常的对 话了。

2、TCP四次挥手
四次挥手是TCP用来确保连接可靠关闭的方式：

第一次挥手：A给B发短信说，“B，我要准备吃饭了？”
第二次挥手：B此时收到了A的信息，然后先对A说：“我知道了。”
第三次挥手：B对A说：“我也要准备吃饭了。”然后放下了手机
第四次挥手：A此时收到了B的确认信息，然后向B发送一个包说：“好的，知道了。”这时才放下手机去吃饭
在四次挥手之后，A和B都能确定这么一件事：双方的通信都可以正常关闭，这样，双方就可以确定对方已经完全知道了自己要确认关闭连接。

![在这里插入图片描述](D:\hgx笔记\hgxbijiben\7、刷题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzg1Njkx,size_16,color_FFFFFF,t_70)







```python
Python 数组翻转指定个数的元素
	定义一个整型数组，并将指定个数的元素翻转到数组的尾部。

例如：(ar[], d, n) 将长度为 n 的 数组 arr 的前面 d 个元素翻转到数组尾部。

以下演示了将数组的前面两个元素放到数组后面。
	def leftRotate(arr, d, n):
    for i in range(d):
        leftRotatebyOne(arr, n)
def leftRotatebyOne(arr, n):
    temp = arr[0]
    for i in range(n-1):
        arr[i] = arr[i+1]
    arr[n-1] = temp
         
 
def printArray(arr,size):
    for i in range(size):
        print ("%d"% arr[i],end=" ")
 

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
		3 4 5 6 7 1 2
		类似冒泡排序的解法引入temp变量
	def leftRotate(arr, d, n):
    for i in range(gcd(d,n)):
         
        temp = arr[i]
        j = i
        while 1:
            k = j + d
            if k >= n:
                k = k - n
            if k == i:
                break
            arr[j] = arr[k]
            j = k
        arr[j] = temp

def printArray(arr, size):
    for i in range(size):
        print ("%d" % arr[i], end=" ")

def gcd(a, b):
    if b == 0:
        return a;
    else:
        return gcd(b, a%b)

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
	def rverseArray(arr, start, end):
    while (start < end):
        temp = arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        start += 1
        end = end-1
 
def leftRotate(arr, d):
    n = len(arr)
    rverseArray(arr, 0, d-1)
    rverseArray(arr, d, n-1)
    rverseArray(arr, 0, n-1)
 
def printArray(arr):
    for i in range(0, len(arr)):
        print (arr[i], end=' ')
 
arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2)
printArray(arr)



Python 将列表中的指定位置的两个元素对调
	定义一个列表，并将列表中的指定位置的两个元素对调。

例如，对调第一个和第三个元素：

对调前 : List = [23, 65, 19, 90], pos1 = 1, pos2 = 3
对调后 : [19, 65, 23, 90]
	def swapPositions(list, pos1, pos2):
     
    list[pos1], list[pos2] = list[pos2], list[pos1]
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
     
    first_ele = list.pop(pos1)    
    second_ele = list.pop(pos2-1)
     
    list.insert(pos1, second_ele)  
    list.insert(pos2, first_ele)  
     
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
 
    get = list[pos1], list[pos2]
       
    list[pos2], list[pos1] = get
       
    return list
 
List = [23, 65, 19, 90]
 
pos1, pos2  = 1, 3
print(swapPositions(List, pos1-1, pos2-1))
	def reversal(list,n1,n2):
    temp = list[n1]
    list[n1] = list[n2]
    list[n2] = temp
    print(list)
list = [1,2,3,4,5,6,7]
reversal(list,4,5)



Python 翻转列表
	定义一个列表，并将它翻转。

例如：

翻转前 : list = [10, 11, 12, 13, 14, 15]
翻转后 : [15, 14, 13, 12, 11, 10]
	def Reverse(lst):
    return [ele for ele in reversed(lst)]
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    lst.reverse()
    return lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    new_lst = lst[::-1]
    return new_lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))





Python 将字符串的时间转换为时间戳
	import time
 
a1 = "2019-5-10 23:40:00"
# 先转换为时间数组
timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")
 
# 转换为时间戳
timeStamp = int(time.mktime(timeArray))
print(timeStamp)
 
 
# 格式转换 - 转为 /
a2 = "2019/5/10 23:40:00"
# 先转换为时间数组,然后转换为其他格式
timeArray = time.strptime(a2, "%Y/%m/%d %H:%M:%S")
otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)
print(otherStyleTime)
```

