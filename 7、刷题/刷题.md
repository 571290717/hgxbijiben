# 刷题



###### 1、链表

```Python
#注：写哈希表 之前，先写个链表
#注：链表的创建
class LinkList: #注：链表类
    class Node: #注：链表里的节点
        def __init__(self, item=None):
            self.item = item
            self.next = None

    class LinkListIterator: #注：这个类是一个迭代器 因为 支持__next__
        def __init__(self, node):
            self.node = node

        def __next__(self):
            if self.node:   #注：如果node不是空
                cur_node = self.node
                self.node = cur_node.next
                return cur_node.item
            else:
                raise StopIteration
        def __iter__(self):
            return self

    def __init__(self, iterable=None):  #注：构造函数。传一个列表
        self.head = None
        self.tail = None
        if iterable:    #注：如果有列表
            self.extend(iterable)

#注：extend()接受一个列表参数  [1,2].extend([1,2,3]) [1,2,1,2,3]
#注：append()接受一个对象参数  [1,2].append([1,2,3]) [1,2,[1,2,3]]
    def append(self, obj):  #注：尾插
        s = LinkList.Node(obj)  #注：创建节点
        if not self.head:   #注：如果head是空
            self.head = s
            self.tail = s
        else:               #注：如果head不是空，插到尾巴上
            self.tail.next = s
            self.tail = s

    def extend(self, iterable): #注：循环调appdend 就有extend了
        for obj in iterable:
            self.append(obj)

    def find(self, obj):    #注：在链表里查找，for循环查
        for n in self:      #注：self是linklist对象，self是迭代的支持这种写法
            if n == obj:
                return True
        else:
            return False

    def __iter__(self): #注：写迭代器的 支持迭代
        return self.LinkListIterator(self.head)

    def __repr__(self):     #注：转换成字符串
        return "<<"+", ".join(map(str, self))+">>"
        #注：map对于可迭代对象的每个元素 转换成字符串str

        
        
        
lk = LinkList([1,2,3,4,5])  #注：可迭代对象
for element in lk:
    print(element)
#结果为
# 1
# 2
# 3
# 4
# 5
print(lk)
#结果 <<1, 2, 3, 4, 5>>
```







###### 2、哈希表



```
#注：在这基础上 写 哈希表

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):   #注：哈希表的构造函数,size哈希表的大小
        self.size = size
        self.T = [LinkList() for i in range(self.size)]   #注：开一个T列表，每个位置都是一个链表（拉链法）
        #注：刚开始T列表 每一个位置都是一个空链表 LinkList()

    def h(self, k): #注：哈希函数
        return k % self.size    #注：对self.size取模

    def insert(self, k):    #注：插入
        #注：计算哈希函数 返回的哈希值
        i = self.h(k)
        #注：k这个元素 要插到i这个位置上去
        #注：判断这个元素在不在里面
        if self.find(k):    #注：如果找到了，我就不插入。达到哈希 去重的目的
            print("Duplicated Insert.") #注：重复插入 提醒
        else:   #注：如果没找到，插入
            self.T[i].append(k) #注：插入

    def find(self, k):  #注：先写 查找函数
        i = self.h(k)   #注：先找到k的哈希值
        return self.T[i].find(k)    #注：T[i] 是个链表

#注：哈希表 删除功能 没写。写删除的话 链表就得支持删除的功能

ht = HashTable()    #注：创建HashTable对象

ht.insert(0)
ht.insert(1)
# ht.insert(0)
# #注：输入第3条语句时 ，提示 Duplicated Insert.
ht.insert(3)
ht.insert(102)
ht.insert(508)

print(",".join(map(str, ht.T)))
#注：打印这个哈希表，1和102在一个链表里，因为 哈希表的长度是101，102对101取余剩1
#注：508对101取余剩3
# <<0>>,<<1, 102>>,<<>>,<<3, 508>>,<<>>,<<>>,<<>>,…………

print(ht.find(3))
#结果为 True
print(ht.find(102)) #注：也能找到，它是个链表， 先去1那个位置上找，发现1 不是，102 是，找到了
#结果为 True
print(ht.find(203))
#结果为 False      #注：因为发现 1 不是，102 不是，没了  返回一个false

#注：集合实现 跟它差不错
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

```
#哈希表 精简代码

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):
        self.size = size
        self.T = [LinkList() for i in range(self.size)]

    def h(self, k):
        return k % self.size

    def insert(self, k):
        i = self.h(k)
        if self.find(k):
            print("Duplicated Insert.")
        else:
            self.T[i].append(k)

    def find(self, k):
        i = self.h(k)
        return self.T[i].find(k)

ht = HashTable()

ht.insert(0)
ht.insert(1)
ht.insert(3)
ht.insert(102)
ht.insert(508)

#print(",".join(map(str, ht.T)))
print(ht.find(203))![点击并拖拽以移动]()
```

# python列表反转的4种方法

```python
# reverse()方法
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a.reverse()
print('列表反转结果：', a)

# 内置reversed()函数
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = reversed(a)
print('列表反转结果（迭代对象）：', a1)
print('列表反转结果转换成列表：', list(a1))

# 切片实现反转
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
print('列表反转结果：', a[::-1])


# 使用for循环
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = [a[len(a)-i-1] for i in range(len(a))]
print('列表反转结果：', a1)



```







3、SQL

```mysql
查看所有数据库
	show databases;

创建数据库
	create database 数据库名 charset=utf8;

使用数据库
	use 数据库名;

查看当前使用的数据库
	select database();

删除数据库-慎重
	drop database 数据库名;

查看当前数据库中所有表
	show tables;

创建表
	create table students(
 id int unsigned primary key auto_increment not null,
 name varchar(20) not null,
 age tinyint unsigned default 0,
 height decimal(5,2),
 gender enum('男','女','人妖','保密')
);

创建表

​	create table 表名(
字段名称 数据类型  可选的约束条件,
column1 datatype contrai,
...
);

修改表-添加字段
	alter table 表名 add 列名 类型 约束;
例：
alter table students add birthday datetime;

修改表-修改字段类型
	alter table 表名 modify 列名 类型 约束;
例：
alter table students modify birthday date not null;
	说明:
modify: 只能修改字段类型或者约束，不能修改字段名

修改表-修改字段名和字段类型
	alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
	说明:
change: 既能对字段重命名又能修改字段类型还能修改约束


修改表-删除字段
	alter table 表名 drop 列名;
例：
alter table students drop birthday;


查看创表SQL语句
	show create table 表名;
例：
show create table students;


查看创库SQL语句
	show create database 数据库名;
例：
show create database mytest;


删除表
	drop table 表名;
例：
drop table students;


查询数据
	-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;


添加数据
	-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
	说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值


修改数据
	update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;

删除数据
	delete from 表名 where 条件
例：
delete from students where id=5;
	问题:
	上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
	-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
	说明:
	逻辑删除，本质就是修改操作



5. 小结
	登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件



使用 as 给字段起别名
select id as 序号, name as 名字, gender as 性别 from students;

distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
as 关键字可以给表中字段 或者 表名起别名
distinct 关键字可以去除重复数据行。



7. 小结
	常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null

4. 模糊查询
	like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
	例1：查询姓黄的学生:
select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:
select * from students where name like '黄_';
3：查询姓黄或叫靖的学生:
select * from students where name like '黄%' or name like '%靖';



1. 排序查询语法
	排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:
先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:
select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:
select * from students  order by age desc,height desc;




2. 分页查询的语法
	select * from 表名 limit start,count
说明:
limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:
select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;

3. 分页查询案例
	已知每页显示m条数据，求第n页显示的数据
提示: 关键是求每页的开始行索引
查询学生表，获取第n页数据的SQL语句:
select * from students limit (n-1)*m,m


6. 求平均值
	-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
	说明
	ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。

8. 小结
	count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值



分组查询
	学习目标
		能够写出分组查询的SQL语句
	1. 分组查询介绍
		分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
	2. group by的使用
		group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
	3. group by + group_concat()的使用
		group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
	4. group by + 聚合函数的使用
		- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
	5. group by + having的使用
		having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
	6. group by + with rollup的使用
		with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
	7. 小结
		group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果



内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;



左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;




右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;



自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:
小结
	自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
	自连接就是一种特殊的连接方式，连接的表还是本身这张表


2. 子查询的使用
	例1. 查询大于平均年龄的学生:
select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:
select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:
select * from students where (age, height) =  (select max(age), max(height) from students);














```





l

```mysql
演练-分组和聚合函数的组合使用
	学习目标
		能够写出分组和聚合函数组合使用的SQL语句
	1. 数据准备
		-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
		表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
	2. SQL语句演练
		查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;
```





```mysql
事务
	学习目标
		能够知道事务的四大特性
	1. 事务的介绍
		事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
	2. 事务的四大特性
		原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
	3. 事务的使用
		在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
		-- 查看MySQL数据库支持的表的存储引擎
show engines;
	查看goods表的创表语句:
		-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
	开启事务:

begin;
或者
start transaction;
	4. 小结
		事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
索引
	学习目标
		能够写出创建索引的SQL语句
	1. 索引的介绍
		索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
		应用场景:
		当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
	2. 索引的使用
		查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
	3. 案例-验证索引查询性能
		创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
	4. 联合索引
		联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
	5. 联合索引的最左原则
		在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
	6. MySQL中索引的优点和缺点和使用原则
		优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
	7. 小结
		索引是加快数据库的查询速度的一种手段
		创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
		删除索引使用: alter table 表名 drop index 索引名;
```



5、装饰器



```python
import time
 
#  装饰器run_time,@run_time加在谁头上，谁就是参数fun
def run_time(fun):
 
    start_time = time.time()
    fun()
    end_time = time.time()
 
    print("程序运行时间为：{} 秒".format(str(round((end_time - start_time), 1))))
    return end_time - start_time
 
#  耗时任务task
@run_time
def task():
    time.sleep(3)
    
    
```



快速排序

`

```python
def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟`


def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]


            
            
            
            
  #二分




def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分


```





## Linux

1、查找文件

 find  /目录 -name filename.txt



2、查看一个程序是否运行   				ps         -ef|grep     进程名字

​				grep 命令的基本格式			 grep [选项] 模式 文件名

3、终止线程							kill  -9  进程号



4、查看文件包含的隐藏文件    		ls  -al 



5、查看当前工作目录					  pwd



6、复制文件包含其子文件到自定义目录			cp 	 -r	sourceFolder   targetFolder



7、创建目录						mkdir	newfolder



8、删除目录					rmdir  【 】 documents    -v显示详细执行过程   -p 删除指定目录及子空目录



9、删除文件包括其子文件		rm 		-rf 		deletefile



10、移动文件 		mv  	/temp/movefile		/targetfolder 	+		mv  oldnamefile	newnamefile



11、切换用户 		su 	-username



12、修改文件权限		chmod	777   	file        -rwxrwxrwx



13、压缩文件		tar		-czf		test.tar.gz  	/test1/test2



14、列出压缩文件列表	tar 	-tzf	test.tar.gz



15、解压文件			tar 	-xvzf		test.tar.gz



16、查看文件头10行		head		-n		10		example.txt



17、查看文件尾10行		tail			-n		10	example.txt

  

18、查看日志文件 			tail			-f		example.log 	



