# 刷题



###### 1、链表

```Python
#注：写哈希表 之前，先写个链表
#注：链表的创建
class LinkList: #注：链表类
    class Node: #注：链表里的节点
        def __init__(self, item=None):
            self.item = item
            self.next = None

    class LinkListIterator: #注：这个类是一个迭代器 因为 支持__next__
        def __init__(self, node):
            self.node = node

        def __next__(self):
            if self.node:   #注：如果node不是空
                cur_node = self.node
                self.node = cur_node.next
                return cur_node.item
            else:
                raise StopIteration
        def __iter__(self):
            return self

    def __init__(self, iterable=None):  #注：构造函数。传一个列表
        self.head = None
        self.tail = None
        if iterable:    #注：如果有列表
            self.extend(iterable)

#注：extend()接受一个列表参数  [1,2].extend([1,2,3]) [1,2,1,2,3]
#注：append()接受一个对象参数  [1,2].append([1,2,3]) [1,2,[1,2,3]]
    def append(self, obj):  #注：尾插
        s = LinkList.Node(obj)  #注：创建节点
        if not self.head:   #注：如果head是空
            self.head = s
            self.tail = s
        else:               #注：如果head不是空，插到尾巴上
            self.tail.next = s
            self.tail = s

    def extend(self, iterable): #注：循环调appdend 就有extend了
        for obj in iterable:
            self.append(obj)

    def find(self, obj):    #注：在链表里查找，for循环查
        for n in self:      #注：self是linklist对象，self是迭代的支持这种写法
            if n == obj:
                return True
        else:
            return False

    def __iter__(self): #注：写迭代器的 支持迭代
        return self.LinkListIterator(self.head)

    def __repr__(self):     #注：转换成字符串
        return "<<"+", ".join(map(str, self))+">>"
        #注：map对于可迭代对象的每个元素 转换成字符串str

        
        
        
lk = LinkList([1,2,3,4,5])  #注：可迭代对象
for element in lk:
    print(element)
#结果为
# 1
# 2
# 3
# 4
# 5
print(lk)
#结果 <<1, 2, 3, 4, 5>>
```







###### 2、哈希表



```python
#注：在这基础上 写 哈希表

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):   #注：哈希表的构造函数,size哈希表的大小
        self.size = size
        self.T = [LinkList() for i in range(self.size)]   #注：开一个T列表，每个位置都是一个链表（拉链法）
        #注：刚开始T列表 每一个位置都是一个空链表 LinkList()

    def h(self, k): #注：哈希函数
        return k % self.size    #注：对self.size取模

    def insert(self, k):    #注：插入
        #注：计算哈希函数 返回的哈希值
        i = self.h(k)
        #注：k这个元素 要插到i这个位置上去
        #注：判断这个元素在不在里面
        if self.find(k):    #注：如果找到了，我就不插入。达到哈希 去重的目的
            print("Duplicated Insert.") #注：重复插入 提醒
        else:   #注：如果没找到，插入
            self.T[i].append(k) #注：插入

    def find(self, k):  #注：先写 查找函数
        i = self.h(k)   #注：先找到k的哈希值
        return self.T[i].find(k)    #注：T[i] 是个链表

#注：哈希表 删除功能 没写。写删除的话 链表就得支持删除的功能

ht = HashTable()    #注：创建HashTable对象

ht.insert(0)
ht.insert(1)
# ht.insert(0)
# #注：输入第3条语句时 ，提示 Duplicated Insert.
ht.insert(3)
ht.insert(102)
ht.insert(508)

print(",".join(map(str, ht.T)))
#注：打印这个哈希表，1和102在一个链表里，因为 哈希表的长度是101，102对101取余剩1
#注：508对101取余剩3
# <<0>>,<<1, 102>>,<<>>,<<3, 508>>,<<>>,<<>>,<<>>,…………

print(ht.find(3))
#结果为 True
print(ht.find(102)) #注：也能找到，它是个链表， 先去1那个位置上找，发现1 不是，102 是，找到了
#结果为 True
print(ht.find(203))
#结果为 False      #注：因为发现 1 不是，102 不是，没了  返回一个false

#注：集合实现 跟它差不错
```



```python
#哈希表 精简代码

# 类似于集合的结构
class HashTable:
    def __init__(self, size=101):
        self.size = size
        self.T = [LinkList() for i in range(self.size)]

    def h(self, k):
        return k % self.size

    def insert(self, k):
        i = self.h(k)
        if self.find(k):
            print("Duplicated Insert.")
        else:
            self.T[i].append(k)

    def find(self, k):
        i = self.h(k)
        return self.T[i].find(k)

ht = HashTable()

ht.insert(0)
ht.insert(1)
ht.insert(3)
ht.insert(102)
ht.insert(508)

#print(",".join(map(str, ht.T)))
print(ht.find(203))![点击并拖拽以移动]()
```

# python列表反转的4种方法

```python
# reverse()方法
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a.reverse()
print('列表反转结果：', a)

# 内置reversed()函数
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = reversed(a)
print('列表反转结果（迭代对象）：', a1)
print('列表反转结果转换成列表：', list(a1))

# 切片实现反转
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
print('列表反转结果：', a[::-1])


# 使用for循环
a = [1, 2, 3, 4, 5, 6, 7, 'abc', 'def']
a1 = [a[len(a)-i-1] for i in range(len(a))]
print('列表反转结果：', a1)



```

**This is a sample   -->  SAMPLE A IS tHIS**

```python
class solution:
    def trans(self,s,n):
        if n==0 :
            return s
        res = " "
        for i in range(n):
            if s[i]<='Z' and s[i]>='A':
                res +=chr(ord(s[i]) - ord('A') + ord('a'))
            elif s[i] >='a' and s[i]<='z':
                res +=chr(ord(s[i]) - ord('a') + ord('A'))
            else:
                res +=s[i]
        res = list(res.split(' '))[::-1]
        return  ' '.join(res)
    
        
if __name__ == "__main__""
	s = solution()
    s2 = s.trans("dqw dwq",7)
    print(s2)
    

```

















3、SQL

```mysql
查看所有数据库
	show databases;

创建数据库
	create database 数据库名 charset=utf8;

使用数据库
	use 数据库名;

查看当前使用的数据库
	select database();

删除数据库-慎重
	drop database 数据库名;

查看当前数据库中所有表
	show tables;

创建表
创建表

​	create table 表名(
字段名称 数据类型  可选的约束条件,
column1 datatype contrai,
...
);

	create table students(
 id int unsigned primary key auto_increment not null,
 name varchar(20) not null,
 age tinyint unsigned default 0,
 height decimal(5,2),
 gender enum('男','女','人妖','保密')
);



修改表-添加字段
	alter table 表名 add 列名 类型 约束;
例：
alter table students add birthday datetime;


修改表-修改字段类型
	alter table 表名 modify 列名 类型 约束;
例：
alter table students modify birthday date not null;
	说明:
modify: 只能修改字段类型或者约束，不能修改字段名



修改表-修改字段名和字段类型
	alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
	说明:
change: 既能对字段重命名又能修改字段类型还能修改约束


修改表-删除字段
	alter table 表名 drop 列名;
例：
alter table students drop birthday;


查看创表SQL语句
	show create table 表名;
例：
show create table students;


查看创库SQL语句
	show create database 数据库名;
例：
show create database mytest;


删除表
	drop table 表名;
例：
drop table students;


查询数据
	-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;


添加数据
	-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
	说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值


修改数据
	update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;

删除数据
	delete from 表名 where 条件
例：
delete from students where id=5;
	问题:
	上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
	-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
	说明:
	逻辑删除，本质就是修改操作



5. 小结
	登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件



使用 as 给字段起别名
select id as 序号, name as 名字, gender as 性别 from students;

distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
as 关键字可以给表中字段 或者 表名起别名
distinct 关键字可以去除重复数据行。



7. 小结
	常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null



4. 模糊查询
	like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
	例1：查询姓黄的学生:
select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:
select * from students where name like '黄_';
3：查询姓黄或叫靖的学生:
select * from students where name like '黄%' or name like '%靖';



1. 排序查询语法
	排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:
先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:
select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:
select * from students  order by age desc,height desc;




2. 分页查询的语法
	select * from 表名 limit start,count
说明:
limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:
select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;

3. 分页查询案例
	已知每页显示m条数据，求第n页显示的数据
提示: 关键是求每页的开始行索引
查询学生表，获取第n页数据的SQL语句:
select * from students limit (n-1)*m,m


6. 求平均值
	-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
	说明
	ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。

8. 小结
	count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值



分组查询
	学习目标
		能够写出分组查询的SQL语句
	1. 分组查询介绍
		分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
	2. group by的使用
		group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
	3. group by + group_concat()的使用
		group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
	4. group by + 聚合函数的使用
		- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
	5. group by + having的使用
		having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
	6. group by + with rollup的使用
		with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
	7. 小结
		group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果



内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;



左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;




右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;



自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:
小结
	自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
	自连接就是一种特殊的连接方式，连接的表还是本身这张表


2. 子查询的使用
	例1. 查询大于平均年龄的学生:
select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:
select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:
select * from students where (age, height) =  (select max(age), max(height) from students);














```





l

```mysql
演练-分组和聚合函数的组合使用
	学习目标
		能够写出分组和聚合函数组合使用的SQL语句
	1. 数据准备
		-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
		表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
	2. SQL语句演练
		查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;
```





```mysql
事务
	学习目标
		能够知道事务的四大特性
	1. 事务的介绍
		事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
	2. 事务的四大特性
		原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
	3. 事务的使用
		在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
		-- 查看MySQL数据库支持的表的存储引擎
show engines;
	查看goods表的创表语句:
		-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
	开启事务:

begin;
或者
start transaction;
	4. 小结
		事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
索引
	学习目标
		能够写出创建索引的SQL语句
	1. 索引的介绍
		索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
		应用场景:
		当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
	2. 索引的使用
		查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
	3. 案例-验证索引查询性能
		创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
	4. 联合索引
		联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
	5. 联合索引的最左原则
		在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
	6. MySQL中索引的优点和缺点和使用原则
		优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
	7. 小结
		索引是加快数据库的查询速度的一种手段
		创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
		删除索引使用: alter table 表名 drop index 索引名;
```



5、装饰器



```python
import time
 
#  装饰器run_time,@run_time加在谁头上，谁就是参数fun
def run_time(fun):
 
    start_time = time.time()
    fun()
    end_time = time.time()
 
    print("程序运行时间为：{} 秒".format(str(round((end_time - start_time), 1))))
    return end_time - start_time
 
#  耗时任务task
@run_time
def task():
    time.sleep(3)
    
    
```



快速排序

`

```python
def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟`


def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]
     return li

li = [1,46,89,1,3,6,9]
print(select_sort(li))




            
            
            
            
  #二分




def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分


```





## Linux

1、查找文件

 find  /目录 -name filename.txt



2、查看一个程序是否运行   				ps         -ef|grep     进程名字

​				grep 命令的基本格式			 grep [选项] 模式 文件名

3、终止线程							kill  -9  进程号



4、查看文件包含的隐藏文件    		ls  -al 



5、查看当前工作目录					  pwd



6、复制文件包含其子文件到自定义目录			cp 	 -r	sourceFolder   targetFolder



7、创建目录						mkdir	newfolder



8、删除目录					rmdir  【 】 documents    -v显示详细执行过程   -p 删除指定目录及子空目录



9、删除文件包括其子文件		rm 		-rf 		deletefile



10、移动文件 		mv  	/temp/movefile		/targetfolder 	+		mv  oldnamefile	newnamefile



11、切换用户 		su 	-username



12、修改文件权限		chmod	777   	file        -rwxrwxrwx



13、压缩文件		tar		-czf		test.tar.gz  	/test1/test2



14、列出压缩文件列表	tar 	-tzf	test.tar.gz



15、解压文件			tar 	-xvzf		test.tar.gz



16、查看文件头10行		head		-n		10		example.txt



17、查看文件尾10行		tail			-n		10	example.txt

  

18、查看日志文件 			tail			-f		example.log 	

 19 、启动vi编辑器			vi

20、查看系统当前时间		date		

21、 cd

22、ls

23、grep 		grep [选项] 模式 文件名	grep CLERK emp.data

如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下：grep -c CLERK emp.data

搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：grep ^78     emp.data

24、find

25、mkdir

26、cp -a file1 file2				cp file1 file2 file3 	dir

27.mv

28.rm -fr dir

29.ps  -a     ps  -ef

30. netstat -a      # 列出所有端口

    netstat -at     # 列出所有TCP端口

    netstat -au    # 列出所有UDP端口

    netstat -ax    # 列出所有unix端口

    netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口，且加上程序名



一、linux管理和目录命令
pwd 显示当前路径地址
cd 改变当前用户的目录
ls 查看当前文件夹下的文件
mkdir  新建文件夹目录
rmdir  删除文件夹目录
touch  新建文件
cat    查看文本内容
mv     移动
cp	复制
rm	删除
grep	字符串查找

二、线上查找
man 查看当前或者一个命令的使用方法
locate 根据一个关键字或者关键词定位
whatis 查看某个命令的含义
三、文件阅读命令
head	从头开始查看
tail 	从尾开始查看
more	分页查看
四、文件或目录的压缩和解压缩
tar 
gzip
bizip2
gunzip
bunzip
五权限管理
chmod	修改权限
useradd	用户添加
userdel 用户删除
su	切换用户
passwd	修改密码
chgrp	修改文件所在组
chown	用来修改文件的所有者
六、文件的定位和查找
which  定位
whereis	查找
七、磁盘操作
df 查看文件系统使用情况
du 查看文件磁盘占用情况
八、系统命令
reboot重启
shutdown 关机
halt	关机
ps	进程
toop	进程
date	日期
cal	日历
exit	退出
kill	结束进程
九网络
ipconfig 显示网络状态
ping	监测主机
netstat	知道整个linux系统的网络情况或显示网络状态

top 查看cpu、内存密集使用的动态数据
free 查看内存使用情况
du 查看目录或文件的大小
df 查看磁盘分区的大小
cd 切换目录
ls 显示目录中的内容
cat 查看文件中的数据
vi 进入打开、修改、保存文件
rm 删除目录或者文件
mkdir 创建目录
touch 如果一个文件不存在，则创建文件，如果一个文件存在，则修改最后的访问时间
cp拷贝目录或文件



# 网络



## 两种 HTTP 请求方法：GET 和 POST

- **GET** - 从指定的资源请求数据。
- **POST** - 向指定的资源提交要被处理的数据。

**Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：**

-  **1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。**
-  **2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。**
-  **3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。**
-  **4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。**
-  **5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。**
-  **6、Get 是 Form 的默认方法。**

**使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。**





浏览器网址请求过程

​     **当我们在浏览器地址上输入一个网址时，浏览器会进行(HTTP)HTTPS的的请求时，基本根据以下步骤。**
​    
​        **1.通过DNS解析域名获取服务器IP。**

**首先，浏览器会根据当前网址域名去DNS服务器上进行解析请求，然后DNS服务器会请求到当前域名所对应的服务器IP地址，并将此IP地址返回给浏览器，浏览器再通过该浏览器访问当前服务器。****

​        **2.通过三次握手与服务器建立连接。**

**此时，在应用层是HTTP(HTTPS)协议，当进行到传输层时，服务器会通过TCP协议进行三次握手，首先客户端发送一个连接数据包给服务器(SYN = 1)，接着服务器会响应一个数据包给客户端，代表允许建立连接，然后客户端再发送一个数据包给客户端代表此时连接建立成功，-->-->**

​        **3.如果为HTTPS请求，则需要通过SSL证书加密。**

**如果是HTTPS协议，服务器首先会发送一个SSL证书给浏览器，浏览器检查当前证书是否过期以及证书是否安全，如果安全，则产生一个随机密钥通过SSL证书的公钥进行加密，将密钥发送给服务器端，服务器端根据自己的私钥对发送过来的密钥进行解密，**

​        **4.进行传输内容。**

**得到随机密钥后，通过随机密钥对要传输的内容加密，然后发送给服务器端，**

​        **5.TCP连接是否为长连接？**

TCP连接在这个过程中，还是基于TCP协议进行报文的发送与接收。如果说浏览器的connection = Keep-alive，代表本次TCP连接是一个长连接，不会主动释放连接，当传输内容完毕后，需要主动释放连接，**

​        **6.通过四次挥手释放连接**

**此时需要客户端发送挥手报文(FIN = 1)，服务器接收到后会发送一个确认报文，如果有未发送完的数据，接着发送数据，如果数据发送完毕，此时服务器会再发送一个数据包(FIN = 1,ACK = 1)给浏览器，浏览器再发送一个确认数据包给服务器，四次握手结束，这就是一个完整的访问网页的过程。**



**进程(Process)：进程是计算机中的程序关于某数据集合的一次运行实例，是操作系统进行资源分配的最小单位**
**线程(Thread)：线程被包含在进程之中，是操作系统进行程序调度执行的最小单位**
**协程(Coroutine)：协程是用户态执行的轻量级编程模型，由单一线程内部发出控制信号进行调度**





迭代器与生成器的区别：
（1）生成器：
生成器本质上就是一个函数，它记住了上一次返回时在函数体中的位置。
对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。
而且记录了程序执行的上下文。
生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。

（2）迭代器

迭代器是一种支持next()操作的对象。它包含了一组元素，当执行next()操作时，返回其中一个元素。
当所有元素都被返回后，再执行next()报异常—[StopIteration](https://so.csdn.net/so/search?q=StopIteration&spm=1001.2101.3001.7020)
生成器一定是可迭代的，也一定是迭代器对象

（3）区别：
①生成器是生成元素的，迭代器是访问集合元素的一中方式
②迭代输出生成器的内容
③迭代器是一种支持next()操作的对象
④迭代器（iterator）：其中iterator对象表示的是一个数据流，可以把它看做一个有序序列，但我们不能提前知道序列的长度，只有通过nex()函数实现需要计算的下一个数据。可以看做生成器的一个子集。







 装饰器本质上是一个Python函数(其实就是闭包)，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。





```

# 为函数添加一个统计运行时长的功能
import time
 
def how_much_time(func):
    def inner():
        t_start = time.time()
        func()
        t_end = time.time()
        print("一共花费了{0}秒时间".format(t_end - t_start, ))
    return inner
    # 将增加的新功能代码以及被装饰函数运行代码func()一同打包返回，返回的是一个内部函数，这个被返回的函数就是装饰器
 
def sleep_5s():
    time.sleep(5)
    print("%d秒结束了" % (5,))
 
def sleep_6s():
    time.sleep(6)
    print("%d秒结束了" % (6,))
 
sleep_5s = how_much_time(sleep_5s)
# 因为sleep_5s函数的功能就是睡5秒钟，虽然增加了统计运行时间的功能，但是他本身功能没变(还是睡5秒钟)，所以仍然用原来函数名接收增加功能了的自己
sleep_6s = how_much_time(sleep_6s)
 
t1 = threading.Thread(target=sleep_5s)
t2 = threading.Thread(target=sleep_6s)
t1.start()
t2.start()
# 5秒结束了
# 一共花费了5.014161109924316秒时间
# 6秒结束了
# 一共花费了6.011810302734375秒时间

```





建立连接的方式又称为三次握手：

（1）第一次握手，主机A向主机B发出请求数据包：“我想给你发数据，可以吗？”这是第一次对话。

（2）第二次握手，主机B向主机A发送同意连接，并要求同步的数据包（同步就是两台主机协调工作，一台在发送，一台在接收）：“可以，你什么时候发？”这是第二次对话。

（3）第三次握手，主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接收吧！”这是第三次对话。

这三次对话的目的是使数据包的发送和接收同步，TCP协议是一定要经过这三次对话之后，主机A才可以向主机B正式发送数据。


TCP建立连接需要进行三次握手，但是断开连接却要进行四次挥手：

（1）第一次挥手，在主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求。

（2）第二次挥手，主机B收到FIN位置上的1信息后对其做出响应，确认这一方向上的TCP连 接将关闭，将ACK置1。

（3）第三次挥手，B主机再提出反方向的关闭请求，并将控制位FIN置1，发送给A主机，并关闭连接。

（4）第四次挥手，主机A对主机B的请求进行确认，将ACK置1，并关闭连接，至此双方关闭连接。





一、TCP和UDP是什么？
TCP：传输控制协议(Transmission Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信 协议。由IETF的RFC 793定义。

UDP：用户数据报协议(User Datagram Protocol)，是一种面向无连接，不可靠、以数据报文段的形式传输的传输层通信协议。由RFC 768描述了UDP。

二、TCP与UDP的区别是什么？
1、连接方面

TCP面向连接(如打电话先拨号建立连接)。

UDP无连接，即发送数据报之前不用建立连接。

2、安全方面

TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达。

UDP尽最大努力交付，即不保证可靠交付。

3、传输效率

TCP传输效率较低，UDP传输效率较高。

4、连接数量的区别

TCP连接只能是一对一、点对点的。

UDP支持一对一、一对多、多对一和多对多的交互通信。

5、首部

TCP报文首部20个字节，UDP首部8个字节。

6、可靠

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

7、面向方式

TCP面向字节流。实际上是TCP把数据看成一串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题。

UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

三、TCP的三次握手与四次挥手
1、TCP三次握手
三次握手是TCP用来确保连接可靠建立的方式：

第一次握手：A给B发短信说：“B，你现在有空吗？”
第二次握手：B此时收到了A的信息，然后对A说：“我有空，你呢？有空吗？”
第三次握手：A此时收到了A的信息，然后说：“我也有空，那我给你说个事。”
在三次握手之后，A和B都能确定这么一件事：双方的通信可以流畅的进行。这样，双方就可以开始进行正常的对 话了。

2、TCP四次挥手
四次挥手是TCP用来确保连接可靠关闭的方式：

第一次挥手：A给B发短信说，“B，我要准备吃饭了？”
第二次挥手：B此时收到了A的信息，然后先对A说：“我知道了。”
第三次挥手：B对A说：“我也要准备吃饭了。”然后放下了手机
第四次挥手：A此时收到了B的确认信息，然后向B发送一个包说：“好的，知道了。”这时才放下手机去吃饭
在四次挥手之后，A和B都能确定这么一件事：双方的通信都可以正常关闭，这样，双方就可以确定对方已经完全知道了自己要确认关闭连接。

![在这里插入图片描述](D:\hgx笔记\hgxbijiben\7、刷题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzg1Njkx,size_16,color_FFFFFF,t_70)







```python
Python 数组翻转指定个数的元素
	定义一个整型数组，并将指定个数的元素翻转到数组的尾部。

例如：(ar[], d, n) 将长度为 n 的 数组 arr 的前面 d 个元素翻转到数组尾部。

以下演示了将数组的前面两个元素放到数组后面。
	def leftRotate(arr, d, n):
    for i in range(d):
        leftRotatebyOne(arr, n)
def leftRotatebyOne(arr, n):
    temp = arr[0]
    for i in range(n-1):
        arr[i] = arr[i+1]
    arr[n-1] = temp
         
 
def printArray(arr,size):
    for i in range(size):
        print ("%d"% arr[i],end=" ")
 

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
		3 4 5 6 7 1 2
		类似冒泡排序的解法引入temp变量
	def leftRotate(arr, d, n):
    for i in range(gcd(d,n)):
         
        temp = arr[i]
        j = i
        while 1:
            k = j + d
            if k >= n:
                k = k - n
            if k == i:
                break
            arr[j] = arr[k]
            j = k
        arr[j] = temp

def printArray(arr, size):
    for i in range(size):
        print ("%d" % arr[i], end=" ")

def gcd(a, b):
    if b == 0:
        return a;
    else:
        return gcd(b, a%b)

arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2, 7)
printArray(arr, 7)
	def rverseArray(arr, start, end):
    while (start < end):
        temp = arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        start += 1
        end = end-1
 
def leftRotate(arr, d):
    n = len(arr)
    rverseArray(arr, 0, d-1)
    rverseArray(arr, d, n-1)
    rverseArray(arr, 0, n-1)
 
def printArray(arr):
    for i in range(0, len(arr)):
        print (arr[i], end=' ')
 
arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2)
printArray(arr)



Python 将列表中的指定位置的两个元素对调
	定义一个列表，并将列表中的指定位置的两个元素对调。

例如，对调第一个和第三个元素：

对调前 : List = [23, 65, 19, 90], pos1 = 1, pos2 = 3
对调后 : [19, 65, 23, 90]
	def swapPositions(list, pos1, pos2):
     
    list[pos1], list[pos2] = list[pos2], list[pos1]
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
     
    first_ele = list.pop(pos1)    
    second_ele = list.pop(pos2-1)
     
    list.insert(pos1, second_ele)  
    list.insert(pos2, first_ele)  
     
    return list
 
List = [23, 65, 19, 90]
pos1, pos2  = 1, 3
 
print(swapPositions(List, pos1-1, pos2-1))
	def swapPositions(list, pos1, pos2):
 
    get = list[pos1], list[pos2]
       
    list[pos2], list[pos1] = get
       
    return list
 
List = [23, 65, 19, 90]
 
pos1, pos2  = 1, 3
print(swapPositions(List, pos1-1, pos2-1))
	def reversal(list,n1,n2):
    temp = list[n1]
    list[n1] = list[n2]
    list[n2] = temp
    print(list)
list = [1,2,3,4,5,6,7]
reversal(list,4,5)



Python 翻转列表
	定义一个列表，并将它翻转。

例如：

翻转前 : list = [10, 11, 12, 13, 14, 15]
翻转后 : [15, 14, 13, 12, 11, 10]
	def Reverse(lst):
    return [ele for ele in reversed(lst)]
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    lst.reverse()
    return lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))
	def Reverse(lst):
    new_lst = lst[::-1]
    return new_lst
     
lst = [10, 11, 12, 13, 14, 15]
print(Reverse(lst))





Python 将字符串的时间转换为时间戳
	import time
 
a1 = "2019-5-10 23:40:00"
# 先转换为时间数组
timeArray = time.strptime(a1, "%Y-%m-%d %H:%M:%S")
 
# 转换为时间戳
timeStamp = int(time.mktime(timeArray))
print(timeStamp)
 
 
# 格式转换 - 转为 /
a2 = "2019/5/10 23:40:00"
# 先转换为时间数组,然后转换为其他格式
timeArray = time.strptime(a2, "%Y/%m/%d %H:%M:%S")
otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)
print(otherStyleTime)

```





# 测试用例八大要素

| 测试用例编号 | 测试项目(测试模块) | 预置(前提)条件 | 测试输入 | 预期输出 | 操作步骤 | 测试用例标题 | 级别 |

1. **用例的设计者**:能准确找到测试用例的设计人员,对用例修改时能方便找到人员
2. **用例设计日期**: 方便检查用例的设计进度
3. **对应的开发人员**: 出现bug后能及时找到相应的人员进行修复
4. **测试结果**: 执行用例最后执行的结果, 包括:pass、fail、block
5. **测试类型**: 功能、性能、压力等等

常用的测试用例设计方法有: **等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果图法、功能图法**.
	等价类划分
		等价类划分
		使用最少的测试数据,达到最好的测试质量.
		等价类划分法的测试思想是:
		从大量数据里划分范围（每个范围内的数据测试效果是等价的所以每个范围是一个等价类），然后从每个范围中挑选代表数据，这些代表数据能反应这个范围内数据的测试结果。
		官方定义:
		等价类测试方法是把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。使用等价类划分方法设计测试用例要经历划分等价类（列出等价类表）和选取测试用例两步，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。
		等价类的类型划分分为:有效等价类和无效等价类.
		(1). 有效等价类
		有效等价类是指对对于程序的规格说明来说是合理的、有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能.
		(2). 无效等价类
		无效等价类指对程序的规格说明是不合理的、无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。利用无效等价类可校验程序对于无效数据的处理能力,检测程序的健壮性、容错能力
		注意:
		设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。
		3. 案例
要求:使用等价类划分法测试QQ账号的合法符合规范

明确需求	输入6-10位的自然数	
有效等价类	有效等价类	自然数个数大于6小于10个
无效等价类	无效等价类	小于6个、大于10个、中文、空格、英文、特殊字符、小数
设计测试用例	有效等价类测试用例	无效等价类测试用例
		

	边界值分析法
		边界值分析法就是对输入或输出边界值进行测试的,也是一种黑盒测试.
		边界值分析法通常作为等价类划分法的补充,其测试用例来自等价类的边界;长期的经验得知,大量的错误是发现在输入或输出范围的边界上，而不是发生再输入输出范围的内部，因此针对各种边界情况设计测试用例，可以查出更多错误.
		和等价类划分法的区别:
		是等价类划分法的补充
		等价类划分法可以挑选等价范围内任意一个数据作为代表,边界值分析法要求每个边界值都要作为测试条件
		边界值分析法不仅考虑输入条件,同样考虑输出产生的测试情况
		常见的边界值:
		边界点(上点):输入范围的边界点
		离点: 离边界点最近的点
		内点: 输入范围内的任意一个点
		对于边界值的说明:
		边界值数据本质上属于等价类的范畴,测试时确实是一种冗余（重复），但是为了更好的测试质量（边界值特别容易出bug），边界值必须要单独测,适当必要的冗余是可以接受的.
		
		2.1 步骤:

明确需求
确定有效和无效等价类
明确输入条件中的边界值
编写测试用例
注意: 边界值法应用时，如果测试时间紧张，应该优先测试最大值和最小值
		

		3. 小结
			边界值分析法作为等价类划分法的补充,经常和等价类划分一起使用.
			使用的场景是:有输入并且存在边界值的位置.
	判定表法
		判定表法
		1. 使用场景
		适合于有多个输入和对个输出,输入和输出之间有相互的组合关系, 输入输出之间有相互的制约和依赖关系
		2. 定义
		判定表也称决策表, 是分析和表达多逻辑条件下执行不同操作的工具.
		它能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此,利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。
		3. 组成
		判定表是由条件桩、动作桩、条件项、动作项四部分组成,如下图.
		条件桩	条件项
		动作桩	动作项
		1） 条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。
		2） 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。
		3） 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。
		4） 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。
		4.规则及规则合并
		4.1 规则
		任何一个条件组合的特定取值及其相应要执行的操作称为规则。
		在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。
		4.2 化简
		规则合并有两条或多条规则具有相同动作,并且其条件项之间存在着极为相似的关系。
		5. 测试案例设计
		步骤:
		明确规则个数
		列出所有条件桩和动作桩
		填入条件项
		填入动作项,等到初始判定表
		简化,合并相似规则


​		
​		
​		
​		
​	因果图法
​		1. 概述
​		因果图法是一种利用图解法分析输入条件、输出结果的各种组合情况,从而设计测试用例的方法.
​		因果图法适用于有多个输入和多个输出，而且输入和输入之间有相互的组合关系，输入和输出之间有相互的制约和依赖关系.
​		使用场景和判定表法是一样的.
​		在界面中有多个控件，控件之间有组合或限制关系，不同的输入组合会对应不同的输出结果，如果想弄清楚不同的输入组合到底对应哪些输出结果，可以使用因果图/判定表法。(因果图/判定表法比较适合测试组合数量较少的情况，一般少于20种)
​		和判定表法的不同:
​		因果图，只是一个用图形表示，表示因果方式不同而已
​		关联:
​		判定表和因果图是等价的，判定表是因果图的简化版。
​		2.核心
​		2.1 因果图
​		原因(因): 输入条件
​		结果(果): 输出结果
​		因果图: 就是通过画图的方式来表示输入条件（因）和输出结果（果）之间的关系。
​		2.2 因果图中的图形符号
​		(1). 恒等(=)
​		恒等
​		含义: 原因出现结果出现,原型不出现,结果不出现. 例如:若c=10,则d=0.
​		(2). 非 (~)
​		非
​		含义: 若原因出现,则结果不出现;原因不出现则结果出现.例如: 搜索联系人,若有就不提示错误.
​		(3). 或 (v)
​		或
​		含义: 若几个原因中有一个出现,这结果出现;若都不出现,结果不出现.
​		(4). 与(^)
​		与
​		含义: 若几个原因都出现结果才出现,否则,结果不出现.
​		2.3 约束
​		输入状态相互之间还可能存在某些互相依赖的关系,称为约束. 输出状态之间也存在某些约束.在因果图中使用特定符号表示这些约.
​		束.
​		约束
​		(1). 输入条件约束
​		E(exclude) 约束: a和b中至多有一个为1.
​		I(include) 包含: a、b和c中至少有一个必须是1.
​		R(required) 要求: a是1时，b必须是1.
​		O(only) 唯一: a和b必须有一个，且仅有1个为1.
​		(2). 输出条件约束
​		M(mandatory) 强制: 若结果a是1,结果b强制为0.
​		3. 设计测试用例
​		步骤
​		了解需求,找出所有的输入条件(因)
​		找出所有的输出结果(果)
​		画因果图、填判定表
​		判定表中每个规则就是一条测试用例


​		
​		小结
​			5.小结
​			因果图法是通向判定表法的一个中间过程.我们经常会将因果图法和判定表分析法结合起来使用.
​			对于业务逻辑比较复杂的我们建议先使用因果图法进行分析,然后再转化为判定表法,最后写测试用例.这样思路比较清晰,
​			对于简单的可以直接使用判定表法直接分析,然后写测试用例.
​	正交验证法
​		1.1 定义
​		正交法,也叫正交实验法或者正交排列法, 就是使用最小的测试过程集合获得最大的测试覆盖率。
​		“正交实验”是研究多因素、多水平的一种实验方法,它利用正交表来对实验进行设计,通过少数实验代替全面的实验.
​		在一项实验中,把影响试验结果的量称为试验因素(因子)，简称因素。因素可以理解为试验过程中的自变量，试验结果可以看成因素的函数。在试验过程中，每一个因素可以处于不同的状态或状况，把因素所处的状态或状况，称为因素的水平，简称水平。
​		
​		2. 使用正交法设计测试用例
​		2.1 步骤
​		根据需求把空间即其取值列举出来
​		根据空间和空间的取值个数,选择一个合适的正交表
​		根据控件的个数,选择正交表的次幂,也就是正交表中包含的最大值, 例如,4个控件,选择4次幂
​		根据控件取值个数,选择正交表的底,也就是正交表包含的最大值, 例如, 每个控件有3个取值,底是3
​		把控件及其取值映射到正交表中
​		把控件名字分别映射到正交表的列名位置
​		把正交表中每一列的数字分别用对应的控件取值替代
​		根据正交表,编写测试用例


​		
​		小结
​			正交实验法，就是使用已经造好了的表格——正交表来安排实验并进行数据分析的一种方法
​			使用最小的测试过程集合获得最大的测试覆盖率。
​			3.1 使用场景
​			需求中条件的组合量比较大的时候
​			需求两个两个相互组合的时候
​			3.2 局限性
​			正交表的个数有限,一般要求每个控件的取值相等,但是这在实际中很难应用,所以在实际使用时要进行取舍
​			对于控件个数,如果没有,就选择一个接近的
​			对于控制的取值,应该少数服从多数, 有更多空间的取值一样
​	场景法
​		1. 概述
​		1.1 为什么使用场景法设计测试用例
​		大多数业务软件由后台管理（比如：用户管理、角色管理、权限管理等等各种管理）和工作流等几个部分组成。终端用户，期望软件能够实现业务需求，而不是简单的功能的组合。对于单点功能利用等价类、边界值、判定表用例设计方法能够解决大部分问题。涉及业务流程的软件系统，采用场景法比较合适。
​		总之, 对于多个功能组合测试的场景适合使用场景法, 所以场景测试,也是业务场景组合测试.
​		1.2 概念
​		场景流程图
​		场景业务流通常分为: 基本流、备选流、异常流程
​		(1) 基本流
​		基本流表示通过业务流程时输入都正确，能达到目标的流程
​		(2) 备选流
​		备选流表示通过业务流程时输入错误（或者操作错误）导致流程存在反复，但是经过纠正后仍能达到能达到目标的流程.（插卡-->输入错误密码--》输入正确密码--》输入金额--》取款--》取卡）
​		(3) 异常流
​		异常流表示通过业务流程时输入错误（或者操作错误）产生异常终止流程
​		2. 使用场景法设计测试用例
​		1. 步骤
​		分析需求,确定基本流程、备选流程、异常流程
​		绘制流程图,确定流程路径, 根据流程图生成不同的场景
​		每一个场景就是一条测试用例


​		
​		小结
​			场景流程比较适合于涉及到业务需求的场景, 能够多个功能联合进行测试,不是单个功能进行测试.
​			1. 步骤
​			分析需求,确定基本流程、备选流程、异常流程
​			绘制流程图,确定流程路径, 根据流程图生成不同的场景
​			每一个场景就是一条测试用例
​	功能图法
​		功能图法
​		一个程序的功能说明通常由动态说明和静态说明组成.
​		动态说明描述了输入数据的次序或转移的次序.静态说明描述了输入条件与输出条件之间的对应关系.
​		对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例.
​		功能图模型由状态迁移图和逻辑功能模型构成.
​		状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.
​		逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。
​		功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.
​		逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.
​		由于覆盖测试的目标不同,逻辑覆盖可分为:
​		语句覆盖
​		判定覆盖
​		判定-条件覆盖
​		条件组合覆盖
​		路径覆盖
​		1.2 组成
​		功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.
​		eg：
​		1.3 设计测试用例
​		(1). 生成测试用例的规则
​		从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.
​		为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.
​		在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.
​		(2). 步骤
​		生成局部测试用例: 在每个状态中,从因果图生成局部测试用例.局部测试用例由输入数据与对应的输出数据或状态构成。
​		测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。
​		测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。
​		小结
​			功能图设计方法：功能图方法使用功能图形象地表示程序的功能说明，并机械地生成功能图的测试用例。
​	错误推测法
​		2.1 定义
​		错误推测法是: 基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。
​		2.2 基本思想
​		根据经验,列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。
​		2.3 使用场景
​		适用于项目时间比较短促,任务比较繁重的情况下



![image-20230129092045067](C:/Users/571290717/Desktop/%25E9%259D%25A2%25E8%25AF%2595%25E9%259D%25A2%25E7%25BB%258F.assets/image-20230129092045067-16749552470691.png)



# 计算机网络



一、网络 7 层架构(ISO/OSI协议参考模型)
	物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
	数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
	网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
	传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。
	会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
	表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
	应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。
	
	
	

二、TCP/IP 原理
	TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。
	

	1、应用层(Application Layer)
	    应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。
	2、传输层(Tramsport Layer-TCP/UDP)
	    传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
	3、网络层(Internet Layer)
	  网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP，Internet Protocol)。
	4、网络访问层(Network Access Layer)
	   网络访问层(Network Access Layer)在 TCP/IP ：是TCP/IP协议栈的最底层，它提供物理网络的接口，实现对复杂数据的发送和接收。网络访问层协议为网络接口、数据传输提供了对应的技术规范。网络访问层对应 OSI 七层网络模型的物理层和数据链路层。
	5、四层协议和对应的标准七层协议的关系如下图
	————————————————

三、TCP 三次握手/四次挥手
	1、三次握手
	SYN：同步序列编号（Synchronize Sequence Numbers）、seq：序号--sequence number、
ACK (Acknowledge character）即是确认字符  、ack number 确认序号
	第一次握手： 主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器主机 B，由 SYN=1 知道，A 要求建立联机；
	第二次握手： 主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包
	第三次握手： 主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认。
	

	2、四次挥手
	TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。
	关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u
	服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
	关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。
	客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
	————————————————
	主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到close 状态。
	为什么会有TIME_WAIT状态：
		确保有足够的时间让对方收到ACK包
		避免新旧连接混淆
	3、TCP/IP状态
		1、LISTENING（listening)
		FTP服务启动后首先处于侦听（LISTENING）状态。
		2、ESTABLISHED（established）
		建立连接。表示两台机器正在通信。
		3、CLOSE_WAIT
		对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT，此时我方要调用close()来使得连接正确关闭。
		4、TIME_WAIT
		我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。
		5、SYN_SENT
		SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED。

四、TCP 长连接与短连接
	1、长连接和短连接使用原因
	当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次挥手，所以说每个连接的建立都是需要资源消耗和时间消耗的。
	2、HTTP的长连接和短连接
	HTTP的长连接和短连接本质上是TCP长连接和短连接。
	在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
	而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
	Connection:keep-alive
	1
	在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
	3、TCP—长连接
	 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。
	连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；
	这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；
	 TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
	4、TCP—短连接
	 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；
	 连接→数据传输→关闭连接；
	5、应用场景
	 长连接： 多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。
	例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
	 短连接： 像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

五、HTTP原理
	 HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。
	1、地址解析
	如用客户端浏览器请求这个页面：http://www.lydms.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
	协议名： http
	主机名： www.lydms.com
	端口： 8080
	对象路径： /index.htm
	在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。
	2、封装 HTTP 请求数据包
	把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包
	3、封装成 TCP 包并建立连接
	封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）
	4、客户机发送请求命
	客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。
	5、服务器响应
	服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。
	6、服务器关闭 TCP 连接
	一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

六、HTTPS
	六、HTTPS
	HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：
	1、SSL/TLS之间的关系
	SSL 是英文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。
	为啥要发明 SSL 这个协议呢？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。
	到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
	很多人都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。
	2、建立连接获取证书
	SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
	3、证书验证
	Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
	4、数据加密和传输
	如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。
	

七、CDN 原理
	CND 一般包含分发服务系统、负载均衡系统和管理系统。
	1、分发服务系统
	其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。
	2、负载均衡系统
	负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。
	3、管理系统
	分为运营管理和网络管理子系统。网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。
	包括用户管理、产品管理、计费管理、统计分析等。

八、TCP/IP协议族
	TCP/IP只提供无连接、不可靠的服务。
	传输之前需要进行三次握手。
	IP的主要功能包括将上层数据(如TCP、UDP数据)或者同层的其它数据(如ICMP数据)封装到IP数据报中，将IP数据报传送到最终目的地；为了使数据能够在链路层上进行传输，对数据进行分段，确定数据报到达其它网络中的目的地的路径。
	1、应用层协议—文件传输服务(FTP)
	用来在计算机之间传输文件。
	实际Internet的FTP服务是一种匿名(anonymous)FTP服务，设置一个特殊的用户名-anonymous，供公众使用。
	匿名登录到FTP服务器后，其工作方式与常规FTP相同。通常处于安全目的，大多数匿名FTP服务器只允许下载，不允许上传文件。
	FTP在客户端到服务器建立2条TCP连接，一条是控制连接，主要用于传输命令和参数(端口21)；另一条是数据连接，主要用于传输文件(端口号20)。
	2、应用层协议—远程登录协议(Telnet)
	远程登录服务实在Telnet协议的支持下，将用户计算机和远程主机连接起来，在远程计算机上运行程序，用户输入的信息通过Telnet协议发送给远程主机，主机在TCP端口监听用户请求，并处理后，将结果通过Telnet协议返回给客户。客户再经过适当的转换显示在计算机屏幕上。因为使用Telnet命令进行远程登录，所有称为Telnet远程登录。
	由客户端软件、服务器软件以及Telnet通用协议三部分组成。
	3、应用层协议—电子邮件协议（SMTP)
	电子邮件(E-mail)利用计算机进行信息交换的电子媒体信件。
	基于客户端/服务器模式，有E-mail客户端软件、E-mail服务器、通信协议三部分组成。发送邮件，首先到达自己注册的邮件服务器主机，再在网络传输中经过多个计算机和路由中转到达目的地的邮件服务器主机，进入收件人的电子邮箱，最后邮件的接收者上网并启动电子邮件管理程序，会自动下载到自己计算机，完成接受邮件。
	SMTP：简单邮件传输协议
	MIME：Internet邮件扩充协议
	PEM：增强私密邮件保护协议
	POP：来保管用户未能及时取走的邮件，简单的纯文本协议，每次传输以正规E-mail为单位，不提供部分传输。
	4、传输层协议—TCP
	在IP提供的不可靠数据服务的基础上为应用程序提供一个可靠的、面向连接的、全双工的数据传输服务。TCP在源主机和目的之间建立和关闭连接操作是，均需要通过三次握手来确认建立和关闭是否成功。TCP虽然提供了一个可靠的数据传输服务，但是以牺牲通信量来实现的。
	TCP采用了重发技术： 发送数据时，启动定时器，在规定时间内没有收到确认信息，就重新发送数据包。
	5、传输层协议—UDP
	用户数据报协议是一种不可靠、无连接的协议，与同层面向连接的TCP相比，UDP是一种无连接的协议(无错误检测功能)。TCP有助于提供可靠的连接，UDP有助于提高传输的高速率性。不负责重新发送丢失的包，不对接收的数据进行排序，不消除重复的IP数据报，不负责建立和终止连接。(都是UDP应用程序负责的)
	TCP：交互式会话应用程序(FTP等)。
	UDP：自己进行错误检测、不需要检测错误(DNS、SNMP)。
	6、网际层协议—IP
	IP只提供无连接、不可靠的服务，把差错检测和流量控制之类的服务授权给了其他层的协议。
	IP的主要功能：
	将上层数据(TCP、UDP数据)或同层其他数据(ICMP数据)封装到IP数据报中；
	将IP数据报传送到最终目的地；
	为了使数据能够在链路层上进行传输，对数据进行分段；
	确定数据报到达其它网络中的目的地的路径。
	7、网际层协议—ICMP
	Internet控制信息协议，用于发送查错报文的协议。ICMP让IP更加稳固。也是利用IP来传送报文的。ping工具就是利用ICMP报文进行目标是否可达测试。
	5种差错报文：(源抑制、超时、目的不可达、重定向和要求分段)
	4种信息报文：回应请求、回应应答、地址屏蔽码请求和地址屏蔽码应答。
	8、网际层协议—ARP和RARP
	地址解析协议(ARP)和反地址解析协议(RARP)
	ARP的作用是将IP地址转为物理地址，RARP的作用是将物理地址转为IP地址。每台设备都有唯一的物理地址(通过网卡给出)，为了屏蔽底层协议及物理地址上的差异，IP协议又使用了IP地址。因此，在传输过程中，必须对IP地址和物理地址进行相互转换。
	9、网络接口层协议—以太网(Ethernet IEEE 802.3
	Ethernet IEEE 802.3：标准局域网，速度10Mps，传输介质为铜缆。
	Ethernet IEEE 802.3u：快速以太网，速度100Mps，传输介质为双绞线。
	Ethernet IEEE 802.3z：千兆以太网，速度1000Mps，传输介质为光纤或双绞线。
	10、网络接口层协议—令牌环网(Ethernet IEEE 802.5)
	1、只有拥有令牌才可以发送数据。
	2、发送数据时，需要捕获一个令牌。
	3、令牌不为空，需要等待。
	11、网络接口层协议—光纤分布式数据接口(FDDI)
	以光纤为传输介质。
	采用双环体系结构，两环上的信息反方向流动。双环中一环称为主环，另一个环称为次环。正常情况下，主环传输数据，次环处于空闲状态。
	双环设计的目的是提供高可靠性和稳定性。FDDI定义的传输介质有单模光纤和多模光纤两种。
	12、网络接口层协议—点对点协议(PPP)
	主要用于”拨号上网“这种广域连接模式。优点简单、具备用户验证功能、可以解决IP分配等。为各种主机、网桥和路由器之间简单连接的一种通用解决方案。
	利用以太网(Ethernet)资源在以太网上运行PPP来进行用户认证接入的方式成为PPPoE。是目前ADSL接入方式中最广泛的技术标准。
	ATM网络撒花姑娘运行PPP来管理用户再认证的方式成为PPPoA。
	PPPoA和PPPoE运行原理相同，不同的是运行环境的不同。
	13、其他—ADSL(非对称用户数据线)
	ADSL Modem上网拨号方式有3中，即专线方式(静态IP)、PPPoA和PPPoE。
	ADSL独享带宽，安全可靠。费用低廉,使用过去的电话线路，可以分离电话机和ADSL Modem(上网)。
	14、其他—IPv4和IPv6
	IPv4：32位二进制，能表示IP地址个数：2^32=40亿
	IPv6:128位二级制，能表示IP地址个数：2128=3.4*1038。

1、TCP和UDP的区别
	TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输；
	TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报；
	TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

2. TCP和UDP分别对应的常见应用层协议？
   2.1 TCP对应的应用层协议
    FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
    Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
    SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
    POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
    HTTP：从Web服务器传输超文本到本地浏览器的传送协议。
   2.2 UDP对应的应用层协议
    DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
    SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
    TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

   各协议对应的端口号

   摘自计算机网络(面试必备知识点)

3. TCP协议如何来保证传输的可靠性
   TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
   对于可靠性，TCP通过以下方式进行保证：
   数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据超时后会重发数据；
   对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
   丢弃重复数据：对于重复数据，能够丢弃重复数据；
   应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
   超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
   流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

4. 解释一下IP的定义，在哪个层上？主要作用是？TCP与UDP呢？
   IP是 Internet protocol 的缩写，是网络层的主要协议，作用是提供不可靠、无连接的数据包传输协传送。
    TCP是 Transmit Control Protocol（传输控制协议），在传输层，TCP提供一种面向连接的、可靠地字节流服务。
    UDP是 User Datagram Protocol（用户数据报协议），在传输层，UDP提供不可靠的传输控制数据服务。

5. IP地址的分类
   IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。
   　　
     每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：
    A类地址：以0开头，第一个字节范围：0~127；
    B类地址：以10开头，第一个字节范围：128~191；
    C类地址：以110开头，第一个字节范围：192~223；
    D类地址：以1110开头，第一个字节范围为224~239；
    E类地址：以1111开头，保留地址

6. 分别写出OSI、TCP/IP及五层协议的体系结构
   从上至下
   OSI：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
   TCP/IP：应用层、运输层、网际层、网络接口层；
   五层协议：应用层、运输层、网络层、数据链路层、物理层；

   6.1 OSI每一层对应的协议
   	体系	协议
   	物理层	RJ45、CLOCK、IEEE802.3 （中继器，集线器）
   	数据链路	PPP、FR、HDLC、VLAN、MAC（网桥，交换机）
   	网络层	IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、（路由器）
   	传输层	TCP、UDP、SPX
   	会话层	NFS、SQL、NETBIOS、RPC
   	表示层	JPEG、MPEG、ASII
   	应用层	FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
   	
   6.2 OSI每一层的作用
   	体系	作用
   	物理层	通过媒介传输比特,确定机械及电气规范（比特Bit）
   	数据链路层	将比特组装成帧和点到点的传递（帧Frame）
   	网络层	负责数据包从源到宿的传递和网际互连（包PackeT）
   	传输层	提供端到端的可靠报文传递和错误恢复（段Segment）
   	会话层	建立、管理和终止会话（会话协议数据单元SPDU）
   	表示层	对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
   	应用层	允许访问OSI环境的手段（应用协议数据单元APDU）
   	拓展：
   	网关的定义：一个链接两种不同协议簇的进程，为某一个特定的应用提供服务。
   	在TCP/IP协议簇中，IP层使用不可靠的服务，TCP提供可靠的服务，为了提供可靠到的服务，TCP采用了超时重传，发送和接收端到端的确认分组机制。
   	网桥是在数据链路层对网络进行互联的，路由器是在网络层对网络进行互联的。

7. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。典型的算法：DES
     由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。典型的算法：RSA

8. Get与POST的区别
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
   GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
   GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

9. ipconfig和netstat的作用？
   ipconfig显示当前TCP/IP配置的信息，帮助用户查看网络状况，可以看到很多网络信息，比如延迟，IP，主机信息，物理地址信息等。
   netstat主要用于提供系统的接口命令。可以使用相关参数打印出每一个接口的MTU、输入分组数、输入错误、冲突以及当前的输出队列长度。

10. 两台笔记本连起来后ping不同，可能是哪些原因？
    网线问题。确认网线连接是否正确，电脑之间连的线和电脑与USB之间连的线分正线、反线，是不同的。但是对于使用千兆网卡的除外，千兆位网卡有自动识别功课，既可以是正线也可以是反线。
    局域网设置问题。电脑互连是要设置的，看看是否安装了必要的网络协议，最重要的是，IP地址是否设置正确，互联的时候最好一台电脑为正，一台电脑为副，为主的设为网关。
    网卡驱动未正确安装
    防火墙设置有问题
    是否有什么软件阻止ping包

11. 运行net share返回结果是什么?
    显示本地计算机上所有共享资源相关信息。如果加上参数 ShareName ，则仅显示有关该共享的信息。

12. net use和net user 分别指什么？
     net use是对用户进行管理，如添加、删除网络使用用户等。
     net user 是对网络设备进行管理

13. 交换和路由的区别是什么，VLAN有什么特点？
    交换机是指转发和过滤帧，是交换机的工作，它在OSI参考模型的第二层。
    而路由器是指网络线路当中非直连的链路，它是路由器的工作，在OSI参考模型的第三层。
    交换和路由的区别很大。首先，交换是不需要IP的，而路由需要，因为IP就是第三层的协议，第二层需要的是MAC地址；再有，第二层可以做NAT、ACL、QOS等。
    VLAN是虚拟局域网络的英文缩写，它是一个纯二层的技术，它的特点有三个：控制广播，安全，灵活性和可扩展性。

14. 简单描述DNS域名系统的工作原理
    当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括3条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53.该应用一般不直接为用户使用，而是为其他应用服务，如HTTP,SMTP等，在其中需要完成主机名到IP地址的转换。

    原文链接：https://blog.csdn.net/weixin_41948075/article/details/88625382

15. 提供可靠数据流传输控制的是OSI的第几层？
    会话层

16. 在浏览器中输入www.baidu.com后执行的全部过程
    1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过该IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，通过TCP进行封装数据包，输入到网络层。
    2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口，然后使用IP层的IP地址查找目的端。
    3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过过哪个路径到达服务器。
    4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

17. ARP是地址解析协议，简单解释一下工作原理？
    首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
    当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
    当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
    源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。



操作系统定义
	操作系统直接运行在计算机上的系统软件， 它是控制硬件和支持软件运行的计算机程序。
	. 操作系统的作用
	向下控制硬件向上支持软件的运行，具有承上启下的作用

Linux基础
	Linux基础知识
		熟练使用Linux常用命令，熟练部署基于Linux系统的测试环境。
		Linux内核是操作系统内部操作和控制硬件设备的核心程序，它是由芬兰人林纳斯开发的。
		真正操作和控制硬件是由内核来完成的，操作系统是基于内核开发出来的。
		是Linux内核与各种常用软件的组合产品，通俗来说就是我们常说的Linux操作系统。
		常用的Linux发行版:
		Ubuntu
		CentOS
		Redhat
		3. 小结
		Linux内核是Linux操作系统管理硬件设备的核心程序
		常用的Linux操作系统都是基于Linux内核开发出来的
	目录命令
		1. 查看目录命令的使用
		命令	       说明
		ls	查看当前目录信息
		tree	以树状方式显示目录信息
		pwd	查看当前目录路径
		clear	清除终端内容
		cd 目录	切换到指定目录
		cd ~	切换到当前用户的主目录
			注意:
			cd命令切换目录时，这个目录必须存在。
			cd 后面不写目录等价于cd ~
		cd ..	切换到上一级目录
		cd .	切换到当前目录
		cd -	切换到上一次目录
		子主题 12
	绝对路径和相对路径
		绝对路径
			从根目录算起的路径叫做绝对路径
		相对路径
			从当前目录算起的路径叫做相对路径
		绝对路径和相对路径的使用
			使用绝对路径切换到桌面
			cd /home/python/Desktop
			在下载目录以相对路径切换到桌面
			cd Downloads
			cd ../Desktop
			在桌面使用相对路径切换到上一级目录的上一级目录 cd Desktop cd ../../
		自动补全
			当敲出 文件或者目录或者命令 的前几个字母之后，按下 tab 键，如果输入的没有歧义，系统会自动补全
			当切换目录或者使用命令的时候，如果不确定当前目录下有那些子目录或者其它命令，可以通过两次tab键查看
	文件及目录命令
		touch 文件名	创建指定文件
		mkdir 目录名	创建目录(文件夹)
			1. mkdir命令选项
			命令选项	说明
			-p	创建所依赖的文件夹
		rm 文件名或者目录名	删除指定文件或者目录
			rm命令想要删除目录需要加上-r选项，-r表示递归删除目录及其内容
			2. rm命令选项
			命令选项	说明
			-i	交互式提示
			-r	递归删除目录及其内容
			-f	强制删除，忽略不存在的文件，无需提示
			-d	删除空目录
		rmdir 目录名	删除空目录
		cp	拷贝文件、拷贝目录
			拷贝目录需要加上-r选项，-r表示递归拷贝目录及其内容
			1. cp命令选项
			命令选项	说明
			-i	交互式提示
			-r	递归拷贝目录及其内容
			-v	显示拷贝后的路径描述
			-a	保留文件的原有权限
		mv	移动文件、移动目录、重命名
			2. mv命令选项
			命令选项	说明
			-i	交互式提示
			-v	显示移动后的路径描述
		小结
			创建嵌套文件夹使用 “mkdir –p” 嵌套目录
			删除空目录使用 “rmdir 目录名” 或者 “rm –d 目录名”
			删除非空目录使用 “rm –r 目录名”
			拷贝文件防止覆盖使用 “cp –i” 操作
			拷贝文件夹使用 “cp –r” 操作，拷贝文件夹并且文件权限不丢失使用 “cp –a” 操作。
			移动文件防止覆盖使用 “mv –i” 操作
			移动文件夹直接使用 “mv” 即可，“mv” 还可以给文件和文件夹重命名。
	终端命令格式的组成
		1. 终端命令格式说明
		command [-options] [parameter]
		每项信息的说明:
		command：命令名, 比如: ls、pwd
		[-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。
		[parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。
		[]：代表可选
		2. 小结
		终端命令完整格式: 命令名 选项(可选) 参数(可选)
		选项：用于调整命令的功能，比如：-r选项调整cp命令的功能。
		选项可以分为短选项和长选项
		短选项的格式: '-'后面接单个字母, 比如:-r
		长选项的格式: '--'后面接单词, 比如:--help
		参数：命令的操作对象，一般是文件名或者目录名。
		对于命令，它的选项和参数一般情况下没有顺序要求，但是scp命令是必须先选项然后在跟上参数。
	查看命令帮助
		--help 使用说明: 命令 --help
		man 使用说明: man 命令
			man命令的说明:
			操作键	说明
			空格	显示下一屏信息
			回车	显示下一行信息
			b	显示上一屏信息
			f	显示下一屏信息
			q	退出
	ls命令选项-查看目录中隐藏文件的命令选项
		1. ls命令选项使用
		命令选项	说明
		-l	以列表方式显示
		-h	件大小单位显示，默认是字节
		-a	显示隐藏文件和隐藏目录
		每项信息说明:
		

# Linux高级

​	重定向命令
​		2. 重定向命令的使用
​		命令	说明
​		>	如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式
​		>>	如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式
​		小结
​			终端内容保存到文件使用重定向有两种方式: > 和 >>
​			> 表示每次只写入最新的数据，原有数据不保留。
​			>> 表示每次在原有数据的基础上进行追加，原有数据会保留。
​	查看文件内容命令
​		1. 查看文件内容命令的使用
​		命令	说明
​		cat	查看小型文件
​			说明:
​			cat命令结合重定向可以完成多个文件的合并
​			gedit 文件编辑命令，可以查看和编辑文件
​		more	分屏查看大型文件
​			操作键说明:
​			操作键	说明
​			空格	显示下一屏信息
​			回车	显示下一行信息
​			b	显示上一屏信息
​			f	显示下一屏信息
​			q	退出
​		2. 管道(|)命令的使用
​			管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。
​		小结
​			查看小文件使用 cat 命令
​			分屏查看大型文件使用 more 命令，
​			查看终端显示内容并分屏展示，使用 管道(|) 结合 more 命令。
​	链接命令
​		ln -s	创建软链接
​		ln	创建硬链接
​		软链接
​			类似于Windows下的快捷方式，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接。
​			注意点:
​			如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。
​			删除源文件则软链接失效
​			可以给目录创建软链接
​			3. 软链接小结
​			软链接的作用是方便文件的快速访问，比如:给一个复杂路径下的文件创建一个软链接，以后就可以通过软链接完成快速访问操作。
​			创建软链接命令格式: ln -s 源文件路径(使用绝对路径) 软链接
​			4. 硬链接
​		硬链接
​			### 4. 硬链接
​			类似于**源文件的一个别名**，也就是说这两个名字指向的是同一个文件数据。
​			**注意点:**
​			- **创建硬链接使用相对路径和绝对路径都可以**
​			- **删除源文件，硬链接还可以访问到数据。**
​			- **创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。**
​			- **创建软链接，硬链接数不会加1**
​			- **不能给目录创建硬链接**
​			**硬链接数:**
​			**硬链接数就是文件数据被文件名使用的次数, 好比引用计数**
​			### 5. 硬链接小结
​			- 硬链接的作用是可以给重要文件创建硬链接，能够防止文件数据被误删。
​			- 删除源文件，软链接失效，但是硬链接依然可以使用。
​			- 创建硬链接命令格式: ln 源文件路径 硬链接
​	文本搜索命令
​		grep	文本搜索
​			2. grep命令选项的使用
​			命令选项	说明
​			-i	忽略大小写
​			-n	显示匹配行号
​			-v	显示不包含匹配文本的所有行
​			3. grep命令结合正则表达式的使用
​			正则表达式	说明
​			^	以指定字符串开头
​			$	以指定字符串结尾
​			.	匹配一个非换行符的字符
​			 扩展
​			grep 命令还可以文本搜索管道中的内容，比如: ls / | grep ‘lib’
​			在使用 grep 命令的时候还可以省略搜索内容的引号，比如: ls / | grep lib， grep hello 1.txt
​		小结
​			grep 命令是完成文本搜索操作的
​			文本搜索的命令格式: grep 选项 文本搜索内容
​	查找文件命令
​		命令	说明
​		find	在指定目录下查找文件(包括目录)
​		find命令选项:
​		选项	说明
​		-name	根据文件名(包括目录名)字查找
​		2. find命令结合通配符的使用
​		通配符:
​		是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件
​		通配符	说明
​		*	代表0个或多个任意字符
​		?	代表任意一个字符
​		3. 小结
​			find命令是完成查找文件操作的
​			查找文件的命令格式: find 指定查找目录 -name "文件名"
​	压缩和解压缩命令
​		1. 压缩格式的介绍
​		Linux默认支持的压缩格式:
​		.gz
​		.bz2
​		.zip
​		说明:
​		.gz和.bz2的压缩包需要使用tar命令来压缩和解压缩
​		.zip的压缩包需要使用zip命令来压缩，使用unzip命令来解压缩
​		压缩目的:
​		节省磁盘空间
​		2. tar命令及选项的使用
​		命令	说明
​		tar	压缩和解压缩命令
​		tar命令选项:
​		选项	说明
​		-c	创建打包文件
​		-v	显示打包或者解包的详细信息
​		-f	指定文件名称, 必须放到所有选项后面
​		-z	压缩或解压缩(.gz)
​		-j	压缩或解压缩(.bz2)
​		-x	解包
​		-C	解压缩到指定目录
​		3. zip和unzip命令及选项的使用
​		命令	说明
​		zip	压缩成.zip格式文件
​		unzip	解压缩.zip格式文件
​		unzip命令选项:
​		选项	说明
​		-d	解压缩到指定目录
​		说明:
​		压缩文件尽量使用.gz格式，因为占用空间较少
​		使用zip命令压缩的文件占用空间比较多, 当时比较通用，操作更加简单。
​		4. 小结
​		.gz和.bz2的压缩文件使用tar命令来完成压缩和解压缩
​		.zip的压缩文件使用zip和unzip命令来完成压缩和解压缩
​	文件权限命令
​		1. chmod命令的介绍
​		命令	说明
​		chmod	修改文件权限
​		chmod修改文件权限有两种方式:
​		字母法
​		数字法
​		2. chmod 字母法的使用
​		角色说明:
​		角色	说明
​		u	user, 表示该文件的所有者
​		g	group, 表示用户组
​		o	other, 表示其他用户
​		a	all, 表示所有用户
​		权限设置说明:
​		操作符	说明
​		+	增加权限
​		-	撤销权限
​		=	设置权限
​		权限说明:
​		权限	说明
​		r	可读
​		w	可写
​		x	可执行
​		-	无任何权限
​		3. chmod 数字法的使用
​		数字法就是“rwx” 这些权限也可以用数字来代替
​		权限说明:
​		权限	说明
​		r	可读，权限值是4
​		w	可写，权限值是2
​		x	可执行，权限值是1
​		-	无任何权限，权限值是0
​		4. 小结
​		利用 chmod 命令可以控制文件的操作权限。
​		字母法格式: chmod 不同角色设置的权限 文件
​		数字法格式: chmod 不同角色的权限值 文件名
​	获取管理员权限的相关命令
​		1. sudo命令的使用
​		命令	说明
​		sudo -s	切换到root用户，获取管理员权限
​		sudo	某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo
​		说明:
​		如果只是某次操作需要使用管理员权限建议使用 sudo , 也就是说临时使用管理器权限。
​		如果大量操作都需要使用管理员权限 sudo –s, 但是操作需谨慎。
​		2. whoami命令的使用
​		命令	说明
​		whoami	查看当前用户限
​		3. exit命令的使用
​		命令	说明
​		exit	退出登录用户
​		说明:
​		如果是切换后的登陆用户，退出则返回上一个登陆账号。
​		如果是终端界面，退出当前终端。
​		4. who命令的使用
​		命令	说明
​		who	查看所有的登录用户
​		5. passwd命令的使用
​		命令	说明
​		passwd	修改用户密码，不指定用户默认修改当前登录用户密码
​		6. which命令的使用
​		命令	说明
​		which	查看命令位置
​		7. 关机和重启命令的使用
​		命令	说明
​		shutdown –h now	立刻关机
​		reboot	重启
​		8. 小结
​		sudo 是临时获取管理员权限
​		sudo -s 是切换到管理员用户，一直使用管理员权限，需要谨慎操作。
​		exit 是退出当前用户
​		passwd 默认修改当前用户密码
​	用户相关操作
​		1. 创建用户
​		命令	说明
​		useradd	创建(添加)用户
​		useradd命令选项:
​		选项	说明
​		-m	自动创建用户主目录,主目录的名字就是用户名
​		-g	指定用户所属的用户组，默认不指定会自动创建一个同名的用户组
​		说明:
​		useradd 命令的使用需要使用管理员权限，前面需要加上 sudo
​		创建用户如果不指定用户组，默认会自动创建一个同名的用户组
​		查看用户是否创建成功，可以查看/etc/passwd这个文件
​		查看用户组是否创建成功，可以查看/etc/group这个文件
​		passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例:
​		第一个：用户名
​		第二个：密码占位符
​		第三个：uid, 用户id
​		第四个：gid, 用户所在组id
​		第五个：用户描述, 可选，
​		第六个：用户的主目录所在位置
​		第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型
​		group文件中的每项信息说明, 以laowang:x:1001:为例:
​		第一个：用户组名
​		第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的
​		第三个：组id
​		id命令查看用户信息:
​		命令	说明
​		id	查看用户信息
​		id命令效果图: id命令
​		每项信息说明:
​		uid=1001(laowang) gid=1001(laowang) 组=1001(laowang)
​		第一个: uid 表示用户id
​		第二个: gid 表示用户组id
​		第三个: 组 表示用户所在的用户组
​		2. 设置密码
​		给其它用户设置密码，需要使用: sudo passwd 用户名
​		设置密码效果图: useradd命令
​		3. 切换用户
​		命令	说明
​		su	切换用户
​		语法格式: su - 用户名
​		切换用户效果图:
​		su命令
​		在laowang用户使用sudo -s效果图:
​		sudo -s命令
​		解决办法:
​		给laowang用户设置一个sudo附加组， 需要使用usermod修改用户信息
​		4. 修改用户信息
​		命令	说明
​		usermod	修改用户信息
​		usermod选项:
​		命令	说明
​		-G	设置一个附加组
​		-g	修改用户组
​		usermod命令效果图:
​		usermod命令
​		设置附加组sudo以后，在sudo -s切换到管理员用户效果图:
​		usermod命令
​		5. 扩展: 删除附加组
​		命令	说明
​		gpasswd	添加和删除附加组信息
​		gpasswd命令选项:
​		选项	说明
​		-a 用户名	给用户添加附加组
​		-d 用户名	给用户删除附加组
​		删除附加组效果图:
​		usermod命令
​		删除附加组再次使用 sudo -s 效果图:
​		usermod命令
​		5. 删除用户
​		命令	说明
​		userdel	删除用户
​		userdel命令选项:
​		选项	说明
​		-r 用户名	删除用户主目录，必须要设置，否则用户主目录不会删除
​		删除用户效果图:
​		userdel命令
​		id查看用户信息效果图:
​		userdel命令
​		查看group文件信息效果图:
​		userdel命令
​		说明:
​		删除用户，默认同名的用户组也会被删除
​		6. 小结
​		创建用户命令格式: sudo useradd -m 用户名, 默认会创建一个同名的用户组。
​		查看用户信息使用 id 命令或者 /etc/passwd文件
​		查看用户组信息使用 /etc/group文件
​		给用户设置密码使用 sudo passwd 用户名
​		切换用户使用 su - 用户名
​		设置附加组使用 sudo usermod -G 组名 用户名
​		删除用户使用 sudo userdel -r 用户名，默认会删除同名的用户组。
​	用户组相关操作
​		1. 创建用户组
​		命令	说明
​		groupadd	创建(添加)用户组
​		创建用户组效果图:
​		groupadd命令
​		2. 创建用户并指定用户组
​		创建用户并指定用户组效果图:
​		groupadd命令
​		3. 修改用户组
​		修改用户组效果图:
​		usermod命令
​		4. 删除用户组
​		命令	说明
​		groupdel	删除用户组
​		删除用户组效果图:
​		groupdel命令
​		说明:
​		如果用户组下面有用户先删除用户在删除用户组
​		5. 小结
​		创建用户组使用: sudo groupadd 用户组名
​		创建用户并指定用户组使用: sudo useradd -m -g 用户组 用户名
​		修改用户组使用: sudo usermod -g 用户组 用户名
​		删除用户组使用: sudo groupdel 用户组名
​	远程登录、远程拷贝命令
​		远程登录、远程拷贝命令
​		学习目标
​		能够写出远程拷贝、远程登录命令
​		1. 远程登录、远程拷贝命令的介绍
​		命令	说明
​		ssh	远程登录
​		scp	远程拷贝
​		2. ssh命令的使用
​		ssh是专门为远程登录提供的一个安全性协议，常用于远程登录，想要使用ssh服务，需要安装相应的服务端和客户端软件，当软件安装成功以后就可以使用ssh命令了，以后可以通过远程登录之间操作远程的服务器。
​		远程登录效果图:
​		ssh命令
​		软件安装步骤:
​		假如Ubuntu作为服务端,需要安装ssh服务端软件. 执行命令: sudo apt-get install openssh-server
​		客户端电脑如果是 macOS 系统则不需要安装 ssh 客户端软件，默认已经安装过了，直接可以使用 ssh 命令
​		客户端电脑如果是Windows系统则需要安装OpenSSH for Windows这个软件
​		ssh命令格式:
​		ssh 用户名@ip地址
​		ssh命令效果图:
​		ssh命令
​		说明:
​		在一台电脑上可以安装安装ssh客户端和ssh服务端软件
​		在Ubuntu安装ssh客户端命令: sudo apt-get install openssh-client
​		3. scp命令的使用
​		scp是基于ssh进行远程文件拷贝的命令，也就是说需要保证服务端和客户端电脑安装了相应的ssh软件，以后可以把我们写代码远程拷贝到服务器。
​		scp命令格式:
​		远程拷贝文件
​		scp 本地文件 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径
​		scp 远程服务器用户名@远程服务器ip地址:远程服务器文件 指定拷贝到本地电脑的路径
​		远程拷贝目标
​		scp -r 本地目录 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径
​		scp -r 远程服务器用户名@远程服务器ip地址:远程服务器目录 指定拷贝到本地电脑的路径
​		-r 表示递归拷贝整个目录
​		本地文件远程拷贝到服务器效果图:
​		scp命令
​		服务器文件远程拷贝到本地效果图:
​		scp命令
​		本地目录远程拷贝到服务器效果图:
​		scp命令
​		服务器目录远程拷贝到本地效果图:
​		scp命令
​		4. FileZilla软件的使用
​		FileZilla 是一个免费开源的FTP软件, 使用可视化方式进行上传和下载文件。以后可以通过 FileZilla 来代替 scp 命令
​		FileZilla使用效果图:
​		FileZilla FileZilla FileZilla FileZilla
​		5. 小结
​		ssh命令是远程登录主机电脑，相当于直接操作的是远程电脑。
​		scp命令是可以完成远程拷贝操作，注意:拷贝文件夹需要加-r选项。
​		大量的文件上传和下载可以通过可视化工具FileZilla来完成。
​	编辑器 vim
​		学习目标
​		能够说出vim的三种工作模式
​		能够说出vim对应复制和粘贴命令
​		1. vim 的介绍
​		vim 是一款功能强大的文本编辑器，也是早年 Vi 编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。
​		2. vim 的工作模式
​		命令模式
​		编辑模式
​		末行模式
​		说明:
​		vim 打开文件进入的是命令模式
​		工作模式效果图:
​		ssh命令
​		注意点:
​		编辑模式和末行模式之间不能直接进行切换，都需要通过命令模式来完成。
​		3. vim 的末行模式命令
​		:w 保存
​		:wq 保存退出
​		:x 保存退出
​		:q! 强制退出
​		4. vim 的常用命令
​		命令	说明
​		yy	复制光标所在行
​		p	粘贴
​		dd	删除/剪切当前行
​		V	按行选中
​		u	撤销
​		ctr+r	反撤销
​		>>	往右缩进
​		<<	往左缩进
​		:/搜索的内容	搜索指定内容
​		:%s/要替换的内容/替换后的内容/g	全局替换
​		:开始行数,结束行数s/要替换的内容/替换后的内容	局部替换
​		.	重复上一次命令操作
​		G	回到最后一行
​		gg	回到第一行
​		数字+G	回到指定行
​		shift+6	回到当前行的行首
​		shift+4	回到当前行的行末
​		ctr+f	下一屏
​		ctr+b	上一屏
​		5. 小结
​		vim 是一款功能强大的命令文本编辑器，可以对远程服务器的代码直接进行修改，这样操作起来更加快速和方便。
​	软件安装
​		学习目标
​		能够使用apt-get命令安装软件
​		1. 软件安装的介绍
​		Ubuntu软件安装有两种方式:
​		离线安装(deb文件格式安装）
​		在线安装(apt-get方式安装)
​		2. deb文件格式安装
​		是 Ubuntu 的安装包格式，可以使用 dpkg 命令进行软件的安装和卸载。
​		命令	说明
​		dpkg	安装和卸载deb安装包
​		dpkg命令选项:
​		选项	说明
​		-i	离线安装deb安装包
​		dpkg命令效果图:
​		dpkg命令
​		3. apt-get方式安装
​		是在线安装deb软件包的命令，主要用于在线从互联网的软件仓库中搜索、安装、升级、卸载软件。
​		在线安装软件命令格式:
​		sudo apt–get install 安装包 , 表示在线安装deb安装包
​		4. 更改镜像源
​		因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器。
​		镜像源说明:
​		镜像源就是下载软件来源的服务器。
​		镜像源效果图:
​		镜像源命令
​		更改镜像源的方式:
​		可视化方式更改镜像源
​		手动方式更改镜像源
​	软件卸载
​		学习目标
​		能够使用apt-get命令卸载软件
​		1. 软件卸载的介绍
​		Ubuntu软件卸载有两种方式:
​		离线安装包的卸载(deb 文件格式卸载）
​		在线安装包的卸载(apt-get 方式卸载)
​		2. deb 文件格式卸载
​		命令格式:
​		sudo dpkg –r 安装包名
​		-r 选项表示安装的卸载
​		dpkg 卸载效果图:
​		dpkg命令
​		3. apt-get 方式卸载
​		命令格式:
​		sudo apt-get remove 安装包名
​		apt-get 卸载效果图:
​		apt-get命令
​		4. 小结
​		Ubuntu 操作系统卸载软件有两种方式:
​		dpkg -r 安装包 命令
​		apt-get remove 安装包 命令卸载

Linux命令总结
	一、Linux管理和目录命令
		pwd 显示当前路径地址
		cd 改变当前用户的目录
		ls 查看当前文件夹下的文件
		mkdir  新建文件夹目录
		rmdir  删除文件夹目录
		touch  新建文件
		cat    查看文本内容
		mv     移动
		cp	复制
		rm	删除
		grep	字符串查找
	二、线上查找
		man 查看当前或者一个命令的使用方法
		locate 根据一个关键字或者关键词定位
		whatis 查看某个命令的含义
	三、文件阅读命令
		head	从头开始查看
		tail 	从尾开始查看
		more	分页查看
	四、文件或目录的压缩和解压缩
		tar 
		gzip
		bizip2
		gunzip
		bunzip
	五、权限管理
		chmod	修改权限
		useradd	用户添加
		userdel 用户删除
		su	切换用户
		passwd	修改密码
		chgrp	修改文件所在组
		chown	用来修改文件的所有者
	六、文件的定位和查找
		which  定位
		whereis	查找
	七、磁盘操作
		df 查看文件系统使用情况
		du 查看文件磁盘占用情况
	八、系统命令
		reboot重启
		shutdown 关机
		halt	关机
		ps	进程
		toop	进程
		date	日期
		cal	日历
		exit	退出
		kill	结束进程
	九、网络
		ipconfig 显示网络状态
		ping	监测主机
		netstat	知道整个linux系统的网络情况或显示网络状态

Linux刷题
	1、查找文件
		find /目录 -name filename.txt
		根据名称查找/目录下的filename.txt文件

Shell

Windows
	# 关机、重启、注销、休眠、定时
​		关机：shutdown /s
​		重启：shutdown /r
​		注销：shutdown /l
​		休眠：shutdown /h /f
​		取消关机：shutdown /a
​		定时关机：shutdown /s /t 3600（3600 秒后关机）
	# 目录操作
​		切换目录，进入指定文件夹：
​		切换磁盘：d:（进入 d 盘）
​		切换磁盘和目录：cd /d d:/test（进入 d 盘 test 文件夹）
​		进入文件夹：cd \test1\test2（进入 test2 文件夹）
​		返回根目录：cd \
​		回到上级目录：cd ..
​		新建文件夹：md test
​		显示目录内容：
​		显示目录中文件列表：dir
​		显示目录结构：tree d:\test（d 盘 test 目录）
​		显示当前目录位置：cd
​		显示指定磁盘的当前目录位置：cd d:
	# 网络操作
​		延迟和丢包率：ping ip/域名
​		Ping 测试 5 次：ping ip/域名 -n 5
​		清除本地 DNS 缓存：ipconfig /flushdns
​		路由追踪：tracert ip/域名
	# 进程/服务操作
​		进程管理：
​		显示当前正在运行的进程：tasklist
​		运行程序或命令：start 程序名
​		结束进程，按名称：taskkill /im notepad.exe（关闭记事本）
​		结束进程，按 PID：taskkill /pid 1234（关闭 PID 为 1234 的进程）
​		服务管理：
​		显示当前正在运行的服务：net start
​		启动指定服务：net start 服务名
​		停止指定服务：net stop 服务名
​		保存为 .bat 可执行文件
​		我们可以将常用的命令输入记事本中，并保存为后缀为 .bat 的可执行文件。
​		以后只要双击该文件即可执行指定命令；将文件放入系统【启动】目录中，可以实现开机自动运行。
​	以下40个非常实用的Windows系统命令大全，在WinXP、Win7、Windows server均可使用：
​		cmd------CMD命令提示符
​		MSConfig------系统配置实用程序
​		regedit------注册表编辑器
​		notepad------打开记事本
​		calc------启动计算器
​		mstsc------远程桌面连接
​		services.msc------系统服务
​		gpedit.msc------组策略
​		shutdown------60秒倒计时关机命令
​		Nslookup-------IP地址侦测器
​		explorer------打开资源管理器
​		chkdsk.exe------Chkdsk磁盘检查
​		dcomcnfg------打开系统组件服务
​		devmgmt.msc------设备管理器
​		cleanmgr------垃圾整理
​		compmgmt.msc------计算机管理
​		secpol.msc------本地安全策略
​		netstat -an------(TC)命令检查接口
​		taskmgr------任务管理器
​		mmc------打开控制台
​		logoff------注销命令
​		lusrmgr.msc------本机用户和组
​		dvdplay------DVD播放器
​		diskmgmt.msc------磁盘管理实用程序
​		dxdiag------检查DirectX信息
​		perfmon.msc------计算机性能检测程序
​		winver------检测Windows版本
​		write------写字板
​		wiaacmgr------扫描仪和照相机向导
​		mspaint------画图板
​		magnify------放大镜实用程序
​		utilman------辅助工具管理器
​		osk------打开屏幕键盘
​		odbcad32------ODBC数据源管理器
​		Sndvol32或Sndvol------音量控制程序
​		sfc.exe------系统文件检查器
​		sfc /scannow------Windows文件保护
​		eventvwr------事件查看器
​		cliconfg------SQL Server客户端网络实用程序
​		certmgr.msc------证书管理实用程序
​		使用 Win键+其他键组合：
​		Win键：打开“开始”菜单
​		Win键+E：打开我的电脑
​		Win键+R：打开运行对话框
​		Win键+D：显示桌面
​		Win键+M：最小化所有窗口
​		Win键+X：Windows移动中心，调节音量，屏幕亮度
​		Win键+Home：除了正在选择的窗口，其他窗口最小化
​		Win键+PAUSE BREAK：打开“系统属性”对话框
​		Win键+【+/-】：打开Windows放大、缩小功能
​		Win键+Pause：显示系统属性对话框
​		Win键+TAB：Aero三维效果切换程序
​		Win键+数字键：让位于任务栏上的程序打开（数字为序号）
​		Win键+P：选择一个演示文稿显示模式，可以用来关闭屏幕
​		Win键+L：锁定计算机，需要输入密码或者选择其他用户
​		Win键+T：多次按可以在多个程序间顺序切换
​		Win键+F：计算机搜索，可以搜索计算机里面所有文件
​		Win键+【←/→】：在屏幕左/右半个屏幕最大化
​		Win键+【↑/↓】：最大化/最小化



常见题目
	1. 什么是性能测试?
		概念：性能测试是模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行的测试。
		说明：
		    1). 峰值：客户指定指标数值或场景需求数值，如：CPU使用率80%以内、登录3秒、内存空间40%等等
		    2). 负载：用户(一个或多个)向服务器发送请求，负载测试我们1.2节会讲解
	2. 性能测试与功能测试的焦点?
		功能测试：验证软件系统操作功能是否符合产品功能需求规格，主要焦点在功能（正向、逆向）；
		性能测试：验证软件系统是否满足业务需求场景，主要焦点是业务场景的满足度（时间、空间）；
		说明：
		    时间：软件的响应时间...
		    空间：服务器的磁盘读写数率、CPU 使用率、内存空闲率...
	3. 性能测试与功能测试的关系?
		功能测试和性能测试是相辅相成的，对于一款优秀的软件产品来讲，它们是测试工作中不可或缺的两个重要环节；



星环科技测开实习生面经

1.自我介绍

2.后续的规划和实习时间

3.TCP三次握手和四次挥手

4.Linux查看资源使用情况和网络带宽（没答出来）

5.有用linux抓过包吗（没有）

6.docker的平台？

7.webservice接口有用过吗？（没有）

8.Mysql隔离级别？MVCC机制实现原理？（不会）

9.通过mysql做过哪些工作？

10.写过python的代码量？（我简历写的熟练python，其实我写的不多，答了点其他的绕过去了）

11.之前项目中测试的大概流程？

12.测试用例的内容？

13.反问

14.到岗时间？



mysql
	知识要点：常用的SQL命令，子查询、连接查询、存储过程、触发器、游标等数据库概念和语法。

MySQL数据库的基本使用
	数据库说明
		学习目标
			能够知道数据库的作用
		1. 数据库的介绍
			数据库就是存储和管理数据的仓库，数据按照一定的格式进行存储，用户可以对数据库中的数据进行增加、修改、删除、查询等操作。
		2. 数据库的分类
			非关系型数据库
			关系型数据库
			常用的关系型数据库:

Oracle
Microsoft SQL Server
MySQL
SQLite
非关系型数据库:

非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调 Key-Value 的方式存储数据。

常用的非关系型数据库:

MongoDB
Redis
		3. 数据库的作用
			数据库的作用就是存储和管理数据的
		4. 数据库的特点
			持久化存储
读写速度极高
保证数据的有效性
		5. 小结
			数据库就是存储和管理数据的一个仓库，是用来持久化存储和快速读取数据的。
			数据库可以分为关系型数据库和非关系型数据库
	关系型数据库管理系统
		1、关系型数据库管理系统介绍
			学习目标
				知道数据库和数据库管理系统的关系
			1. 关系型数据库管理系统的介绍
				数据库管理系统（英语全拼：Relational Database Management System，简称RDBMS）是为管理关系型数据库而设计的软件系统，如果大家想要使用关系型数据库就需要安装数据库管理系统，其实就是一个应用软件。
				关系型数据库管理系统可以分为:

关系型数据库服务端软件
关系型数据库客户端软件
			关系型数据库管理系统的效果图:
				

		2. SQL的介绍
			SQL(Structured Query Language)是结构化查询语言，是一种用来操作RDBMS的数据库的语言。也就是说通过 SQL 可以操作 oracle,sql server,mysql,sqlite 等关系型的数据库。
			SQL的作用是实现数据库客户端和数据库服务端之间的通信，SQL就是通信的桥梁。
			SQL语言主要分为：
				DQL：数据查询语言，用于对数据进行查询，如select
				DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete
				TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback
				DCL：数据控制语言，进行授权与权限回收，如grant、revoke
				DDL：数据定义语言，进行数据库、表的管理等，如create、drop
			说明:
				对于程序员来讲，重点是数据的增、删、改、查，必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它操作如TPL、DCL了解即可.
				SQL语言不区分大小写
		3. 小结
			关系型数据库管理系统是一个软件，它可以管理不同的数据库，想要对数据库进行操作安装对应的关系型数据库管理系统软件即可。
			SQL的作用是实现数据库客户端和数据库服务端之间的通信，好比是通信桥梁。
	MySQL数据库
		sudo apt-get install mysql-server
		查看MySQL服务状态:
			sudo service mysql status
		停止MySQL服务:
			sudo service mysql stop
		启动MySQL服务:
			sudo service mysql start
		重启MySQL服务:
			sudo service mysql restart
		配置文件路径为: /etc/mysql/mysql.conf.d/mysqld.cnf
		命令行客户端mysql的安装
			sudo apt-get install mysql-client
		mysql命令的使用帮助:
			mysql --help
		MySQL客户端连接MySQL服务端命令
			mysql -uroot -p
	数据类型和约束
		1. 数据类型
			使用数据类型的原则是:够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间。

常用数据类型如下:

整数：int，bit
小数：decimal
字符串：varchar,char
日期时间: date, time, datetime
枚举类型(enum)
数据类型说明:

decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.
char表示固定长度的字符串，如char(3)，如果填充'ab'时会补一个空格为'ab '，3表示字符数
varchar表示可变长度的字符串，如varchar(3)，填充'ab'时就会存储'ab'，3表示字符数
对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径.
字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.
		2. 数据约束
			主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.
			非空 not null: 此字段不允许填写空值.
			惟一 unique: 此字段的值不允许重复.
			默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.
			外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.
		3. 数据类型附录表
			1. 整数类型
类型	字节大小	有符号范围(Signed)	无符号范围(Unsigned)
TINYINT	1	-128 ~ 127	0 ~ 255
SMALLINT	2	-32768 ~ 32767	0 ~ 65535
MEDIUMINT	3	-8388608 ~ 8388607	0 ~ 16777215
INT/INTEGER	4	-2147483648 ~2147483647	0 ~ 4294967295
BIGINT	8	-9223372036854775808 ~ 9223372036854775807	0 ~ 18446744073709551615

2. 字符串
   类型	说明	使用场景
   CHAR	固定长度，小型数据	身份证号、手机号、电话、密码
   VARCHAR	可变长度，小型数据	姓名、地址、品牌、型号
   TEXT	可变长度，字符个数大于 4000	存储小型文章或者新闻
   LONGTEXT	可变长度， 极大型文本数据	存储极大型文本数据
3. 时间类型
   类型	字节大小	示例
   DATE	4	'2020-01-01'
   TIME	3	'12:29:59'
   DATETIME	8	'2020-01-01 12:29:59'
   YEAR	1	'2017'
   TIMESTAMP	4	'1970-01-01 00:00:01' UTC ~ '2038-01-01 00:00:01' UTC
   图形化客户端Navicat
   	sqlyog
   命令行客户端MySQL的使用
   	登录or登出数据库:
   		登出(退出)数据库:
   			quit 或 exit 或 ctrl + d
   		登录数据库:
   		mysql -uroot -p
   		# 显示当前时间
   select now();
   	2. 数据库操作的SQL语句
   		查看所有数据库
   			show databases;
   		创建数据库
   			create database 数据库名 charset=utf8;
   			例：
   			create database python charset=utf8;
   		使用数据库
   			use 数据库名;
   		查看当前使用的数据库
   			select database();
   		删除数据库-慎重
   			drop database 数据库名;
   			例：
   			drop database python;
   	3. 表结构操作的SQL语句
   		查看当前数据库中所有表
   			show tables;
   		创建表
   			create table students(
    id int unsigned primary key auto_increment not null,
    name varchar(20) not null,
    age tinyint unsigned default 0,
    height decimal(5,2),
    gender enum('男','女','人妖','保密')
   );
   			create table 表名(
   字段名称 数据类型  可选的约束条件,
   column1 datatype contrai,
   ...
   );
   		修改表-添加字段
   			alter table 表名 add 列名 类型 约束;
   例：
   alter table students add birthday datetime;
   		修改表-修改字段类型
   			alter table 表名 modify 列名 类型 约束;
   例：
   alter table students modify birthday date not null;
   			说明:

modify: 只能修改字段类型或者约束，不能修改字段名
			修改表-修改字段名和字段类型
				alter table 表名 change 原名 新名 类型及约束;
例：
alter table students change birthday birth datetime not null;
				说明:

change: 既能对字段重命名又能修改字段类型还能修改约束
			修改表-删除字段
				alter table 表名 drop 列名;
例：
alter table students drop birthday;
			查看创表SQL语句
				show create table 表名;
例：
show create table students;
			查看创库SQL语句
				show create database 数据库名;
例：
show create database mytest;
			删除表
				drop table 表名;
例：
drop table students;
		4. 表数据操作的SQL语句
			查询数据
				-- 1. 查询所有列
select * from 表名;
例：
select * from students;
-- 2. 查询指定列
select 列1,列2,... from 表名;
例：
select id,name from students;
			添加数据
				-- 1. 全列插入：值的顺序与表结构字段的顺序完全一一对应
insert into 表名 values (...)
例:
insert into students values(0, 'xx', default, default, '男');
-- 2. 部分列插入：值的顺序与给出的列顺序对应
insert into 表名 (列1,...) values(值1,...)
例:
insert into students(name, age) values('王二小', 15);
-- 3. 全列多行插入
insert into 表名 values(...),(...)...;
例:
insert into students values(0, '张飞', 55, 1.75, '男'),(0, '关羽', 58, 1.85, '男');
-- 4. 部分列多行插入
insert into 表名(列1,...) values(值1,...),(值1,...)...;
例：
insert into students(name, height) values('刘备', 1.75),('曹操', 1.6);
				说明:

主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null或者default)
在全列插入时，如果字段列有默认值可以使用 default 来占位，插入后的数据就是之前设置的默认值
			修改数据
				update 表名 set 列1=值1,列2=值2... where 条件
例：
update students set age = 18, gender = '女' where id = 6;
			删除数据
				delete from 表名 where 条件
例：
delete from students where id=5;
				问题:
				上面的操作称之为物理删除，一旦删除就不容易恢复，我们可以使用逻辑删除的方式来解决这个问题。
				-- 添加删除表示字段，0表示未删除 1表示删除
alter table students add isdelete bit default 0;
-- 逻辑删除数据
update students set isdelete = 1 where id = 8;
				说明:
				逻辑删除，本质就是修改操作
		5. 小结
			登录数据库: mysql -uroot -p
退出数据库: quit 或者 exit 或者 ctr + d
创建数据库: create database 数据库名 charset=utf8;
使用数据库: use 数据库名;
删除数据库: drop database 数据库名;
创建表: create table 表名(字段名 字段类型 约束, ...);
修改表-添加字段: alter table 表名 add 字段名 字段类型 约束
修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束
修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束
修改表-删除字段: alter table 表名 drop 字段名;
删除表: drop table 表名;
查询数据: select * from 表名; 或者 select 列1,列2,... from 表名;
插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...)
修改数据: update 表名 set 列1=值1,列2=值2... where 条件
删除数据: delete from 表名 where 条件
	as和distinct关键字
		学习目标
			能够知道去除重复数据行的关键字
		1. as关键字
			使用 as 给字段起别名
			select id as 序号, name as 名字, gender as 性别 from students;
			可以通过 as 给表起别名

-- 如果是单表查询 可以省略表名
select id, name, gender from students;

-- 表名.字段名
select students.id,students.name,students.gender from students;

-- 可以通过 as 给表起别名 
select s.id,s.name,s.gender from students as s;
		2. distinct关键字
			distinct可以去除重复数据行。

select distinct 列1,... from 表名;

例： 查询班级中学生的性别
select name, gender from students;

-- 看到了很多重复数据 想要对其中重复数据行进行去重操作可以使用 distinct
select distinct name, gender from students;
		as 关键字可以给表中字段 或者 表名起别名
		distinct 关键字可以去除重复数据行。
	where条件查询
		1. where条件查询的介绍
			where语句支持的运算符:

比较运算符
逻辑运算符
模糊查询
范围查询
空判断
			where条件查询语法格式如下:

select * from 表名 where 条件;
例：
select * from students where id = 1;
		2. 比较运算符查询
			等于: =
大于: >
大于等于: >=
小于: <
小于等于: <=
不等于: != 或 <>
			例1：查询编号大于3的学生:
select * from students where id > 3;

例2：查询编号不大于4的学生:
select * from students where id <= 4;

例3：查询姓名不是“黄蓉”的学生:
select * from students where name != '黄蓉';

例4：查询没被删除的学生:
select * from students where is_delete=0;
		3. 逻辑运算符查询
			and
or
not
			例1：查询编号大于3的女同学:

select * from students where id > 3 and gender=0;
例2：查询编号小于4或没被删除的学生:

select * from students where id < 4 or is_delete=0;
例3：查询年龄不在10岁到15岁之间的学生:

select * from students where not (age >= 10 and age <= 15);
			说明:
			多个条件判断想要作为一个整体，可以结合‘()’。
		4. 模糊查询
			like是模糊查询关键字
%表示任意多个任意字符
_表示一个任意字符
			例1：查询姓黄的学生:

select * from students where name like '黄%';
例2：查询姓黄并且“名”是一个字的学生:

select * from students where name like '黄_';
例3：查询姓黄或叫靖的学生:

select * from students where name like '黄%' or name like '%靖';
		5. 范围查询
			between .. and .. 表示在一个连续的范围内查询
in 表示在一个非连续的范围内查询
			例1：查询编号为3至8的学生:

select * from students where id between 3 and 8;
例2：查询编号不是3至8的男生:

select * from students where (not id between 3 and 8) and gender='男';
		6. 空判断查询
			判断为空使用: is null
判断非空使用: is not null
			例1：查询没有填写身高的学生:

select * from students where height is null;
			注意:

不能使用 where height = null 判断为空
不能使用 where height != null 判断非空
null 不等于 '' 空字符串
		7. 小结
			常见的比较运算符有 >,<,>=,<=,!=
逻辑运算符and表示多个条件同时成立则为真，or表示多个条件有一个成立则为真，not表示对条件取反
like和%结合使用表示任意多个任意字符，like和_结合使用表示一个任意字符
between-and限制连续性范围 in限制非连续性范围
判断为空使用: is null
判断非空使用: is not null
	排序
		1. 排序查询语法
			排序查询语法：

select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
语法说明:

先按照列1进行排序，如果列1的值相同时，则按照 列2 排序，以此类推
asc从小到大排列，即升序
desc从大到小排序，即降序
默认按照列值从小到大排列（即asc关键字）
例1：查询未删除男生信息，按学号降序:

select * from students where gender=1 and is_delete=0 order by id desc;
例2：显示所有的学生信息，先按照年龄从大-->小排序，当年龄相同时 按照身高从高-->矮排序:

select * from students  order by age desc,height desc;
		排序使用 order by 关键字
		asc 表示升序
		desc 表示降序
	分页查询
		1. 分页查询的介绍
		2. 分页查询的语法
			select * from 表名 limit start,count
说明:

limit是分页查询关键字
start表示开始行索引，默认是0
count表示查询条数
例1：查询前3行男生信息:

select * from students where gender=1 limit 0,3;
简写
select * from students where gender=1 limit 3;
		3. 分页查询案例
			已知每页显示m条数据，求第n页显示的数据

提示: 关键是求每页的开始行索引

查询学生表，获取第n页数据的SQL语句:

select * from students limit (n-1)*m,m
		4. 小结
			使用 limit 关键字可以限制数据显示数量，通过 limit 关键可以完成分页查询
			limit 关键字后面的第一个参数是开始行索引(默认是0，不写就是0)，第二个参数是查询条数

MySQL数据库的条件查询
	聚合函数
		学习目标
			能够写出查询总行数的SQL语句
		1. 聚合函数的介绍
			聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结合分组(group by)来使用，用于统计和计算分组数据。

常用的聚合函数:

count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值
		2. 求总行数
			-- 返回非NULL数据的总行数.
select count(height) from students; 
-- 返回总行数，包含null值记录;
select count(*) from students;
		3. 求最大值
			-- 查询女生的编号最大值
select max(id) from students where gender = 2;
		4. 求最小值
			-- 查询未删除的学生最小编号
select min(id) from students where is_delete = 0;
		5. 求和
			-- 查询男生的总身高
select sum(height) from students where gender = 1;
-- 平均身高
select sum(height) / count(*) from students where gender = 1;
		6. 求平均值
			-- 求男生的平均身高, 聚合函数不统计null值，平均身高有误
select avg(height) from students where gender = 1;
-- 求男生的平均身高, 包含身高是null的
select avg(ifnull(height,0)) from students where gender = 1;
			说明
			ifnull函数: 表示判断指定字段的值是否为null，如果为空使用自己提供的值。
		7. 聚合函数的特点
			聚合函数默认忽略字段为null的记录 要想列值为null的记录也参与计算，必须使用ifnull函数对null值做替换。
		8. 小结
			count(col): 表示求指定列的总行数
max(col): 表示求指定列的最大值
min(col): 表示求指定列的最小值
sum(col): 表示求指定列的和
avg(col): 表示求指定列的平均值
	分组查询
		学习目标
			能够写出分组查询的SQL语句
		1. 分组查询介绍
			分组查询就是将查询结果按照指定字段进行分组，字段中数据相等的分为一组。

分组查询基本的语法格式如下：

GROUP BY 列名 [HAVING 条件表达式] [WITH ROLLUP]

说明:

列名: 是指按照指定字段的值进行分组。
HAVING 条件表达式: 用来过滤分组后的数据。
WITH ROLLUP：在所有记录的最后加上一条记录，显示select查询时聚合函数的统计和计算结果
		2. group by的使用
			group by可用于单个字段分组，也可用于多个字段分组

-- 根据gender字段来分组
select gender from students group by gender;
-- 根据name和gender字段进行分组
select name, gender from students group by name, gender;
		3. group by + group_concat()的使用
			group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割

-- 根据gender字段进行分组， 查询gender字段和分组的name字段信息
select gender,group_concat(name) from students group by gender;
		4. group by + 聚合函数的使用
			- 统计不同性别的人的平均年龄
select gender,avg(age) from students group by gender;
-- 统计不同性别的人的个数
select gender,count(*) from students group by gender;
		5. group by + having的使用
			having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by

-- 根据gender字段进行分组，统计分组条数大于2的
select gender,count(*) from students group by gender having count(*)>2;
		6. group by + with rollup的使用
			with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果

-- 根据gender字段进行分组，汇总总人数
select gender,count(*) from students group by gender with rollup;
-- 根据gender字段进行分组，汇总所有人的年龄
select gender,group_concat(age) from students group by gender with rollup;
		7. 小结
			group by 根据指定的一个或者多个字段对数据进行分组
group_concat(字段名)函数是统计每个分组指定字段的信息集合
聚合函数在和 group by 结合使用时, 聚合函数统计和计算的是每个分组的数据
having 是对分组数据进行条件过滤
with rollup在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果
	连接查询-内连接
		学习目标
			能够写出内连接查询的SQL语句
		1. 连接查询的介绍
			连接查询可以实现多个表的查询，当查询的字段数据来自不同的表就可以使用连接查询来完成。

连接查询可以分为:

内连接查询
左连接查询
右连接查询
自连接查询
		2. 内连接查询
			查询两个表中符合条件的共有记录
			内连接查询语法格式:

select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2
说明:

inner join 就是内连接查询关键字
on 就是连接查询条件
例1：使用内连接查询学生表与班级表:

select * from students as s inner join classes as c on s.cls_id = c.id;
			

		3. 小结
			内连接使用inner join .. on .., on 表示两个表的连接查询条件
			内连接根据连接查询条件取出两个表的 “交集”
	连接查询-左连接
		学习目标
			能够写出左连接查询的SQL语句
		1. 左连接查询
			以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充
			左连接查询效果图:
			左连接查询语法格式:

select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2
说明:

left join 就是左连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用左连接查询学生表与班级表:

select * from students as s left join classes as c on s.cls_id = c.id;
		2. 小结
			左连接使用left join .. on .., on 表示两个表的连接查询条件
			左连接以左表为主根据条件查询右表数据，右表数据不存在使用null值填充。
	连接查询-右连接
		学习目标
			能够写出右连接查询的SQL语句
		1. 右连接查询
			以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充
			右连接查询效果图:
			右连接查询语法格式:

select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2
说明:

right join 就是右连接查询关键字
on 就是连接查询条件
表1 是左表
表2 是右表
例1：使用右连接查询学生表与班级表:

select * from students as s right join classes as c on s.cls_id = c.id;
		2. 小结
			右连接使用right join .. on .., on 表示两个表的连接查询条件
			右连接以右表为主根据条件查询左表数据，左表数据不存在使用null值填充。
	连接查询-自连接
		学习目标
			能够写出自连接查询的SQL语句
		1. 自连接查询
			左表和右表是同一个表，根据连接查询条件查询两个表中的数据。

区域表效果图

区域表

例1：查询省的名称为“山西省”的所有城市

区域表

创建areas表:

create table areas(
    id varchar(30) not null primary key, 
    title varchar(30), 
    pid varchar(30)
);
执行sql文件给areas表导入数据:

source areas.sql;
说明:

source 表示执行的sql文件
自连接查询的用法:

select c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = '山西省';
说明:

自连接查询必须对表起别名
		小结
			自连接查询就是把一张表模拟成左右两张表，然后进行连表查询。
			自连接就是一种特殊的连接方式，连接的表还是本身这张表
	子查询
		学习目标
			能够写出子查询的SQL语句
		1. 子查询的介绍
			在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句，外部那个select语句则称为主查询.

主查询和子查询的关系:

子查询是嵌入到主查询中
子查询是辅助主查询的,要么充当条件,要么充当数据源
子查询是可以独立存在的语句,是一条完整的 select 语句
		2. 子查询的使用
			例1. 查询大于平均年龄的学生:

select * from students where age > (select avg(age) from students);
例2. 查询学生在班的所有班级名字:

select name from classes where id in (select cls_id from students where cls_id is not null);
例3. 查找年龄最大,身高最高的学生:

select * from students where (age, height) =  (select max(age), max(height) from students);

		3. 小结
			子查询是一个完整的SQL语句，子查询被嵌入到一对小括号里面
	数据库设计之三范式
		范式: 对设计数据库提出的一些规范，目前有迹可寻的共有8种范式，一般遵守3范式即可。
		第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。
		第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。
		第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
		E-R模型由 实体、属性、实体之间的关系构成，主要用来描述数据库中表结构。
		开发流程是先画出E-R模型，然后根据三范式设计数据库中的表结构
	外键SQL语句的编写
		学习目标
			能够写出删除外键约束的SQL语句
		1. 外键约束作用
			外键约束:对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性
		2. 对于已经存在的字段添加外键约束
			alter table students add foreign key(cls_id) references classes(id);
			-- 为cls_id字段添加外键约束
		3. 在创建数据表时设置外键约束
			-- 创建学校表

create table school(
    id int not null primary key auto_increment, 
    name varchar(10)
);

-- 创建老师表
create table teacher(
    id int not null primary key auto_increment, 
    name varchar(10), 
    s_id int not null, 
    foreign key(s_id) references school(id)
);
		4. 删除外键约束
			-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称
show create table teacher;

-- 获取名称之后就可以根据名称来删除外键约束
alter table teacher drop foreign key 外键名;
		5. 小结
			添加外键约束: alter table 从表 add foreign key(外键字段) references 主表(主键字段);
			删除外键约束: alter table 表名 drop foreign key 外键名;
	演练-分组和聚合函数的组合使用
		学习目标
			能够写出分组和聚合函数组合使用的SQL语句
		1. 数据准备
			-- 创建 "京东" 数据库
create database jing_dong charset=utf8;

-- 使用 "京东" 数据库
use jing_dong;

-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);

-- 向goods表中插入数据

insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
			表结构说明:

id 表示主键 自增
name 表示商品名称
cate_name 表示分类名称
brand_name 表示品牌名称
price 表示价格
is_show 表示是否显示
is_saleoff 表示是否售完
		2. SQL语句演练
			查询类型cate_name为 '超极本' 的商品名称、价格

 select name,price from goods where cate_name = '超级本';
显示商品的分类

 select cate_name from goods group by cate_name;
求所有电脑产品的平均价格,并且保留两位小数

 select round(avg(price),2) as avg_price from goods;
显示每种商品的平均价格

 select cate_name,avg(price) from goods group by cate_name;
查询每种类型的商品中 最贵、最便宜、平均价、数量

 select cate_name,max(price),min(price),avg(price),count(*) 
 from goods group by cate_name;
查询所有价格大于平均价格的商品，并且按价格降序排序

 select id,name,price from goods 
 where price > (select round(avg(price),2) as avg_price from goods) 
 order by price desc;

MySQL数据库的高级使用
	将查询结果插入到其它表中
		

			-- 查询goods表中商品的分类信息

select cate_name from goods group by cate_name;

-- 将查询结果插入到good_cates表中
insert into good_cates(name) select cate_name from goods group by cate_name;

-- 添加移动设备分类信息
insert into good_cates(name) values('移动设备');
		想要完成表复制可以使用: insert into .. select .. SQL语句
	使用连接更新表中某个字段数据
		1. 更新goods表中的商品分类信息
			-- 查看goods表中的商品分类名称对应的商品分类id
select * from goods inner join good_cates on goods.cate_name = good_cates.name;

-- 把该语句中from 后的语句理解为一张虚表  
update goods g inner join good_cates gc on g.cate_name=gc.name set g.cate_name=gc.id;
		连接更新表中数据使用: update .. join .. 语句
	创建表并给某个字段添加数据
		

			-- 查询品牌信息 

select brand_name from goods group by brand_name;

-- 通过create table ...select来创建数据表并且同时插入数据
-- 创建商品分类表，注意: 需要对brand_name 用as起别名，否则name字段就没有值
create table good_brands (     
id int unsigned primary key auto_increment,     
name varchar(40) not null) select brand_name as name from goods group by brand_name;
			-- 将goods表中的品牌名称更改成品牌表中对应的品牌id
			update goods as g inner join good_brands gb on g.brand_name = gb.name set g.brand_name = gb.id;
		create table .. select 列名 .. 表示创建表并插入数据
	修改goods表结构
		

			-- 查看表结构

desc goods;
-- 通过alter table语句修改表结构
alter table goods change cate_name cate_id int not null, change brand_name brand_id int not null;
		修改表结构可以使用: alter table 语句，多个修改字段之间使用逗号分隔
	PyMySQL的使用
		 Python程序操作MySQL数据库
			安装pymysql第三方包:

sudo pip3 install pymysql
		pymysql的使用:
			导入 pymysql 包

 import pymysql
创建连接对象

调用pymysql模块中的connect()函数来创建连接对象,代码如下:

 conn=connect(参数列表)

 * 参数host：连接的mysql主机，如果本机是'localhost'
 * 参数port：连接的mysql主机的端口，默认是3306
 * 参数user：连接的用户名
 * 参数password：连接的密码
 * 参数database：数据库的名称
 * 参数charset：通信采用的编码方式，推荐使用utf8
   连接对象操作说明:

关闭连接 conn.close()
提交数据 conn.commit()
撤销数据 conn.rollback()
获取游标对象

获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下:

 # 调用连接对象的cursor()方法获取游标对象   

 cur =conn.cursor()
游标操作说明:

使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句
获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,'张三')
获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,'张三'),(2,'李四'))
关闭游标: cur.close(),表示和数据库操作完成
pymysql完成数据的查询操作

import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

# 查询 SQL 语句

sql = "select * from students;"

# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数

row_count = cursor.execute(sql)
print("SQL 语句执行影响的行数%d" % row_count)

# 取出结果集中一行数据,　例如:(1, '张三')

# print(cursor.fetchone())

# 取出结果集中的所有数据, 例如:((1, '张三'), (2, '李四'), (3, '王五'))

for line in cursor.fetchall():
    print(line)

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
pymysql完成对数据的增删改

import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

try:
    # 添加 SQL 语句
    # sql = "insert into students(name) values('刘璐'), ('王美丽');"
    # 删除 SQ L语句
    # sql = "delete from students where id = 5;"
    # 修改 SQL 语句
    sql = "update students set name = '王铁蛋' where id = 6;"
    # 执行 SQL 语句
    row_count = cursor.execute(sql)
    print("SQL 语句执行影响的行数%d" % row_count)
    # 提交数据到数据库
    conn.commit()
except Exception as e:
    # 回滚数据， 即撤销刚刚的SQL语句操作
    conn.rollback()

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
说明:

conn.commit() 表示将修改操作提交到数据库
conn.rollback() 表示回滚数据
防止SQL注入

什么是SQL注入?

用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。

如何防止SQL注入?

SQL语句参数化

SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作
将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数
防止SQL注入的示例代码:

from pymysql import connect

def main():

    find_name = input("请输入物品名称：")
    
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,user='root',password='mysql',database='jing_dong',charset='utf8')
    # 获得Cursor对象
    cs1 = conn.cursor()
    
    # 非安全的方式
    # 输入 ' or 1 = 1 or '   (单引号也要输入)
    # sql = "select * from goods where name='%s'" % find_name
    # print("""sql===>%s<====""" % sql)
    # # 执行select语句，并返回受影响的行数：查询所有数据
    # count = cs1.execute(sql)
    
    # 安全的方式
    # 构造参数列表
    params = [find_name]
    # 执行select语句，并返回受影响的行数：查询所有数据
    count = cs1.execute("select * from goods where name=%s", params)
    # 注意：
    # 如果要是有多个参数，需要进行参数化
    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可
    # %s 不需要带引号
    
    # 打印受影响的行数
    print(count)
    # 获取查询的结果
    # result = cs1.fetchone()
    result = cs1.fetchall()
    # 打印查询的结果
    print(result)
    # 关闭Cursor对象
    cs1.close()
    # 关闭Connection对象
    conn.close()

if __name__ == '__main__':
    main()
说明:

execute方法中的 %s 占位不需要带引号
			import pymysql

# 创建连接对象

conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')

# 获取游标对象

cursor = conn.cursor()

try:
    # 添加 SQL 语句
    # sql = "insert into students(name) values('刘璐'), ('王美丽');"
    # 删除 SQ L语句
    # sql = "delete from students where id = 5;"
    # 修改 SQL 语句
    sql = "update students set name = '王铁蛋' where id = 6;"
    # 执行 SQL 语句
    row_count = cursor.execute(sql)
    print("SQL 语句执行影响的行数%d" % row_count)
    # 提交数据到数据库
    conn.commit()
except Exception as e:
    # 回滚数据， 即撤销刚刚的SQL语句操作
    conn.rollback()

# 关闭游标

cursor.close()

# 关闭连接

conn.close()
		3. 小结
			导包

 import pymysql
创建连接对象

 pymysql.connect(参数列表)
获取游标对象

 cursor =conn.cursor()
执行SQL语句

 row_count = cursor.execute(sql)
获取查询结果集

 result = cursor.fetchall()
将修改操作提交到数据库

 conn.commit()
回滚数据

 conn.rollback()
关闭游标

 cursor.close()
关闭连接

 conn.close()
	事务
		学习目标
			能够知道事务的四大特性
		1. 事务的介绍
			事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。
		2. 事务的四大特性
			原子性(Atomicity)
一致性(Consistency)
隔离性(Isolation)
持久性(Durability)
原子性:

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

一致性:

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

隔离性:

通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

持久性:

一旦事务提交，则其所做的修改会永久保存到数据库。

说明:

事务能够保证数据的完整性和一致性，让用户的操作更加安全。
		3. 事务的使用
			在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。

表的存储引擎说明:

表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。
			-- 查看MySQL数据库支持的表的存储引擎
show engines;
		查看goods表的创表语句:
			-- 选择数据库
use jing_dong;
-- 查看goods表
show create table goods;

mysql root@(none):jing_dong> show create table goods;
+-------+--------------------------------------------------------+
| Table | Create Table                                           |
+-------+--------------------------------------------------------+
| goods | CREATE TABLE `goods` (                                 |
|       |   `id` int(10) unsigned NOT NULL AUTO_INCREMENT,       |
|       |   `name` varchar(150) NOT NULL,                        |
|       |   `cate_id` int(10) unsigned NOT NULL,                 |
|       |   `brand_id` int(10) unsigned NOT NULL,                |
|       |   `price` decimal(10,3) NOT NULL DEFAULT '0.000',      |
|       |   `is_show` bit(1) NOT NULL DEFAULT b'1',              |
|       |   `is_saleoff` bit(1) NOT NULL DEFAULT b'0',           |
|       |   PRIMARY KEY (`id`)                                   |
|       | ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------+
		开启事务:

begin;
或者
start transaction;
		4. 小结
			事务的特性:
原子性: 强调事务中的多个操作时一个整体
一致性: 强调数据库中不会保存不一致状态
隔离性: 强调数据库中事务之间相互不可见
持久性: 强调数据库能永久保存数据，一旦提交就不可撤销
MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操作会自动的触发事务,完成事务的提交或者回滚
开启事务使用 begin 或者 start transaction;
回滚事务使用 rollback;
pymysql 里面的 conn.commit() 操作就是提交事务
pymysql 里面的 conn.rollback() 操作就是回滚事务
	索引
		学习目标
			能够写出创建索引的SQL语句
		1. 索引的介绍
			索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。
			应用场景:
			当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。
		2. 索引的使用
			查看表中已有索引:

show index from 表名;
说明:

主键列会自动创建索引
索引的创建:

-- 创建索引的语法格式
-- alter table 表名 add index 索引名[可选](列名, ..)
-- 给name字段添加索引
alter table classes add index my_name (name);
说明:

索引名不指定，默认使用字段名
索引的删除:

-- 删除索引的语法格式
-- alter table 表名 drop index 索引名
-- 如果不知道索引名，可以查看创表sql语句
show create table classes;
alter table classes drop index my_name;
		3. 案例-验证索引查询性能
			创建测试表testindex:

create table test_index(title varchar(10));
向表中插入十万条数据:

from pymysql import connect

def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='python',user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()

if __name__ == "__main__":
    main()
验证索引性能操作：

-- 开启运行时间监测：
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间：
show profiles;
-- 给title字段创建索引：
alter table test_index add index (title);
-- 再次执行查询语句
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
		4. 联合索引
			联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。

-- 创建teacher表
create table teacher
(
    id int not null primary key auto_increment,
    name varchar(10),
    age int
);

-- 创建联合索引
alter table teacher add index (name,age);
联合索引的好处:

减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。
		5. 联合索引的最左原则
			在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。

最左原则示例:

-- 下面的查询使用到了联合索引
select * from stu where name='张三' -- 这里使用了联合索引的name部分
select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 
-- 下面的查询没有使用到联合索引
select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合
说明:

在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效
		6. MySQL中索引的优点和缺点和使用原则
			优点：

加快数据的查询速度
缺点：

创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加
使用原则：

通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
		7. 小结
			索引是加快数据库的查询速度的一种手段
			创建索引使用: alter table 表名 add index 索引名[可选] (字段名, xxx);
			删除索引使用: alter table 表名 drop index 索引名;

刷题



Linux命令总结
	一、Linux管理和目录命令
		pwd 显示当前路径地址
		cd 改变当前用户的目录
		ls 查看当前文件夹下的文件
		mkdir  新建文件夹目录
		rmdir  删除文件夹目录
		touch  新建文件
		cat    查看文本内容
		mv     移动
		cp	复制
		rm	删除
		grep	字符串查找
	二、线上查找
		man 查看当前或者一个命令的使用方法
		locate 根据一个关键字或者关键词定位
		whatis 查看某个命令的含义
	三、文件阅读命令
		head	从头开始查看
		tail 	从尾开始查看
		more	分页查看
	四、文件或目录的压缩和解压缩
		tar 
		gzip
		bizip2
		gunzip
		bunzip
	五、权限管理
		chmod	修改权限
		useradd	用户添加
		userdel 用户删除
		su	切换用户
		passwd	修改密码
		chgrp	修改文件所在组
		chown	用来修改文件的所有者
	六、文件的定位和查找
		which  定位
		whereis	查找
	七、磁盘操作
		df 查看文件系统使用情况
		du 查看文件磁盘占用情况
	八、系统命令
		reboot重启
		shutdown 关机
		halt	关机
		ps	进程
		toop	进程
		date	日期
		cal	日历
		exit	退出
		kill	结束进程
	九、网络
		ipconfig 显示网络状态
		ping	监测主机
		netstat	知道整个linux系统的网络情况或显示网络状态
Linux刷题
	1、查找文件
		find /目录 -name filename.txt
		根据名称查找/目录下的filename.txt文件



1）pwd：显示当前所在位置；

2）su：申请切换root用户，需要输入root用户密码（sudo su是当前用户暂时申请root权限，需要输入当前用户密码）；

3）grep：要搜索的字符串 要搜索的文件 --color ： 搜索命令，–color 代表高亮显示；

4）ps -ef || ps -aux：两者的区别是展示格式不同（System Ｖ风格和BSD风格）；

5）kill -9 [pid] ： 销毁进程（-9表示强制停止），先用ps查找进程，然后用kill掉；

6）find ：寻找；

7）tar -zcvf ：打包并压缩文件 ；tar -xvf 压缩文件 - C 解压的位置 : 解压压缩包；

8）free : 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存；

9）wget : 是从远程下载的工具 ； curl ；

10）top : 监控系统状况，比如CPU、内存的使用，显示系统上正在运行的进程 load average（系统负载，就是进程队列的长度）；

11）vmstat : 虚拟内存性能监控、CPU 监控。











# 计算机网络

一、网络 7 层架构(ISO/OSI协议参考模型)
	物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
	数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
	网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
	传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。
	会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
	表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
	应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。
	
	
	

二、TCP/IP 原理
	TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。
	

	1、应用层(Application Layer)
	    应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。
	2、传输层(Tramsport Layer-TCP/UDP)
	    传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
	3、网络层(Internet Layer)
	  网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP，Internet Protocol)。
	4、网络访问层(Network Access Layer)
	   网络访问层(Network Access Layer)在 TCP/IP ：是TCP/IP协议栈的最底层，它提供物理网络的接口，实现对复杂数据的发送和接收。网络访问层协议为网络接口、数据传输提供了对应的技术规范。网络访问层对应 OSI 七层网络模型的物理层和数据链路层。
	5、四层协议和对应的标准七层协议的关系如下图
	————————————————

三、TCP 三次握手/四次挥手
	1、三次握手
	SYN：同步序列编号（Synchronize Sequence Numbers）、seq：序号--sequence number、
ACK (Acknowledge character）即是确认字符  、ack number 确认序号
	第一次握手： 主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器主机 B，由 SYN=1 知道，A 要求建立联机；
	第二次握手： 主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包
	第三次握手： 主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认。
	

	2、四次挥手
	TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。
	关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u
	服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
	关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。
	客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
	————————————————
	主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到close 状态。
	为什么会有TIME_WAIT状态：
		确保有足够的时间让对方收到ACK包
		避免新旧连接混淆
	3、TCP/IP状态
		1、LISTENING（listening)
		FTP服务启动后首先处于侦听（LISTENING）状态。
		2、ESTABLISHED（established）
		建立连接。表示两台机器正在通信。
		3、CLOSE_WAIT
		对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT，此时我方要调用close()来使得连接正确关闭。
		4、TIME_WAIT
		我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。
		5、SYN_SENT
		SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED。

四、TCP 长连接与短连接
	1、长连接和短连接使用原因
	当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次挥手，所以说每个连接的建立都是需要资源消耗和时间消耗的。
	2、HTTP的长连接和短连接
	HTTP的长连接和短连接本质上是TCP长连接和短连接。
	在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
	而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
	Connection:keep-alive
	1
	在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
	3、TCP—长连接
	 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。
	连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；
	这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；
	 TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
	4、TCP—短连接
	 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；
	 连接→数据传输→关闭连接；
	5、应用场景
	 长连接： 多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。
	例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
	 短连接： 像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

五、HTTP原理
	 HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。
	1、地址解析
	如用客户端浏览器请求这个页面：http://www.lydms.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
	协议名： http
	主机名： www.lydms.com
	端口： 8080
	对象路径： /index.htm
	在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。
	2、封装 HTTP 请求数据包
	把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包
	3、封装成 TCP 包并建立连接
	封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）
	4、客户机发送请求命
	客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。
	5、服务器响应
	服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。
	6、服务器关闭 TCP 连接
	一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

六、HTTPS
	六、HTTPS
	HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：
	1、SSL/TLS之间的关系
	SSL 是英文“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。
	为啥要发明 SSL 这个协议呢？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。
	到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
	很多人都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。
	2、建立连接获取证书
	SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
	3、证书验证
	Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
	4、数据加密和传输
	如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。
	

七、CDN 原理
	CND 一般包含分发服务系统、负载均衡系统和管理系统。
	1、分发服务系统
	其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。
	2、负载均衡系统
	负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。
	3、管理系统
	分为运营管理和网络管理子系统。网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。
	包括用户管理、产品管理、计费管理、统计分析等。

八、TCP/IP协议族
	TCP/IP只提供无连接、不可靠的服务。
	传输之前需要进行三次握手。
	IP的主要功能包括将上层数据(如TCP、UDP数据)或者同层的其它数据(如ICMP数据)封装到IP数据报中，将IP数据报传送到最终目的地；为了使数据能够在链路层上进行传输，对数据进行分段，确定数据报到达其它网络中的目的地的路径。
	1、应用层协议—文件传输服务(FTP)
	用来在计算机之间传输文件。
	实际Internet的FTP服务是一种匿名(anonymous)FTP服务，设置一个特殊的用户名-anonymous，供公众使用。
	匿名登录到FTP服务器后，其工作方式与常规FTP相同。通常处于安全目的，大多数匿名FTP服务器只允许下载，不允许上传文件。
	FTP在客户端到服务器建立2条TCP连接，一条是控制连接，主要用于传输命令和参数(端口21)；另一条是数据连接，主要用于传输文件(端口号20)。
	2、应用层协议—远程登录协议(Telnet)
	远程登录服务实在Telnet协议的支持下，将用户计算机和远程主机连接起来，在远程计算机上运行程序，用户输入的信息通过Telnet协议发送给远程主机，主机在TCP端口监听用户请求，并处理后，将结果通过Telnet协议返回给客户。客户再经过适当的转换显示在计算机屏幕上。因为使用Telnet命令进行远程登录，所有称为Telnet远程登录。
	由客户端软件、服务器软件以及Telnet通用协议三部分组成。
	3、应用层协议—电子邮件协议（SMTP)
	电子邮件(E-mail)利用计算机进行信息交换的电子媒体信件。
	基于客户端/服务器模式，有E-mail客户端软件、E-mail服务器、通信协议三部分组成。发送邮件，首先到达自己注册的邮件服务器主机，再在网络传输中经过多个计算机和路由中转到达目的地的邮件服务器主机，进入收件人的电子邮箱，最后邮件的接收者上网并启动电子邮件管理程序，会自动下载到自己计算机，完成接受邮件。
	SMTP：简单邮件传输协议
	MIME：Internet邮件扩充协议
	PEM：增强私密邮件保护协议
	POP：来保管用户未能及时取走的邮件，简单的纯文本协议，每次传输以正规E-mail为单位，不提供部分传输。
	4、传输层协议—TCP
	在IP提供的不可靠数据服务的基础上为应用程序提供一个可靠的、面向连接的、全双工的数据传输服务。TCP在源主机和目的之间建立和关闭连接操作是，均需要通过三次握手来确认建立和关闭是否成功。TCP虽然提供了一个可靠的数据传输服务，但是以牺牲通信量来实现的。
	TCP采用了重发技术： 发送数据时，启动定时器，在规定时间内没有收到确认信息，就重新发送数据包。
	5、传输层协议—UDP
	用户数据报协议是一种不可靠、无连接的协议，与同层面向连接的TCP相比，UDP是一种无连接的协议(无错误检测功能)。TCP有助于提供可靠的连接，UDP有助于提高传输的高速率性。不负责重新发送丢失的包，不对接收的数据进行排序，不消除重复的IP数据报，不负责建立和终止连接。(都是UDP应用程序负责的)
	TCP：交互式会话应用程序(FTP等)。
	UDP：自己进行错误检测、不需要检测错误(DNS、SNMP)。
	6、网际层协议—IP
	IP只提供无连接、不可靠的服务，把差错检测和流量控制之类的服务授权给了其他层的协议。
	IP的主要功能：
	将上层数据(TCP、UDP数据)或同层其他数据(ICMP数据)封装到IP数据报中；
	将IP数据报传送到最终目的地；
	为了使数据能够在链路层上进行传输，对数据进行分段；
	确定数据报到达其它网络中的目的地的路径。
	7、网际层协议—ICMP
	Internet控制信息协议，用于发送查错报文的协议。ICMP让IP更加稳固。也是利用IP来传送报文的。ping工具就是利用ICMP报文进行目标是否可达测试。
	5种差错报文：(源抑制、超时、目的不可达、重定向和要求分段)
	4种信息报文：回应请求、回应应答、地址屏蔽码请求和地址屏蔽码应答。
	8、网际层协议—ARP和RARP
	地址解析协议(ARP)和反地址解析协议(RARP)
	ARP的作用是将IP地址转为物理地址，RARP的作用是将物理地址转为IP地址。每台设备都有唯一的物理地址(通过网卡给出)，为了屏蔽底层协议及物理地址上的差异，IP协议又使用了IP地址。因此，在传输过程中，必须对IP地址和物理地址进行相互转换。
	9、网络接口层协议—以太网(Ethernet IEEE 802.3
	Ethernet IEEE 802.3：标准局域网，速度10Mps，传输介质为铜缆。
	Ethernet IEEE 802.3u：快速以太网，速度100Mps，传输介质为双绞线。
	Ethernet IEEE 802.3z：千兆以太网，速度1000Mps，传输介质为光纤或双绞线。
	10、网络接口层协议—令牌环网(Ethernet IEEE 802.5)
	1、只有拥有令牌才可以发送数据。
	2、发送数据时，需要捕获一个令牌。
	3、令牌不为空，需要等待。
	11、网络接口层协议—光纤分布式数据接口(FDDI)
	以光纤为传输介质。
	采用双环体系结构，两环上的信息反方向流动。双环中一环称为主环，另一个环称为次环。正常情况下，主环传输数据，次环处于空闲状态。
	双环设计的目的是提供高可靠性和稳定性。FDDI定义的传输介质有单模光纤和多模光纤两种。
	12、网络接口层协议—点对点协议(PPP)
	主要用于”拨号上网“这种广域连接模式。优点简单、具备用户验证功能、可以解决IP分配等。为各种主机、网桥和路由器之间简单连接的一种通用解决方案。
	利用以太网(Ethernet)资源在以太网上运行PPP来进行用户认证接入的方式成为PPPoE。是目前ADSL接入方式中最广泛的技术标准。
	ATM网络撒花姑娘运行PPP来管理用户再认证的方式成为PPPoA。
	PPPoA和PPPoE运行原理相同，不同的是运行环境的不同。
	13、其他—ADSL(非对称用户数据线)
	ADSL Modem上网拨号方式有3中，即专线方式(静态IP)、PPPoA和PPPoE。
	ADSL独享带宽，安全可靠。费用低廉,使用过去的电话线路，可以分离电话机和ADSL Modem(上网)。
	14、其他—IPv4和IPv6
	IPv4：32位二进制，能表示IP地址个数：2^32=40亿
	IPv6:128位二级制，能表示IP地址个数：2128=3.4*1038。

1、TCP和UDP的区别
	TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输；
	TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报；
	TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

2. TCP和UDP分别对应的常见应用层协议？
   2.1 TCP对应的应用层协议
    FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
    Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
    SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
    POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
    HTTP：从Web服务器传输超文本到本地浏览器的传送协议。
   2.2 UDP对应的应用层协议
    DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
    SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
    TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

   各协议对应的端口号

   摘自计算机网络(面试必备知识点)

3. TCP协议如何来保证传输的可靠性
   TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
   对于可靠性，TCP通过以下方式进行保证：
   数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据超时后会重发数据；
   对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
   丢弃重复数据：对于重复数据，能够丢弃重复数据；
   应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
   超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
   流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

4. 解释一下IP的定义，在哪个层上？主要作用是？TCP与UDP呢？
   IP是 Internet protocol 的缩写，是网络层的主要协议，作用是提供不可靠、无连接的数据包传输协传送。
    TCP是 Transmit Control Protocol（传输控制协议），在传输层，TCP提供一种面向连接的、可靠地字节流服务。
    UDP是 User Datagram Protocol（用户数据报协议），在传输层，UDP提供不可靠的传输控制数据服务。

5. IP地址的分类
   IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。
   　　
     每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：
    A类地址：以0开头，第一个字节范围：0~127；
    B类地址：以10开头，第一个字节范围：128~191；
    C类地址：以110开头，第一个字节范围：192~223；
    D类地址：以1110开头，第一个字节范围为224~239；
    E类地址：以1111开头，保留地址

6. 分别写出OSI、TCP/IP及五层协议的体系结构
   从上至下
   OSI：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
   TCP/IP：应用层、运输层、网际层、网络接口层；
   五层协议：应用层、运输层、网络层、数据链路层、物理层；

   6.1 OSI每一层对应的协议
   	体系	协议
   	物理层	RJ45、CLOCK、IEEE802.3 （中继器，集线器）
   	数据链路	PPP、FR、HDLC、VLAN、MAC（网桥，交换机）
   	网络层	IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、（路由器）
   	传输层	TCP、UDP、SPX
   	会话层	NFS、SQL、NETBIOS、RPC
   	表示层	JPEG、MPEG、ASII
   	应用层	FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
   	
   6.2 OSI每一层的作用
   	体系	作用
   	物理层	通过媒介传输比特,确定机械及电气规范（比特Bit）
   	数据链路层	将比特组装成帧和点到点的传递（帧Frame）
   	网络层	负责数据包从源到宿的传递和网际互连（包PackeT）
   	传输层	提供端到端的可靠报文传递和错误恢复（段Segment）
   	会话层	建立、管理和终止会话（会话协议数据单元SPDU）
   	表示层	对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
   	应用层	允许访问OSI环境的手段（应用协议数据单元APDU）
   	拓展：
   	网关的定义：一个链接两种不同协议簇的进程，为某一个特定的应用提供服务。
   	在TCP/IP协议簇中，IP层使用不可靠的服务，TCP提供可靠的服务，为了提供可靠到的服务，TCP采用了超时重传，发送和接收端到端的确认分组机制。
   	网桥是在数据链路层对网络进行互联的，路由器是在网络层对网络进行互联的。

7. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。典型的算法：DES
     由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。典型的算法：RSA

8. Get与POST的区别
   GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
   GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
   GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
   GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

9. ipconfig和netstat的作用？
   ipconfig显示当前TCP/IP配置的信息，帮助用户查看网络状况，可以看到很多网络信息，比如延迟，IP，主机信息，物理地址信息等。
   netstat主要用于提供系统的接口命令。可以使用相关参数打印出每一个接口的MTU、输入分组数、输入错误、冲突以及当前的输出队列长度。

10. 两台笔记本连起来后ping不同，可能是哪些原因？
    网线问题。确认网线连接是否正确，电脑之间连的线和电脑与USB之间连的线分正线、反线，是不同的。但是对于使用千兆网卡的除外，千兆位网卡有自动识别功课，既可以是正线也可以是反线。
    局域网设置问题。电脑互连是要设置的，看看是否安装了必要的网络协议，最重要的是，IP地址是否设置正确，互联的时候最好一台电脑为正，一台电脑为副，为主的设为网关。
    网卡驱动未正确安装
    防火墙设置有问题
    是否有什么软件阻止ping包

11. 运行net share返回结果是什么?
    显示本地计算机上所有共享资源相关信息。如果加上参数 ShareName ，则仅显示有关该共享的信息。

12. net use和net user 分别指什么？
     net use是对用户进行管理，如添加、删除网络使用用户等。
     net user 是对网络设备进行管理

13. 交换和路由的区别是什么，VLAN有什么特点？
    交换机是指转发和过滤帧，是交换机的工作，它在OSI参考模型的第二层。
    而路由器是指网络线路当中非直连的链路，它是路由器的工作，在OSI参考模型的第三层。
    交换和路由的区别很大。首先，交换是不需要IP的，而路由需要，因为IP就是第三层的协议，第二层需要的是MAC地址；再有，第二层可以做NAT、ACL、QOS等。
    VLAN是虚拟局域网络的英文缩写，它是一个纯二层的技术，它的特点有三个：控制广播，安全，灵活性和可扩展性。

14. 简单描述DNS域名系统的工作原理
    当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括3条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53.该应用一般不直接为用户使用，而是为其他应用服务，如HTTP,SMTP等，在其中需要完成主机名到IP地址的转换。
    ————————————————
    版权声明：本文为CSDN博主「lucky多多」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/weixin_41948075/article/details/88625382

15. 提供可靠数据流传输控制的是OSI的第几层？
    会话层

16. 在浏览器中输入www.baidu.com后执行的全部过程
    1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过该IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，通过TCP进行封装数据包，输入到网络层。
    2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口，然后使用IP层的IP地址查找目的端。
    3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过过哪个路径到达服务器。
    4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

17. ARP是地址解析协议，简单解释一下工作原理？
    首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
    当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
    当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
    源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。





![image-20230302085605768](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/image-20230302085605768-16777185673611.png)









```
http
	GET请求报文
		请求行
			---- 请求行 ----
GET / HTTP/1.1  # GET请求方式 请求资源路径 HTTP协议版本
		请求头
			---- 请求头 -----
Host: www.itcast.cn  # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Upgrade-Insecure-Requests: 1 # 让浏览器升级不安全请求，使用https请求
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36  # 用户代理，也就是客户端的名称
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 # 可接受的数据类型
Accept-Encoding: gzip, deflate # 可接受的压缩格式
Accept-Language: zh-CN,zh;q=0.9 #可接受的语言
Cookie: pgv_pvi=1246921728; # 登录用户的身份标识

		空行
			
---- 空行 ----
	POST请求报文
		请求行
			---- 请求行 ----
POST /xmweb?host=mail.itcast.cn&_t=1542884567319 HTTP/1.1 # POST请求方式 请求资源路径 HTTP协议版本
		请求头
			---- 请求头 ----
Host: mail.itcast.cn # 服务器的主机地址和端口号,默认是80
Connection: keep-alive # 和服务端保持长连接
Content-Type: application/x-www-form-urlencoded  # 告诉服务端请求的数据类型
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 # 客户端的名称

		空行
			---- 空行 ----
		请求体
			---- 请求体 ----
username=hello&pass=hello # 请求参数
	HTTP请求格式(请求协议)
		
	HTTP响应格式（响应协议）
		

URL的组成
	URL的样子:
		https://news.163.com/18/1122/10/E178J2O4000189FH.html
	URL的组成部分:
		协议部分: https://、http://、ftp://
		域名部分: news.163.com
		资源路径部分: /18/1122/10/E178J2O4000189FH.html

```

![img](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/867021-20180322001733298-201433635-16777206451324.jpg)



![img](D:/hgx笔记/hgxbijiben/7、刷题/计算机网络.assets/867021-20180322001744323-654009411-16777206363732.jpg)



